////////////////////////////////////////
//                                    //
//   MM2D Script: Height Mechanic     //
//                                    //
////////////////////////////////////////

//start Height
//Uses script placed flags 1-2 (inherent are ignored, only placed matter)
//98 = Warp up
//99 = Warp down
DEFINE CF_UP = 108;
DEFINE CF_DOWN = 109;
//For the DMap equivalent to the array index, what DMap is "above" this? -1 for "this is the top"
int DMAP_UP[] = {1,2,-1,4,5,-1};
//For the DMap equivalent to the array index, what DMap is "below" this? -1 for "this is the bottom"
int DMAP_DOWN[] = {-1,0,1,-1,3,4};
void heightWarp()
{
	if(isCenteredOnPlacedFlag(CF_DOWN,true,false,CT_WATER,false,true,CF_SCRIPT1))
	{
		unless(floating||Deku_flying||!canFall)
		{
			warpDown();
		}
	}
	else if(isCenteredOnPlacedFlag(CF_UP,true,false,CT_WATER,false,true,CF_SCRIPT1))
	{
		if(warpUp())
		{
			if(floating)floating=1;
			Deku_flying=0;
		}
	}
}

bool warpUp()
{
	int dmap = getUpDMap();
	if(dmap!=-1)
	{
		int scr = getUpScreen(true);
		warpHeight(dmap,scr);
		return true;
	}
	return false;
}

bool warpDown()
{
	int dmap = getDownDMap();
	if(dmap!=-1)
	{
		int scr = getDownScreen(true);
		warpHeight(dmap,scr);
		return true;
	}
	return false;
}

void warpHeight(int dmap, int scr)
{
	handleSpriteLayers1();
	Hero->WarpEx({WT_IWARP,dmap,scr,Hero->X,Hero->Y,WARPEFFECT_NONE,0,0x100});
	handleSpriteLayers2(dmap);
}

int getDownDMap()
{
	if(GetCurDMap() >= SizeOfArray(DMAP_DOWN))return -1;
	return DMAP_DOWN[Game->GetCurDMap()];
}

int getDownScreen(bool mod)
{
	int dmap = getDownDMap();
	if(dmap==-1)return -1;
	if(mod)
		return MapToDMap(Screen->LayerScreen(3),dmap);
	return Screen->LayerScreen(3);
}

int getUpDMap()
{
	if(GetCurDMap() >= SizeOfArray(DMAP_UP))return -1;
	return DMAP_UP[Game->GetCurDMap()];
}

int getUpScreen(bool mod)
{
	int dmap = getUpDMap();
	if(dmap==-1)return -1;
	if(mod)
		return MapToDMap(Screen->LayerScreen(4),dmap);
	return Screen->LayerScreen(4);
}

bool isCenteredOnPlacedFlag(int flag, bool notType, bool yesType, int type, bool notInherent, bool yesInherent, int inherent)
{
	int x = Hero->X;
	int y = Hero->Y;
	int c1 = ComboAt(Hero->X+2,Hero->Y+9);
	int c2 = ComboAt(Hero->X+12,Hero->Y+9);
	int c3 = ComboAt(Hero->X+12,Hero->Y+12);
	int c4 = ComboAt(Hero->X+2,Hero->Y+12);
	if(notType)
	{
		if(notInherent)
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]!=inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]!=inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]!=inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]!=inherent);
		}
		else if(yesInherent)
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]==inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]==inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]==inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]==inherent);
		}
		else
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type);
		}
	}
	else if(yesType)
	{
		if(notInherent)
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]!=inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]!=inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]!=inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]!=inherent);
		}
		else if(yesInherent)
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]==inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]==inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]==inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]==inherent);
		}
		else
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]==type)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]==type)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]==type)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]==type);
		}
	}
	else
	{
		if(notInherent)
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboI[c1]!=inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboI[c2]!=inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboI[c3]!=inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboI[c4]!=inherent);
		}
		else if(yesInherent)
		{
			return (Screen->ComboF[c1]==flag&&Screen->ComboI[c1]==inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboI[c2]==inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboI[c3]==inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboI[c4]==inherent);
		}
		else
		{
			return Screen->ComboF[c1]==flag&&Screen->ComboF[c2]==flag&&Screen->ComboF[c3]==flag&&Screen->ComboF[c4]==flag;
		}
	}
}

bool isTouchingComboType(int combotype)
{
	int x = Hero->X;
	int y = Hero->Y;
	if(Screen->ComboT[ComboAt(Hero->X,Hero->Y+8)]==combotype)return true;
	if(Screen->ComboT[ComboAt(Hero->X+15,Hero->Y+8)]==combotype)return true;
	if(Screen->ComboT[ComboAt(Hero->X,Hero->Y+15)]==combotype)return true;
	if(Screen->ComboT[ComboAt(Hero->X+15,Hero->Y+15)]==combotype)return true;
	return false;
}
//end Height
//start FallDown
void checkFall()
{
	unless(floating||Deku_flying||!canFall||Hero->Action==LA_RAFTING)
	{
		linkPitfall();
	}
}

void linkPitfall()
{
	int dmap = getDownDMap();
	int scr = getDownScreen(true);
	unless(dmap==-1||scr==-1)
	{
		int combosAt[] = {ComboAt(Hero->X+3,Hero->Y+9),ComboAt(Hero->X+12,Hero->Y+9),ComboAt(Hero->X+3,Hero->Y+12),ComboAt(Hero->X+12,Hero->Y+12)};
		for(int i = 0;i<4;i++)
		{
			if(Screen->ComboT[combosAt[i]]==CT_PITFALL)
			{
				int dir = Hero->Dir;
				//
				Hero->X=ComboX(combosAt[i]);
				Hero->Y=ComboY(combosAt[i]);
				//
				if(Hero->X<16)Hero->X+=2;
				else if(Hero->X>16*14)Hero->X-=2;
				if(Hero->Y<16)Hero->Y+=2;
				else if(Hero->Y>16*9)Hero->Y-=2;
				//
				freezeFrames=5;
				//
				warpHeight(dmap,scr);
				//
				/*char msg[] = "Pitwarping! Dmap, Scr:";
				TraceS(msg);
				Trace(dmap);
				Trace(scr);*/
				//
				Hero->Dir=dir;
			}
		}
	}
}
//end FallDown
//start Jump
void checkJump()
{
	if(form!=2)
	{
		if(canFall&&!floating&&!Deku_flying)
		{
			int jumpDir = wouldJump();
			if(jumpDir!=-1)
			{
				floatDir = jumpDir;
				setFloating();
				canFall=false;
			}
		}
	}
	else unless(floating||form!=2)
	{
		rampJump();
	}
	jump();
}

void setFloating()
{
	bool sfx = true;
	floating = getFloating();
	if(floating==-1)return;
	unless(floating)sfx = false;
	floatPix=2;
	if(sfx)
		Game->PlaySound(SFX_JUMPING);
}

int getFloating()
{
	if(!form || form==4)
	{
		if(mask==12)return 32;
		return 24;
	}
	else if(form==1)
	{
		return 16;
	}
	else if(form==3)
	{
		return 32;
	}
	else if(form==2)
	{
		return 0;
	}
	return -1;
}

void jump()//start jump
{
	if(floating!=0)
	{
		if(floating>0)
		{
			int movPix = floatPix;
			if(LinkOnFlagMod(CF_SCRIPT20,dirX(floatDir)*floatPix,(dirY(floatDir)*floatPix),2,false))
			{
				movPix=0;
			}
			Hero->X+=dirX(floatDir)*movPix;
			Hero->Y+=dirY(floatDir)*movPix;
			floating--;
		}
		if(floating<=0)
		{
			if(floatDir==DIR_DOWN||floatDir==DIR_UP)
			{
				Hero->Y=GridY(Hero->Y+12);
			}
			else if(floatDir==DIR_RIGHT||floatDir==DIR_LEFT)
			{
				Hero->X=GridX(Hero->X+8);
			}
			int timeOut = 25;//Prevent infinite loop
			int jumpDir = wouldJump();
			while(jumpDir!=-1&&timeOut>0)
			{
				if(jumpDir==DIR_DOWN)Hero->Y--;
				if(jumpDir==DIR_RIGHT)Hero->X--;
				if(jumpDir==DIR_LEFT)Hero->X++;
				if(jumpDir==DIR_UP)Hero->Y++;
				jumpDir=wouldJump();
				timeOut--;
			}
			canFall=true;
			Hero->Invisible=false;
			floating=0;
		}
		else
		{
			//Draw Hero's jumping tile over him, with a Y-Offset based on how far through the jump he is, peaking at the middle.
			int maxFloating = getFloating();
			if(curled)
			{
				maxFloating=getRampFloat();
			}
			maxFloating*=floatPix;
			int yOffSet = (floating*floatPix) - (maxFloating/2);
			if(yOffSet>0)yOffSet*=-1;
			yOffSet += (maxFloating/2);	
			yOffSet *= -1;
			yOffSet /= 2;//Reduce the absurdity of the height
			//Trace(yOffSet);
			replaceLinkTile(40,3,6,0,yOffSet,true);
			//
			unless(form)
			{
				killActionsBut({CB_A});
			}
			else
			{
				NoAction();
			}
		}
	}
}//end jump
//start tilemods
DEFINE TILE_LINKUL = 10400;
DEFINE TILE_LINKSHADOW = 10453;

void replaceLinkTile(int mod, int aframes, int aspeed,int xOffSet,int yOffSet,bool drawShadow)
{
	aframes = Max(aframes,1);aspeed = Max(aspeed,1);
	Hero->Invisible=true;
	int linkTile = TILE_LINKUL+mod;
	linkTile+=Hero->Dir*aframes;
	linkTile+=Floor((gameframe%(aframes*aspeed))/aspeed);
	linkTile+=getLinkTileModifier();
	if(drawShadow)
	{
		Screen->FastTile(1,Hero->X,Hero->Y,TILE_LINKSHADOW,6,OP_TRANS);
	}
	Screen->FastTile(1,Hero->X+xOffSet,Hero->Y+yOffSet,linkTile,6,OP_OPAQUE);
}

int getLinkTileModifier()
{
	if(Hero->Item[FORM1])return idata::GetLinkTileModifier(FORM1);
	else if(Hero->Item[FORM2])return idata::GetLinkTileModifier(FORM2);
	else if(Hero->Item[FORM3])return idata::GetLinkTileModifier(FORM3);
	else if(Hero->Item[FORM4])return idata::GetLinkTileModifier(FORM4);
	else if(Hero->Item[FORM2CURLED])return idata::GetLinkTileModifier(FORM2CURLED);
	else if(Hero->Item[FORM_SHIELD])return idata::GetLinkTileModifier(FORM_SHIELD);
	else if(Hero->Item[FORM_M_SHIELD])return idata::GetLinkTileModifier(FORM_M_SHIELD);
	else if(Hero->Item[FORM2SPIKED])return idata::GetLinkTileModifier(FORM2SPIKED);
	else return 0;
}//end tilemods

int wouldJump()//start
{
	int linkCombo = ComboAt(Hero->X+8,Hero->Y+12);
	int linkPlacedFlag = Screen->ComboF[linkCombo];
	if(Screen->ComboI[linkCombo]==CF_SCRIPT1&&Screen->ComboT[linkCombo]!=CT_WATER)
	{
		if(Hero->Dir==DIR_DOWN&&Input->Button[CB_DOWN]&&linkPlacedFlag==CF_SCRIPT1&&linkCombo!=ComboAt(Hero->X+8,Hero->Y+16))
		{
			return DIR_DOWN;
		}
		else if(Hero->Dir==DIR_RIGHT&&Input->Button[CB_RIGHT]&&linkPlacedFlag==CF_SCRIPT2&&linkCombo!=ComboAt(Hero->X+16,Hero->Y+12))
		{
			return DIR_RIGHT;
		}
		else if(Hero->Dir==DIR_LEFT&&Input->Button[CB_LEFT]&&linkPlacedFlag==CF_SCRIPT3&&linkCombo!=ComboAt(Hero->X-1,Hero->Y+12))
		{
			return DIR_LEFT;
		}
		else if(Hero->Dir==DIR_UP&&Input->Button[CB_UP]&&linkPlacedFlag==CF_SCRIPT4&&linkCombo!=ComboAt(Hero->X+8,Hero->Y+7))
		{
			return DIR_UP;
		}
		else if(Hero->Dir==DIR_DOWN&&Input->Button[CB_DOWN]&&(Screen->ComboF[linkCombo]==CF_SCRIPT7||Screen->ComboF[linkCombo]==CF_SCRIPT5||Screen->ComboF[linkCombo]==CF_SCRIPT13)&&linkCombo!=ComboAt(Hero->X+8,Hero->Y+16))
		{
			return DIR_DOWN;
		}
		else if(Hero->Dir==DIR_RIGHT&&Input->Button[CB_RIGHT]&&(Screen->ComboF[linkCombo]==CF_SCRIPT5||Screen->ComboF[linkCombo]==CF_SCRIPT6||Screen->ComboF[linkCombo]==CF_SCRIPT14)&&linkCombo!=ComboAt(Hero->X+16,Hero->Y+12))
		{
			return DIR_RIGHT;
		}
		else if(Hero->Dir==DIR_LEFT&&Input->Button[CB_LEFT]&&(Screen->ComboF[linkCombo]==CF_SCRIPT8||Screen->ComboF[linkCombo]==CF_SCRIPT7||Screen->ComboF[linkCombo]==CF_SCRIPT14)&&linkCombo!=ComboAt(Hero->X-1,Hero->Y+12))
		{
			return DIR_LEFT;
		}
		else if(Hero->Dir==DIR_UP&&Input->Button[CB_UP]&&(Screen->ComboF[linkCombo]==CF_SCRIPT6||Screen->ComboF[linkCombo]==CF_SCRIPT8||Screen->ComboF[linkCombo]==CF_SCRIPT13)&&linkCombo!=ComboAt(Hero->X+8,Hero->Y+7))
		{
			return DIR_UP;
		}
	}
	return -1;
}//end
//start RampJump
void rampJump()
{
	if(curled&&timeRolling>=100)
	{
		int downCombo = ComboAt(Hero->X+8,Hero->Y+15);
		int rightCombo = ComboAt(Hero->X+15,Hero->Y+12);
		int leftCombo = ComboAt(Hero->X,Hero->Y+12);
		int upCombo = ComboAt(Hero->X+8,Hero->Y+8);
		if(Hero->Dir==DIR_DOWN&&Screen->ComboT[downCombo]==CT_LEDGE&&Screen->ComboI[downCombo]==CF_SCRIPT2&&Screen->ComboS[downCombo]==1010b)
		{
			floatDir=DIR_DOWN;
			Hero->Y=ComboY(downCombo);
			setRampFloat();
			rampWarpUp(downCombo);
		}
		else if(Hero->Dir==DIR_RIGHT&&Screen->ComboT[rightCombo]==CT_LEDGE&&Screen->ComboI[rightCombo]==CF_SCRIPT2&&Screen->ComboS[rightCombo]==1100b)
		{
			floatDir=DIR_RIGHT;
			Hero->X=ComboX(rightCombo);
			setRampFloat();
			rampWarpUp(rightCombo);
		}
		else if(Hero->Dir==DIR_LEFT&&Screen->ComboT[leftCombo]==CT_LEDGE&&Screen->ComboI[leftCombo]==CF_SCRIPT2&&Screen->ComboS[leftCombo]==0011b)
		{
			floatDir=DIR_LEFT;
			Hero->X=ComboX(leftCombo);
			setRampFloat();
			rampWarpUp(leftCombo);
		}
		else if(Hero->Dir==DIR_UP&&Screen->ComboT[upCombo]==CT_LEDGE&&Screen->ComboI[upCombo]==CF_SCRIPT2&&Screen->ComboS[upCombo]==0101b)
		{
			floatDir=DIR_UP;
			Hero->Y=ComboY(upCombo);
			setRampFloat();
			rampWarpUp(upCombo);
		}
	}
}

void setRampFloat()
{
	if(spikedRolling)
	{
		floatPix=8;
	}
	else
	{
		floatPix=4;
	}
	floating=getRampFloat();
}

int getRampFloat()
{
	if(spikedRolling)
	{
		return 16;
	}
	else
	{
		return 20;
	}
}

void rampWarpUp(int theCombo)
{
	if(Screen->ComboF[theCombo]==CF_SCRIPT1)
	{
		warpUp();
	}
	else if(Screen->ComboF[theCombo]==CF_SCRIPT2)
	{
		if(warpUp())
		{
			Waitframe();
			warpUp();
		}
	}
}
//end RampJump
//end Jump
//start Sprite Height Handling
//start Global Weapons Arrays
DEFINE LWMISC_LAYERDMAP = 31;
DEFINE EWMISC_LAYERDMAP = 31;
DEFINE NPCMISC_LAYERDMAP = 31;
DEFINE ITEMMISC_LAYERDMAP = 31;
DEFINE ITEMMISC_ISNOHIT = 30;

void handleSpriteLayers1()
{
	DEFINE NUMLW = Screen->NumLWeapons();
	DEFINE NUMEW = Screen->NumEWeapons();
	DEFINE NUMNPC = Screen->NumNPCs();
	DEFINE NUMITEM = Screen->NumItems();
	DEFINE THISDMAP = Game->GetCurDMap();
	for(int q = MIN_LWEAPON; q<=NUMLW; ++q)
	{
		lweapon weap = Screen->LoadLWeapon(q);
		unless(weap->Misc[LWMISC_LAYERDMAP])weap->Misc[LWMISC_LAYERDMAP] = THISDMAP+1;
	}
	for(int q = MIN_EWEAPON; q<=NUMEW; ++q)
	{
		eweapon weap = Screen->LoadEWeapon(q);
		unless(weap->Misc[EWMISC_LAYERDMAP])weap->Misc[EWMISC_LAYERDMAP] = THISDMAP+1;
	}
	for(int q = MIN_NPC; q<=NUMNPC; ++q)
	{
		npc n = Screen->LoadNPC(q);
		unless(n->Misc[NPCMISC_LAYERDMAP])n->Misc[NPCMISC_LAYERDMAP] = THISDMAP+1;
	}
	for(int q = MIN_ITEM; q<=NUMITEM; ++q)
	{
		item it = Screen->LoadItem(q);
		unless(it->Misc[ITEMMISC_LAYERDMAP])it->Misc[ITEMMISC_LAYERDMAP] = THISDMAP+1;
		if(it->Pickup & (IP_ST_ITEM|IP_ST_SPECIALITEM)) Remove(it);
	}
}

void handleSpriteLayers2(int newdmap)
{
	DEFINE NUMITEM = Screen->NumItems();
	for(int q = MIN_ITEM; q<=NUMITEM; ++q)
	{
		item it = Screen->LoadItem(q);
		if(it->Misc[ITEMMISC_LAYERDMAP] == (newdmap+1))
		{
			if(it->Misc[ITEMMISC_ISNOHIT]) it->HitXOffset -= 1000;
			it->Misc[ITEMMISC_ISNOHIT] = false;
		}
		else
		{
			unless(it->Misc[ITEMMISC_ISNOHIT]) it->HitXOffset += 1000;
			it->Misc[ITEMMISC_ISNOHIT] = true;
		}
	}
}
//start relativeHeight
int getRelativeHeight(lweapon weap)
{
	unless(weap->Misc[LWMISC_LAYERDMAP])weap->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return weap->Misc[LWMISC_LAYERDMAP] - (Game->GetCurDMap() + 1);
}

int getRelativeHeight(eweapon weap)
{
	unless(weap->Misc[LWMISC_LAYERDMAP])weap->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return weap->Misc[EWMISC_LAYERDMAP] - (Game->GetCurDMap() + 1);
}

int getRelativeHeight(npc n)
{
	unless(n->Misc[LWMISC_LAYERDMAP])n->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return n->Misc[NPCMISC_LAYERDMAP] - (Game->GetCurDMap() + 1);
}

int getRelativeHeight(lweapon o1, lweapon o2)
{
	unless(o1->Misc[LWMISC_LAYERDMAP])o1->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[LWMISC_LAYERDMAP])o2->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[LWMISC_LAYERDMAP] - o2->Misc[LWMISC_LAYERDMAP];
}

int getRelativeHeight(lweapon o1, eweapon o2)
{
	unless(o1->Misc[LWMISC_LAYERDMAP])o1->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[EWMISC_LAYERDMAP])o2->Misc[EWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[LWMISC_LAYERDMAP] - o2->Misc[EWMISC_LAYERDMAP];
}

int getRelativeHeight(eweapon o1, lweapon o2)
{
	unless(o1->Misc[EWMISC_LAYERDMAP])o1->Misc[EWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[LWMISC_LAYERDMAP])o2->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[EWMISC_LAYERDMAP] - o2->Misc[LWMISC_LAYERDMAP];
}

int getRelativeHeight(eweapon o1, eweapon o2)
{
	unless(o1->Misc[EWMISC_LAYERDMAP])o1->Misc[EWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[EWMISC_LAYERDMAP])o2->Misc[EWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[EWMISC_LAYERDMAP] - o2->Misc[EWMISC_LAYERDMAP];
}

int getRelativeHeight(npc o1, lweapon o2)
{
	unless(o1->Misc[NPCMISC_LAYERDMAP])o1->Misc[NPCMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[LWMISC_LAYERDMAP])o2->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[NPCMISC_LAYERDMAP] - o2->Misc[LWMISC_LAYERDMAP];
}

int getRelativeHeight(lweapon o1, npc o2)
{
	unless(o1->Misc[LWMISC_LAYERDMAP])o1->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[NPCMISC_LAYERDMAP])o2->Misc[NPCMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[LWMISC_LAYERDMAP] - o2->Misc[NPCMISC_LAYERDMAP];
}

int getRelativeHeight(npc o1, npc o2)
{
	unless(o1->Misc[NPCMISC_LAYERDMAP])o1->Misc[NPCMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[NPCMISC_LAYERDMAP])o2->Misc[NPCMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[NPCMISC_LAYERDMAP] - o2->Misc[NPCMISC_LAYERDMAP];
}

int getRelativeHeight(npc o1, eweapon o2)
{
	unless(o1->Misc[NPCMISC_LAYERDMAP])o1->Misc[NPCMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[EWMISC_LAYERDMAP])o2->Misc[EWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[NPCMISC_LAYERDMAP] - o2->Misc[EWMISC_LAYERDMAP];
}

int getRelativeHeight(eweapon o1, npc o2)
{
	unless(o1->Misc[EWMISC_LAYERDMAP])o1->Misc[EWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	unless(o2->Misc[NPCMISC_LAYERDMAP])o2->Misc[NPCMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
	return o1->Misc[EWMISC_LAYERDMAP] - o2->Misc[NPCMISC_LAYERDMAP];
}
//end relativeHeight

//start mapdata
mapdata getLayerMapdata(int relativeHeight)
{
	dmapdata dmap = Game->LoadDMapData(Game->GetCurDMap() + relativeHeight);
	return Game->LoadMapData(dmap->Map,Game->GetCurScreen());
}

/*mapdata getBottomMapdata()
{
	int dmap = Game->GetCurDMap();
	if(dmap > SizeOfArray(DMAP_DOWN)) return NULL;
	while(DMAP_DOWN[dmap] != -1)
		dmap = DMAP_DOWN[dmap];
	return Game->LoadMapData(Game->LoadDMapData(dmap)->Map, Game->GetCurScreen());
}

mapdata getTopMapdata()
{
	int dmap = Game->GetCurDMap();
	if(dmap > SizeOfArray(DMAP_UP)) return NULL;
	while(DMAP_UP[dmap] != -1)
		dmap = DMAP_UP[dmap];
	return Game->LoadMapData(Game->LoadDMapData(dmap)->Map, Game->GetCurScreen());
}

mapdata getMapdataIndex(int offset)
{
	int dmap = Game->GetCurDMap();
	if(dmap > SizeOfArray(DMAP_DOWN)) return NULL;
	while(DMAP_DOWN[dmap] != -1)
		dmap = DMAP_DOWN[dmap];
	//dmap == bottom dmap
	//Go up `offset` number of dmaps
	for(int q = 0; q < offset && dmap != -1; ++q)
		dmap = DMAP_UP[dmap];
	if(dmap == -1) return NULL;
	return Game->LoadMapData(Game->LoadDMapData(dmap)->Map, Game->GetCurScreen());
}*/
//end mapdata
//end

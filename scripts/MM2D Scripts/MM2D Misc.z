////////////////////////////////////////
//                                    //
//     MM2D Script: Miscellaneous     //
//                                    //
////////////////////////////////////////

namespace MM2D
{
	//start CanWalkM
	/**
	* This function (and set of overloads) acts as CanWalk, but uses an arbitrary 
	*      `mapdata` pointer for solidity, rather than the current screen.
	* Related: `CurMapdata()`
	*/

	//lweapon
	bool CanWalkM(lweapon weap, mapdata map, int dir, int step)
	{
		return CanWalkM(weap, map, dir, step, false);
	}

	bool CanWalkM(lweapon weap, mapdata map, int dir, int step, bool useHit)
	{
		unless(weap->isValid())return false;
		return CanWalkM(weap->X + (useHit ? weap->Misc[SPRITE_MISC_HITXOFFSET] : 0), weap->Y + (useHit ? weap->HitYOffset : 0), weap->X + (useHit ?  weap->HitWidth + weap->Misc[SPRITE_MISC_HITXOFFSET] :  weap->TileWidth * 16) - 1, weap->Y + (useHit ?  weap->HitHeight + weap->HitYOffset :  weap->TileHeight * 16) - 1, map, dir, step);
	}
	//eweapon
	bool CanWalkM(eweapon weap, mapdata map, int dir, int step)
	{
		return CanWalkM(weap, map, dir, step, false);
	}

	bool CanWalkM(eweapon weap, mapdata map, int dir, int step, bool useHit)
	{
		unless(weap->isValid())return false;
		return CanWalkM(weap->X + (useHit ? weap->Misc[SPRITE_MISC_HITXOFFSET] : 0), weap->Y + (useHit ? weap->HitYOffset : 0), weap->X + (useHit ?  weap->HitWidth + weap->Misc[SPRITE_MISC_HITXOFFSET] :  weap->TileWidth * 16) - 1, weap->Y + (useHit ?  weap->HitHeight + weap->HitYOffset :  weap->TileHeight * 16) - 1, map, dir, step);
	}
	//npc
	bool CanWalkM(npc n, mapdata map, int dir, int step)
	{
		return CanWalkM(n, map, dir, step, false);
	}

	bool CanWalkM(npc n, mapdata map, int dir, int step, bool useHit)
	{
		unless(n->isValid())return false;
		return CanWalkM(n->X + (useHit ? n->Misc[SPRITE_MISC_HITXOFFSET] : 0), n->Y + (useHit ? n->HitYOffset : 0), n->X + (useHit ?  n->HitWidth + n->Misc[SPRITE_MISC_HITXOFFSET] :  n->TileWidth * 16) - 1, n->Y + (useHit ?  n->HitHeight + n->HitYOffset :  n->TileHeight * 16) - 1, map, dir, step);
	}
	//ffc
	bool CanWalkM(ffc f, mapdata map, int dir, int step)
	{
		return CanWalkM(f, map, dir, step, false);
	}

	bool CanWalkM(ffc f, mapdata map, int dir, int step, bool useEffect)
	{
		return CanWalkM(f->X, f->Y, f->X + (useEffect ?  f->EffectWidth :  f->TileWidth * 16) - 1, f->Y + (useEffect ?  f->EffectHeight :  f->TileHeight * 16) - 1, map, dir, step);
	}
	//Link
	bool CanWalkM(mapdata map, int dir, int step, bool largeHitbox)
	{
		return CanWalkM(Hero->X, Hero->Y + (largeHitbox ?  0 :  8), Hero->X + 15, Hero->Y + 15, map, dir, step);
	}
	//Main
	//Uses VenrobMisc.zh's version
	//end CanWalkM
}
//start Misc Functions
void saveTheGame()//start
{
	if(noSave)return;
	Screen->DrawScreen(7,LAYERSMAP1,LAYERSCREEN_SAVING,0,0,0);
	Waitframe();
	Game->Save();
}//end
bool linkWalkingOntoFlag(int flag, int setting,bool fullTile)//start
{
	int lspeed = Ceiling(1.5+LinkMovement_GetLinkSpeedBoost());
	return LinkOnFlagMod(flag,LinkMovement[LM_STICKX]*lspeed,LinkMovement[LM_STICKY]*lspeed,setting,fullTile);
}//end
bool LinkOnFlagMod(int flag, int x, int y, int setting, bool fullTile)//start
{
	int yCorrection = 0;
	unless(fullTile)yCorrection=8;
	int combos[4] = {ComboAt(Hero->X+x,Hero->Y+y+yCorrection),ComboAt(Hero->X+x+15,Hero->Y+y+yCorrection),ComboAt(Hero->X+x+15,Hero->Y+y+15),ComboAt(Hero->X+x,Hero->Y+y+15)};
	for(int i=0;i<4;i++)
	{
		if(setting)
			if(Screen->ComboI[combos[i]]==flag)return true;
		if(setting!=1)
			if(Screen->ComboF[combos[i]]==flag)return true;
	}
	return false;
}//end
bool LinkOnFlag(int flag)//start
{
	int combos[4] = {ComboAt(Hero->X,Hero->Y),ComboAt(Hero->X+15,Hero->Y),ComboAt(Hero->X+15,Hero->Y+15),ComboAt(Hero->X,Hero->Y+15)};
	for(int i=0;i<4;i++)
	{
		if(Screen->ComboF[combos[i]]==flag)return true;
	}
	return false;
}//end
void stopScreenTransition(int pxD,int pxR,int pxL, int pxU)//start
{
	if(Hero->Y>160-pxD)Input->Button[CB_DOWN]=false;
	if(Hero->X>240-pxR)Input->Button[CB_RIGHT]=false;
	if(Hero->X<0+pxL)Input->Button[CB_LEFT]=false;
	if(Hero->Y<0+pxU)Input->Button[CB_UP]=false;
}//end
void TotalNoAction()//start
{
	for(int q = 0; q < CB_MAX; ++q)
	{
		Input->Button[q] = false;
		Input->Press[q] = false;
	}
}//end
void WaitTotalNoAction()//start
{
	WaitTotalNoAction(1);
}//end
void WaitTotalNoAction(int frames)//start
{
	for(int j = 0; j < frames; ++j)
	{
		TotalNoAction();
		Waitframe();
	}
}//end
void killActions(int actions)//start
{
	for(int q = SizeOfArray(actions) - 1; q >= 0; --q)
	{
		Input->Button[actions[q]] = false;
		Input->Press[actions[q]] = false;
	}
}//end
void killActionsBut(int actions)//start
{
	DEFINE SIZE = SizeOfArray(actions);
	for(int q = 0; q < CB_MAX; ++q)
	{
		//Skip past any actions in the whitelist
		for(int j = SIZE-1; j >= 0; --j)
		{
			unless(q < CB_MAX) return;
			if(q == actions[j])
			{
				++q;
				j = SIZE-1;
			}
		}
		//Disable anything else
		Input->Button[q] = false;
		Input->Press[q] = false;
	}
}//end
bool isTouchingCombo(int comboID)//start
{
	int x = Hero->X;
	int y = Hero->Y;
	if(Screen->ComboD[ComboAt(Hero->X,Hero->Y+8)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Hero->X+15,Hero->Y+8)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Hero->X,Hero->Y+15)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Hero->X+15,Hero->Y+15)]==comboID)return true;
	return false;
}//end
void NoDirs()//start
{
	killActions({CB_DOWN,CB_UP,CB_LEFT,CB_RIGHT});
}//end
int countNPCInRange(int x, int y, int radius)//start
{
	int npcCount = 0;
	for(int i = Screen->NumNPCs();i>0;--i)
	{
		npc anNPC = Screen->LoadNPC(i);
		if(anNPC->X>x-(radius+anNPC->HitWidth-1)&&anNPC->X<x+radius&&anNPC->Y>y-(radius+anNPC->HitHeight-1)&&anNPC->Y<y+radius)
		{
			npcCount++;
		}
	}
	return npcCount;
}//end
npc getNthNPCInRange(int x, int y, int radius, int num)//start
{
	int npcCount = 0;
	for(int i = Screen->NumNPCs();i>0;--i)
	{
		npc anNPC = Screen->LoadNPC(i);
		if(anNPC->X>x-(radius+anNPC->HitWidth-1)&&anNPC->X<x+radius&&anNPC->Y>y-(radius+anNPC->HitHeight-1)&&anNPC->Y<y+radius)
		{
			if(npcCount==num)
			{
				return anNPC;
			}
			else
			{
				npcCount++;
			}
		}
	}
}//end
void Screen_Freeze(int freeze)//start
{
	ffc f1 = Screen->LoadFFC(31);
	ffc f2 = Screen->LoadFFC(32);
	if(freeze==2)
	{
		f1->Data = COMBO_FRZ1;
		f2->Data = COMBO_FRZ2;
		isFrozen=true;
	}
	else if(freeze==1)
	{
		f1->Data = COMBO_FRZ1;
		f2->Data = 0;
		isFrozen=true;
	}
	else
	{
		f1->Data = 0;
		f2->Data = 0;
		isFrozen=false;
	}
}

int Get_Freeze()
{
	ffc f1 = Screen->LoadFFC(31);
	ffc f2 = Screen->LoadFFC(32);
	return (f1->Data == COMBO_FRZ1) ? (f2->Data == COMBO_FRZ2 ? 1 : 2) : (0);
}//end
int getNPCfromUID(npc n)//start
{
	for(int i = 1;i<=Screen->NumNPCs();i++)
	{
		npc anNPC = Screen->LoadNPC(i);
		if(anNPC->UID==n->UID)return i;
	}
	return -1;
}//end
int LimitFPSStateSave = 00b;//start
void saveFPSstate()
{
	/*unless(LimitFPSStateSave & 10b)
	{
		if(Game->CappedFPS)LimitFPSStateSave |= 11b;
		else LimitFPSStateSave |= 10b;
	}*/
}

void loadFPSstate()
{
	/*if((LimitFPSStateSave & 10b) == 10b)
	{
		if((LimitFPSStateSave & 01b) == 01b)Game->CappedFPS = true;
		else Game->CappedFPS = false;
		LimitFPSStateSave = 0;
	}*/
}//end
int fullCounter(int counter)//start
{
	return Game->Counter[counter]+Game->DCounter[counter];
}//end
bool isOverworldScreen()//start
{
	dmapdata dm = Game->LoadDMapData(Game->GetCurDMap());
	if(IsDungeonFlag())return false;
	if(IsInteriorFlag())return false;
	if(dm->Type%2)return true;
	return false;
}//end
void FastLine(int layer, int x, int y, int x2, int y2, int color, int opacity)//start
{
	Screen->Line(layer, x, y, x2, y2, color, 0, 0, 0, 0, opacity);
}//end
void HeightFastLine(int layer, int x, int y, int x2, int y2, int color, int opacity)//start
{
	HeightLine(layer, x, y, x2, y2, color, 0, 0, 0, 0, opacity);
}//end
void killAllSfx() //start
{
	for(int q = 1; q < 256; ++q) Audio->EndSound(q);
}//end
void pauseAllSfx() //start
{
	for(int q = 1; q < 256; ++q) Audio->PauseSound(q);
}//end
void resumeAllSfx() //start
{
	for(int q = 1; q < 256; ++q) Audio->ResumeSound(q);
}//end
int getPressedDir8() //start
{
	if(Input->Button[CB_RIGHT] && Input->Button[CB_DOWN]) return DIR_RIGHTDOWN;
	if(Input->Button[CB_LEFT] && Input->Button[CB_DOWN]) return DIR_LEFTDOWN;
	if(Input->Button[CB_LEFT] && Input->Button[CB_UP]) return DIR_LEFTUP;
	if(Input->Button[CB_RIGHT] && Input->Button[CB_UP]) return DIR_RIGHTUP;
	if(Input->Button[CB_RIGHT]) return DIR_RIGHT;
	if(Input->Button[CB_DOWN]) return DIR_DOWN;
	if(Input->Button[CB_LEFT]) return DIR_LEFT;
	if(Input->Button[CB_UP]) return DIR_UP;
	return -1;
}//end
int validateDir(int dir, int defaultdir) //start
{
	if(dir<0||dir>7)return defaultdir;
	return dir;
}//end
bool offscreen(int x, int y) //start
{
	return x <= 3 || x >= 237 || y <= 1 || y >= 157;
}//end
void resetMusic() //start
{
	int midi = CurMapdata()->MIDI;
	if(midi==-4) midi = Game->LoadDMapData(Game->GetCurDMap())->MIDI;
	unless(midi==Game->GetMIDI()) Audio->PlayMIDI(midi);
}//end
//end Misc Functions
//start Keyboard
void KeyToString(int key, char buf)
{
	KeyToString(key, buf, false);
}

void KeyToString(int key, char buf, bool ShowPad)
{
	KeyToString(key, buf, ShowPad, false);
}

void KeyToString(int key, char buf, bool ShowPad, bool AllCaps)
{
	switch(key)
	{
		case KEY_TAB:
			strcat(buf, "Tab");
			break;
		
		case KEY_BACKSPACE:
			strcat(buf, "Back");
			break;
			
		case KEY_ENTER:
		case KEY_ENTER_PAD:
			strcat(buf, "Enter");
			if(ShowPad && key == KEY_ENTER_PAD) strcat(buf, " (Pad)");
			break;
			
		case KEY_SPACE:
			strcat(buf, "Space");
			break;
			
		case KEY_DEL:
		case KEY_DEL_PAD:
			strcat(buf, "Del");
			if(ShowPad && key == KEY_DEL_PAD) strcat(buf, " (Pad)");
			break;
			
		case KEY_HOME:
			strcat(buf, "Home");
			break;
			
		case KEY_END:
			strcat(buf, "End");
			break;
			
		case KEY_PGUP:
			strcat(buf, "PgUp");
			break;
			
		case KEY_PGDN:
			strcat(buf, "PgDn");
			break;
			
		case KEY_UP:
			strcat(buf, "Up");
			break;
			
		case KEY_DOWN:
			strcat(buf, "Down");
			break;
			
		case KEY_LEFT:
			strcat(buf, "Left");
			break;
			
		case KEY_RIGHT:
			strcat(buf, "Right");
			break;
		
		case KEY_PRTSCR:
			strcat(buf, "PrintScr");
			break;
			
		case KEY_PAUSE:
			strcat(buf, "Pause");
			break;
		
		case KEY_ESC:
			strcat(buf, "Esc");
			break;
			
		case KEY_F1:
		case KEY_F2:
		case KEY_F3:
		case KEY_F4:
		case KEY_F5:
		case KEY_F6:
		case KEY_F7:
		case KEY_F8:
		case KEY_F9:
			strcat(buf, {'F', key - KEY_F1 + '1', 0});
			break;
			
		case KEY_F10:
		case KEY_F11:
		case KEY_F12:
			strcat(buf, {'F', '1', key - KEY_F10 + '0', 0});
			break;
			
		case KEY_LCONTROL:
			strcat(buf, "LCtrl");
			break;
			
		case KEY_RCONTROL:
			strcat(buf, "RCtrl");
			break;
			
		case KEY_LSHIFT:
			strcat(buf, "LShift");
			break;
			
		case KEY_RSHIFT:
			strcat(buf, "RShift");
			break;
			
		case KEY_ALT:
			strcat(buf, "LAlt");
			break;
			
		case KEY_ALTGR:
			strcat(buf, "RAlt");
			break;
			
		case KEY_LWIN:
			strcat(buf, "LWin");
			break;
			
		case KEY_RWIN:
			strcat(buf, "RWin");
			break;
			
		case KEY_MENU:
			strcat(buf, "Menu");
			break;
			
		case KEY_SCRLOCK:
			strcat(buf, "ScrLock");
			break;
		
		case KEY_NUMLOCK:
			strcat(buf, "NumLock");
			break;
		
		case KEY_CAPSLOCK:
			strcat(buf, "CapsLock");
			break;
			
		case KEY_COMMAND:
			strcat(buf, "Cmd");
			break;
			
		default:
			char keyChar = KeyToChar(key, false, false);
			strcat(buf, (char[2]){AllCaps ? LowerToUpper(keyChar) : keyChar});
			if(ShowPad)
			{
				switch(key)
				{
					case KEY_SLASH_PAD:
					case KEY_MINUS_PAD:
					case KEY_PLUS_PAD:
					case KEY_ASTERISK:
					case KEY_EQUALS_PAD:
					case KEY_0_PAD:
					case KEY_1_PAD:
					case KEY_2_PAD:
					case KEY_3_PAD:
					case KEY_4_PAD:
					case KEY_5_PAD:
					case KEY_6_PAD:
					case KEY_7_PAD:
					case KEY_8_PAD:
					case KEY_9_PAD:
						strcat(buf, " (Pad)");
				}
			}
	}
}

int getKeyPress()
{
	for(int key = -4096; key < KEY_FINAL; key < -1 ? (key /= 2) : ++key)
	{
		if(Input->ReadKey[key]) return key;
	}
	return 0;
}
//end

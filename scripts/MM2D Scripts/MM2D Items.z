////////////////////////////////////////
//                                    //
//          MM2D Script: Items        //
//                                    //
////////////////////////////////////////
//start ITEM misc
item script giveAnother{
	void run(int it1, int it2, int it3, int it4, int it5,int it6,int it7, int it8){
		Hero->Item[it1] = true;
		Hero->Item[it2] = true;
		Hero->Item[it3] = true;
		Hero->Item[it4] = true;
		Hero->Item[it5] = true;
		Hero->Item[it6] = true;
		Hero->Item[it7] = true;
		Hero->Item[it8] = true;
	}
}

item script addCounterMax{
	void run(int cr, int add, int max, int cr2, int add2, int max2){
		Game->MCounter[cr]+=add;
		if(Game->MCounter[cr]>max)Game->MCounter[cr]=max;
		Game->MCounter[cr2]+=add2;
		if(Game->MCounter[cr2]>max2)Game->MCounter[cr2]=max2;
	}
}
//end ITEM misc
//start EX Items
void handleEXItems(){
	if(!subscreen){
		if(useItem>0){
			Hero->ItemJinx=0;
			if(SetBItem(useItem)){
				Input->Press[CB_B] = true;
				Input->Button[CB_B] = true;
				useItem = 0;
				usingItem = useItem;
			} else {
				Input->Button[CB_B]=false;Input->Press[CB_B]=false;
			}
		} else if(Input->Button[CB_B]&&B_item!=0){
			if(isArrow(B_item)&&!canShootArrow()){
				Input->Button[CB_B]=false;Input->Press[CB_B]=false;
			} else if(SetBItem(B_item)){
				Input->Button[CB_B] = true;
				Input->Button[CB_EX1]=false;
				Input->Button[CB_EX2]=false;
			} else {
				Input->Button[CB_B]=false;Input->Press[CB_B]=false;
			}
		} else if(Input->Button[CB_EX1]&&EX1_item!=0){
			if(isArrow(EX1_item)&&!canShootArrow()){
				Input->Button[CB_B]=false;Input->Press[CB_B]=false;
			} else if(SetBItem(EX1_item)){
				Input->Button[CB_B] = true;
				if(Input->Press[CB_EX1])Input->Press[CB_B] = true;
				Input->Button[CB_EX2]=false;
			} else {
				Input->Button[CB_B]=false;Input->Press[CB_B]=false;
			}
		} else if(Input->Button[CB_EX2]&&EX2_item!=0){
			if(isArrow(EX2_item)&&!canShootArrow()){
				Input->Button[CB_B]=false;Input->Press[CB_B]=false;
			} else if(SetBItem(EX2_item)){
				Input->Button[CB_B] = true;
				if(Input->Press[CB_EX2])Input->Press[CB_B] = true;
			} else {
				Input->Button[CB_B]=false;Input->Press[CB_B]=false;
			}
		} else if((Input->Press[CB_B]||Input->Button[CB_B])&&!B_item){
			Input->Button[CB_B]=false;Input->Press[CB_B]=false;
		}
		
	} else if(subState == SUBSTATE_ITEMS && (!Input->Button[CB_EX3]&&(Input->Press[CB_EX1]||Input->Press[CB_EX2]||Input->Press[CB_B]||pressA))){
		int itID = ItemIDs[cursorIndex];
		if(canEquip(itID)){
			if(itID==211){
				if(!form&&pressA){
					Hero->Item[210] = !Hero->Item[210];
					Game->PlaySound(83);
				}
			} else if(!pressA){
				bool arrow = isArrow(itID);
				int snd = 83;
				switch(itID){
					case 14:{snd=84;break;}
					case 57:{snd=85;break;}
					case 137:{snd=86;break;}
				}
				Audio->EndSound(83);
				Audio->EndSound(84);
				Audio->EndSound(85);
				Audio->EndSound(86);
				if(Input->Press[CB_EX1]){
					Game->PlaySound(snd);
					EX1_item = itID;
					if(EX2_item==itID||(isArrow(EX2_item)&&arrow))EX2_item=0;
					if(B_item==itID||(isArrow(B_item)&&arrow))B_item=0;
				} else if(Input->Press[CB_EX2]){
					Game->PlaySound(snd);
					EX2_item = itID;
					if(EX1_item==itID||(isArrow(EX1_item)&&arrow))EX1_item=0;
					if(B_item==itID||(isArrow(B_item)&&arrow))B_item=0;
				} else if(Input->Press[CB_B]){
					Game->PlaySound(snd);
					B_item = itID;
					SetBItem(itID);
					if(EX1_item==itID||(isArrow(EX1_item)&&arrow))EX1_item=0;
					if(EX2_item==itID||(isArrow(EX2_item)&&arrow))EX2_item=0;
				}
			}
		}
	} else {
		if(Input->Press[CB_B])B_item=0;
		if(Input->Press[CB_EX1])EX1_item=0;
		if(Input->Press[CB_EX2])EX2_item=0;
	}
	
}

bool isArrow(int itID){
	return (itID==13||itID==14||itID==57||itID==137);
}

bool canShootArrow(){
	return (!countLWeaponType(LW_ARROW))&&Game->Counter[CR_ARROWS];
}

bool SetBItem(int itemID){
	/*if(force)Hero->SetItemSlot(itemID,0,0);
	else Hero->SetItemSlot(itemID,0,1);
	return GetEquipmentB()==itemID;
	*/
	int oldId = GetEquipmentB();
	int i = 0;
	while(Hero->Item[itemID]&&GetEquipmentB()!=itemID&&i<100){
		Hero->SelectBWeapon(DIR_RIGHT); i++;
	}
	if(i>=100){
		i = 0;
		while(Hero->Item[oldId]&&GetEquipmentB()!=oldId&&i<100){
			Hero->SelectBWeapon(DIR_RIGHT); i++;
		}
	}
	return GetEquipmentB()==itemID;
}

bool canEquip(int itID){
	if(itID==3||itID==139){
		return Hero->Item[81];
	} else if(itID==48){
		return Hero->Item[106];
	} else {
		return Hero->Item[itID];
	}
}
//end EX Items
//start throwableBombs
item script throwableBombs
{
	void run(int fuse, int damage)
	{
		if(!countLWeaponType(LW_THRBOMBS))
		{
			lweapon bomb = CreateLWeaponAt(LW_THRBOMBS,Hero->X,Hero->Y);
			bomb->UseSprite(this->Sprites[0]);
			bomb->Behind = false;
			bomb->CollDetection = false;
			bomb->Misc[BOMB_MISC_FUSE] = fuse;
			bomb->Misc[BOMB_MISC_DAMAGE] = damage;
			bomb->Script = this->WeaponScript;
			bomb->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1;
			bomb->Misc[BOMB_MISC_MODE] = BOMB_STATE_HELD;
			NoAction();
		}
	}
}

lweapon script throwableBombs_LW
{
	void run()
	{
		while(this->isValid())
		{
			mapdata map = getLayerMapdata(getRelativeHeight(this));
			holdingBomb = this->Misc[BOMB_MISC_MODE]==BOMB_STATE_HELD;
			switch(this->Misc[BOMB_MISC_MODE])
			{
				case BOMB_STATE_HELD:
				{
					this->X = Hero->X;
					this->Y = Hero->Y;
					this->DrawYOffset = -8;
					this->Misc[LWMISC_LAYERDMAP] = Game->GetCurDMap() + 1; //While held, lock to Hero through transitions!
					if(Input->Press[CB_A]||Input->Press[CB_B]||Input->Press[CB_EX1]||Input->Press[CB_EX2])
					{
						this->DrawYOffset = 0;
						this->Dir = Hero->Dir;
						this->Step = 150;
						this->Misc[BOMB_MISC_MOVINGTIME] = 60;
						this->Misc[BOMB_MISC_MODE] = BOMB_STATE_MOVING;
						Hero->SwordJinx=3;
						Hero->ItemJinx=3;
					}
					else if(Input->Press[CB_R])
					{
						this->DrawYOffset = 0;
						switch(Hero->Dir)
						{
							case DIR_DOWN:
								this->X = Hero->X;
								this->Y = Hero->Y + 16;
								break;
							case DIR_RIGHT:
								this->X = Hero->X + 16;
								this->Y = Hero->Y;
								break;
							case DIR_LEFT:
								this->X = Hero->X - 16;
								this->Y = Hero->Y;
								break;
							case DIR_UP:
								this->X = Hero->X;
								this->Y = Hero->Y - 16;
						}
						this->Dir = Hero->Dir;
						this->Misc[BOMB_MISC_MODE] = BOMB_STATE_STILL;
						Input->Press[CB_R]=false;
						Input->Button[CB_R]=false;
					}
					Input->Press[CB_START]=false;
					Input->Button[CB_START]=false;
					NoActionButMoveAndEx4AndA();
					break;
				}
				
				case BOMB_STATE_MOVING:
				{
					if(!CanWalkM(this, map, this->Dir, Ceiling(this->Step/100)))
						this->Misc[BOMB_MISC_MOVINGTIME] = 0;
					if(this->Misc[BOMB_MISC_MOVINGTIME])--this->Misc[BOMB_MISC_MOVINGTIME];
					else
					{
						this->Misc[BOMB_MISC_MODE] = BOMB_STATE_STILL;
						this->Step = 0;
					}
					break;
				}
				
				case BOMB_STATE_STILL:
				{
					for(int x = this->X+3; x<this->X+13; x+=9)
					{
						for(int y = this->Y+9; y<this->Y+13; y+=3)
						{
							if(map->ComboT[ComboAt(x,y)] == CT_PITFALL)
							{
								--this->Misc[LWMISC_LAYERDMAP];
								//Reset loop to re-check next layer:
								x = this->X+3;
								y = this->Y+9;
								map = getLayerMapdata(getRelativeHeight(this));
							}
						}
					}
					break;
				}
			}
			if(this->Misc[BOMB_MISC_FUSE])--this->Misc[BOMB_MISC_FUSE];
			else
			{
				lweapon blast = CreateLWeaponAt(LW_BOMBBLAST,this->X,this->Y);
				blast->Damage=this->Misc[BOMB_MISC_DAMAGE];
				blast->Dir=this->Dir;
				blast->UseSprite(9);
				blast->Misc[LWMISC_LAYERDMAP] = this->Misc[LWMISC_LAYERDMAP];
				this->DeadState=WDS_DEAD;
				holdingBomb=false;
				return;
			}
			Waitframe();
		}
	}
}

DEFINE BOMB_MISC_MOVINGTIME = 0;
DEFINE BOMB_MISC_FUSE = 1;
DEFINE BOMB_MISC_DAMAGE = 2;
DEFINE BOMB_MISC_IDENTITY = 3;
DEFINE BOMB_MISC_MODE = 4;
DEFINE BOMB_STATE_HELD = 0;
DEFINE BOMB_STATE_MOVING = 1;
DEFINE BOMB_STATE_STILL = 2;

bool holdingBomb = false;
DEFINE LW_THRBOMBS = 31;

lweapon loadLWeaponType(int type,int num){
	int weapCount = 0;
	for(int i = 1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if(weap->ID==type){
				if(weapCount==num){
					return weap;
				} else {
					weapCount++;
				}
			}
		}
	}
}

int countLWeaponType(int type){
	int weapCount = 0;
	for(int i = 1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if(weap->ID==type){
				weapCount++;
			}
		}
	}
	return weapCount;
}

void stopScreenTransition(int pxAway){
	stopScreenTransition(pxAway,pxAway,pxAway,pxAway);
}
//end throwableBombs
//start ArrowChange
item script arrowTypes{
	void run(int type){
		arrowType = type;
	}
}
//end ArrowChange
//start omniArrows
item script omniArrows
{
	void run(int type)
	{
		arrowType = type;
		//Restore the spent magic cost; it should not be charged yet, though it has been already!
		Game->DCounter[CR_MAGIC] += this->MagicCost * 2;
		Audio->EndSound(this->UseSound);
		if(!Game->Counter[CR_ARROWS]) return; //Do not proceed without the arrow cost being payable!
		arrowAimMode = !arrowAimMode;
		
		if(arrowAimMode)
		{
			int angle;
			if(Input->Button[CB_RIGHT] && Input->Button[CB_DOWN])     angle = 45;
			else if(Input->Button[CB_LEFT] && Input->Button[CB_DOWN]) angle = 135;
			else if(Input->Button[CB_LEFT] && Input->Button[CB_UP])   angle = 225;
			else if(Input->Button[CB_RIGHT] && Input->Button[CB_UP])  angle = 315;
			else switch(Hero->Dir)
			{
				case DIR_RIGHT:
					angle = 0;
					break;
				case DIR_DOWN:
					angle = 90;
					break;
				case DIR_LEFT:
					angle = 180;
					break;
				case DIR_UP:
					angle = 270;
			}
			setGlobalVar(GVAR_ARROWANGLE, GV_MISC, angle);
		}
	}
}

void runOmniArrows()
{
	runOmniArrows(1);
}

void runOmniArrows(int mult)
{
	if(!arrowAimMode) return; //Not aiming arrows
	int angle = getGlobalVar(GVAR_ARROWANGLE, GV_MISC);
	if(/*canShootArrow() && */((Input->Press[CB_B] && isArrow(B_item)) || (Input->Press[CB_EX1] && isArrow(EX1_item)) || (Input->Press[CB_EX2] && isArrow(EX2_item))))
	{ //Fire arrow!
		arrowAimMode = false;
		Hero->ItemJinx = 3;
		freezeFrames = 10;
		lweapon arr = CreateLWeaponAt(LW_ARROW, Hero->X, Hero->Y);
		switch(arrowType) //Find proper parent item, and magic cost, based on type
		{
			case ARRTYPE_FIRE:
				arr->Parent = I_FIREARROWS;
				break;
			case ARRTYPE_ICE:
				arr->Parent = I_ICEARROWS;
				break;
			case ARRTYPE_LIGHT:
				arr->Parent = I_LIGHTARROWS;
				break;
			default:
				arr->Parent = I_BOWARROW;
		}
		itemdata parentItem = Game->LoadItemData(arr->Parent);
		Game->PlaySound(parentItem->UseSound);
		int mcost = parentItem->MagicCost * 2;
		arr->UseSprite(parentItem->Sprites[0]); //Set proper sprite
		//Set Angle/Speed of projectile:
		arr->Angular = true;
		arr->Angle   = DegtoRad(angle);
		arr->Dir     = AngleDir4(WrapDegrees(angle));
		arr->Step    = 250;
		arr->Damage  = parentItem->Power;
		/*//Ensure proper direction:
		if(arr->Dir==DIR_RIGHT)
		{
			arr->Tile+=1;
			arr->Flip=0;
		}
		else if(arr->Dir==DIR_LEFT)
		{
			arr->Tile+=1;
			arr->Flip=1;
		}
		else if(arr->Dir==DIR_DOWN)
		{
			arr->Flip=2;
		}*/
		arr->OriginalTile = arr->Tile;
		--Game->DCounter[CR_ARROWS]; //Charge the arrow cost
		if(mcost) Game->DCounter[CR_MAGIC] -= mcost; //Charge the magic cost
	}
	else
	{ //Aiming arrows
		if(Input->Press[CB_L]){arrowAimMode = false; return;}
		if(Input->Button[CB_R])
		{
			if(Input->Button[CB_RIGHT] && Input->Button[CB_DOWN]) angle = 45;
			else if(Input->Button[CB_LEFT] && Input->Button[CB_DOWN]) angle = 135;
			else if(Input->Button[CB_LEFT] && Input->Button[CB_UP]) angle = 225;
			else if(Input->Button[CB_RIGHT] && Input->Button[CB_UP]) angle = 315;
			else if(Input->Button[CB_RIGHT]) angle = 0;
			else if(Input->Button[CB_DOWN]) angle = 90;
			else if(Input->Button[CB_LEFT]) angle = 180;
			else if(Input->Button[CB_UP]) angle = 270;
		}
		else
		{
			int startAngle = angle;
			if(Input->Button[CB_RIGHT] && Input->Button[CB_DOWN])
			{
				if(startAngle != 45)
				{
					angle += (startAngle > 45 && startAngle < 225) ? -mult : mult;
				}
			}
			else if(Input->Button[CB_LEFT] && Input->Button[CB_DOWN])
			{
				if(startAngle != 135)
				{
					angle += (startAngle > 135 && startAngle < 315) ? -mult : mult;
				}
			}
			else if(Input->Button[CB_LEFT] && Input->Button[CB_UP])
			{
				if(startAngle != 225)
				{
					angle += (startAngle > 45 && startAngle < 225) ? mult : -mult;
				}
			}
			else if(Input->Button[CB_RIGHT] && Input->Button[CB_UP])
			{
				if(startAngle != 315)
				{
					angle += (startAngle > 135 && startAngle < 315) ? mult : -mult;
				}
			}
			else if(Input->Button[CB_UP])
			{
				if(startAngle != 270)
				{
					angle += (startAngle > 90 && startAngle < 270) ? mult : -mult;
				}
			}
			else if(Input->Button[CB_DOWN])
			{
				if(startAngle != 90)
				{
					angle += (startAngle > 90 && startAngle < 270) ? -mult : mult;
				}
			}
			else if(Input->Button[CB_LEFT])
			{
				if(startAngle != 180)
				{
					angle += (startAngle < 180) ? mult : -mult;
				}
			}
			else if(Input->Button[CB_RIGHT])
			{
				if(startAngle != 0)
				{
					angle += (startAngle < 180) ? -mult : mult;
					if(startAngle < 180) angle -= mult;
					else angle += mult;
				}
			}
			if(angle < 0) angle += 360;
			else if(angle >= 360) angle -= 360;
			if(angle % mult) angle -= (angle % mult);
		}
		setGlobalVar(GVAR_ARROWANGLE, GV_MISC, angle);
		int x = Hero->X+8 + VectorX(16, angle);
		int y = Hero->Y+8 + VectorY(16, angle);
		MooshDrawTile(6, x, y, TILE_AIMARROW, 1, 1, 0, 16, 16, x, y, angle, 0, false, OP_OPAQUE);
		Hero->Dir = AngleDir4(WrapDegrees(angle));
		TotalNoAction();
	}
}
//end omniArrows
//start DekuNuts
item script DekuNuts{
	void run(int stunSeconds){
		if(Game->Counter[CR_DEKUNUTS]>0){
			Game->PlaySound(SFX_DEKUNUT_SNAP);
			bool freeze = false;
			for(int i = 0;i<countNPCInRange(CenterLinkX(),CenterLinkY(),40);i++){
				npc n = getNthNPCInRange(CenterLinkX(),CenterLinkY(),40,i);
				if((!n->Defense[NPCD_SCRIPT10]||n->Defense[NPCD_SCRIPT10]==3||n->Defense[NPCD_SCRIPT10]==4||n->Defense[NPCD_SCRIPT10]==5)&&!n->Stun){
					n->Stun=stunSeconds*60;
					freeze = true;
				}
			}
			if(freeze)Game->PlaySound(SFX_DEKUNUT_FREEZE);
			Game->Counter[CR_DEKUNUTS]--;
		}
	}
}
//end DekuNuts
//start RazorSword
void razorSwordCheck(){
	if(swordCounter>=RAZSWORD_USES){
		Hero->Item[I_SWORD_RAZOR]=false;
		swordCounter=0;
	}
}

item script razorSword{
	void run(){
		swordCounter++;
	}
}
//end RazorSword
//start EmptyBottles
//X--------------------X
//|  Bottle Constants  | start
//X--------------------X
DEFINE BOTTLE_SETTING_NO_WATER = 0; //Set to 1 if water shouldn't be bottleable

DEFINE TIL_BOTTLE = 63980; //First of the tiles used for the bottle items. Should come in four identical rows.
                              //Tile order in each row should go as such:
							  //Empty, Empty, Red Potion, Green Potion, Blue Potion, Water, Fairy, Bee

DEFINE POTION_HEARTS = 20; //Hearts the red potion heals
DEFINE POTION_MP = 1024; //MP the green potion restores
DEFINE MILK_HEARTS = 5;

DEFINE LW_WATER = 32; //LWeapon type used for bottled water. Script 1 by default
DEFINE LW_HOTWATER = 33;
DEFINE SPR_BOTTLEWATER = 94; //Sprite used for bottled water
DEFINE SPR_BOTTLEWATERHOT = 95; //^
DEFINE SFX_BOTTLEWATER = 55; //Sound when water is dumped out

DEFINE FAIRY_HEARTS = 3; //Hearts healed by a fairy
DEFINE CMB_FAIRY = 13935; //Fairy combo
DEFINE CS_FAIRY = 8; //Fairy cset
DEFINE SFX_FAIRY = 53; //Sound that plays when a fairy appears

DEFINE IC_BOTTLE = 70; //Item class used for bottles

DEFINE I_BOTTLE1 = 146; //Item ID for the first bottle (Level 1)
DEFINE I_BOTTLE2 = 147; //Item ID for the second bottle (Level 2)
DEFINE I_BOTTLE3 = 148; //Item ID for the third bottle (Level 3)
DEFINE I_BOTTLE4 = 149; //Item ID for the fourth bottle (Level 4)
DEFINE I_BOTTLE5 = 150; //Item ID for the fifth bottle (Level 5)
DEFINE I_BOTTLE6 = 151; //Item ID for the sixth bottle (Level 6)

DEFINE FREQ_HEARTREFILL = 8; //Frequency in frames at which potions/fairies restore hearts
DEFINE SFX_HEARTREFILL = 22; //Sound when potion/fairy restores a heart
DEFINE FREQ_MAGICSOUND = 8; //Frequency in frames where the magic refill sound plays
DEFINE SFX_MAGICREFILL = 23; //Magic refill sound
						  
DEFINE TIL_BOTTLESWING = 64111; //Tile of a right facing open bottle used when trying to catch something
DEFINE CS_BOTTLESWING = 11; //CSet of the swinging bottle
DEFINE SFX_BOTTLESWING = 30; //Sound used for the bottle being swung

DEFINE I_WATERBOTTLE = 175; //Item for bottle water pickup
DEFINE I_FAIRYBOTTLE = 177; //Item for bottle fairy pickup
DEFINE I_HOTWATERBOTTLE = 176; //Item for bottle hot water pickup

DEFINE STR_CANTAFFORD = 29; //Message for when you can't afford an item
DEFINE STR_NOBOTTLE = 42; //Message for when you don't have a bottle to store a potion in
DEFINE STR_WATERCOOLED = 36; //Message for when hot spring water cools off

DEFINE C_WHITE = 0x01; //The color white
DEFINE C_BLACK = 0x0F; //The color black

int TIME_HOTWATER = TIME_HOUR*4; //Does not initialize properly, as TIME_HOUR reads as "0" on init! Re-init in "Init" script!

//X--------------------------X
//|  Empty Bottle Functions  |
//X--------------------------X

//X--------------------------------------------------------X
//|  These constants don't need to be changed.             |
//|  They just define various states of the empty bottle.  |
//|  BS_ constants are also used for  the potion filling   |
//|  pickup item script. Look here to see what to set D2   |
//|  to for that.                                          |
//X--------------------------------------------------------X

DEFINE BS_EMPTY = 0;
DEFINE BS_POTIONRED = 1;
DEFINE BS_POTIONGREEN = 2;
DEFINE BS_POTIONBLUE = 3;
DEFINE BS_WATER = 4;
DEFINE BS_FAIRY = 5;
DEFINE BS_MILK = 6;
DEFINE BS_HALFMILK = 7;
DEFINE BS_BUG = 8;
DEFINE BS_CHATEAU = 9;
DEFINE BS_POE = 10;
DEFINE BS_BPOE = 11;
DEFINE BS_HOTWATER = 12;
DEFINE BS_MUSHROOM = 13;
DEFINE BS_GOLDDUST = 14;
DEFINE BS_FISH = 15;
DEFINE BS_DEKUPRINCESS = 16;
DEFINE BS_SEAHORSE = 17;
//DEFINE BS_ZORAEGG = 18;

DEFINE BSI_BOTTLEUSED = 6;
DEFINE BSI_BOTTLETIMER = 7;
DEFINE BSI_OLDHP = 8;
DEFINE BSI_OLDMP = 9;
DEFINE BSI_FAIRYTIMER = 10;
DEFINE BSI_FAIRYREVIVE = 11;
//end
//vars
int usingBugs = 0;
int BottleStateForTango = -1;
//
//---------------------------------------------------------X
//start functions

int BottleState[12];//0-5: States of bottles, 6: Bottle used, 
                    //7: Potion timer, 8: OldHP, 9: OldMP

int springTimers[6];
//This function should be called at the beginning of your global and 
//refreshes the graphics for the bottles.
void RefreshBottles(){
	for(int i=0; i<6; i++){
		CopyTile(TIL_BOTTLE+1+BottleState[i], TIL_BOTTLE+20*i);
	}
}

int UsingEmptyBottle(){
	if(Hero->Action!=LA_WALKING&&Hero->Action!=LA_NONE)return -1;
	if(Input->Press[CB_A]){
		int id = GetEquipmentA();
		if(id>0){
			itemdata A = Game->LoadItemData(id);
			if(A->Family==IC_BOTTLE)
				return A->Level-1;
		}
	}
	else if(Input->Press[CB_B]){
		int id = GetEquipmentB();
		if(id>0){
			itemdata B = Game->LoadItemData(id);
			if(B->Family==IC_BOTTLE){
				return B->Level-1;
			}
		}
	}
	return -1;
}

bool CanFillBottle(){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=0; i<6; i++){
		if(Hero->Item[bottles[i]]&&BottleState[i]==BS_EMPTY)
			return true;
	}
	return false;
}

int FillBottle(int state){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=0; i<6; i++){
		if(Hero->Item[bottles[i]]&&BottleState[i]==BS_EMPTY){
			BottleState[i] = state;
			RefreshBottles();
			return i;
		}
	}
}

int HasFairy(){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=0; i<6; i++){
		if(Hero->Item[bottles[i]]&&BottleState[i]==BS_FAIRY)
			return i;
	}
	return -1;
}

//This function goes in the while loop of your global script before waitdraw
void EmptyBottleGlobal(){//start defaultBottleCode
	for(int i=0;i<6;i++){
		if(springTimers[i]>-1){
			if(BottleState[i]==BS_HOTWATER){
				if(trueTime>=springTimers[i]){
					BottleState[i]=BS_WATER;
					RefreshBottles();
					int args[8] = {STR_WATERCOOLED};
					RunFFCScript(FFC_SHOWSTRING,args);
				}
			} else {
				springTimers[i]=-1;
			}
		}
	}
	int bottle = BottleState[BSI_BOTTLEUSED];
	if(BottleState[BSI_BOTTLETIMER]>0){
		bool hpHeal = (BottleState[bottle]==BS_POTIONRED||BottleState[bottle]==BS_MILK||BottleState[bottle]==BS_HALFMILK||BottleState[bottle]==BS_POE||BottleState[bottle]==BS_BPOE);
		if(hpHeal){
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_HEARTREFILL)){
				Hero->HP += 16;
				Game->PlaySound(SFX_HEARTREFILL);
				if(Hero->HP>=Hero->MaxHP){
					BottleState[BSI_BOTTLETIMER] = 0;
				}
			}
		}
		else if(BottleState[bottle]==BS_POTIONGREEN){
			Hero->MP += 2;
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_MAGICSOUND))
				Game->PlaySound(SFX_MAGICREFILL);
			if(Hero->MP>=Hero->MaxMP){
				BottleState[BSI_BOTTLETIMER] = 0;
			}
		}
		else if(BottleState[bottle]==BS_POTIONBLUE||BottleState[bottle]==BS_CHATEAU){
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_HEARTREFILL)&&Hero->HP<BottleState[BSI_OLDHP]+POTION_HEARTS*16&&Hero->HP<Hero->MaxHP){
				Hero->HP += 16;
				Game->PlaySound(SFX_HEARTREFILL);
			}
			if(Hero->MP<BottleState[BSI_OLDMP]+POTION_MP&&Hero->MP<Hero->MaxMP){
				if(!(BottleState[BSI_BOTTLETIMER]%FREQ_MAGICSOUND))
					Game->PlaySound(SFX_MAGICREFILL);
				Hero->MP += 2;
			}
			if(Hero->HP>=Hero->MaxHP&&Hero->MP>=Hero->MaxMP){
				BottleState[BSI_BOTTLETIMER] = 0;
			}
		}
		else if(BottleState[bottle]==BS_FAIRY){
			if(BottleState[BSI_BOTTLETIMER]<2&&BottleState[BSI_FAIRYTIMER]<120)
				BottleState[BSI_BOTTLETIMER] = 2;
			BottleState[BSI_FAIRYTIMER]++;
			int X = Hero->X+VectorX(16*(BottleState[BSI_FAIRYTIMER]/120), BottleState[BSI_FAIRYTIMER]*8);
			int Y = Hero->Y+VectorY(8*(BottleState[BSI_FAIRYTIMER]/120), BottleState[BSI_FAIRYTIMER]*8)-BottleState[BSI_FAIRYTIMER]/8;
			if(BottleState[BSI_FAIRYREVIVE]==1){
				if(BottleState[BSI_FAIRYTIMER]<10||BottleState[BSI_FAIRYTIMER]>110)
					Screen->Rectangle(6, 0, 0, 256, 176, C_BLACK, 1, 0, 0, 0, true, 64);
				else
					Screen->Rectangle(6, 0, 0, 256, 176, C_BLACK, 1, 0, 0, 0, true, 128);
				Screen->FastTile(6, Hero->X+Hero->DrawXOffset, Hero->Y+Hero->DrawYOffset, Hero->Tile, 6, 128);
			}
			if(BottleState[BSI_FAIRYTIMER]<80||!(BottleState[BSI_FAIRYTIMER]%2))
				Screen->FastCombo(6, X, Y, CMB_FAIRY, CS_FAIRY, 128);
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_HEARTREFILL)&&Hero->HP<Hero->MaxHP){
				Hero->HP += 16;
				Game->PlaySound(SFX_HEARTREFILL);
			}
			if(Hero->HP>=Hero->MaxHP&&BottleState[BSI_FAIRYTIMER]>=120){
				BottleState[BSI_BOTTLETIMER] = 0;
			}
		}
		BottleState[BSI_BOTTLETIMER]--;
		NoAction();
		if(BottleState[BSI_BOTTLETIMER]<=0){
			if(BottleState[bottle]==BS_MILK){
				BottleState[bottle]=BS_HALFMILK;
			} else {
				BottleState[bottle] = BS_EMPTY;
			}
			BottleState[BSI_BOTTLEUSED] = -1;
			RefreshBottles();
			Screen_Freeze(0);
			isBottleFrozen=false;
		}
	}
	else{
		bottle = UsingEmptyBottle();
		if(bottle>-1){
			bool refresh = BottleState[bottle]!=BS_EMPTY;
			if(BottleState[bottle]==BS_EMPTY){
				int scriptname[] = "Bottle_Empty";
				int scriptid = Game->GetFFCScript(scriptname);
				int Args[8] = {bottle};
				RunFFCScript(scriptid, Args);
			} 
			else if(BottleState[bottle]==BS_POTIONRED){
				if(Hero->HP==Hero->MaxHP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*POTION_HEARTS;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			}
			else if(BottleState[bottle]==BS_POTIONGREEN){
				if(Hero->MP==Hero->MaxMP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = POTION_MP/2;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			}
			else if(BottleState[bottle]==BS_POTIONBLUE){
				if(Hero->HP==Hero->MaxHP&&Hero->MP==Hero->MaxMP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = Max(FREQ_HEARTREFILL*POTION_HEARTS, POTION_MP/2);
					BottleState[BSI_OLDHP] = Hero->HP;
					BottleState[BSI_OLDMP] = Hero->MP;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			}
			else if(BottleState[bottle]==BS_WATER){
				Hero->Action = LA_ATTACKING;
				lweapon l = CreateLWeaponAt(LW_WATER, Hero->X+InFrontX(Hero->Dir, 0), Hero->Y+InFrontY(Hero->Dir, 0));
				l->UseSprite(SPR_BOTTLEWATER);
				l->DeadState = (l->ASpeed*l->NumFrames)-2;
				l->CollDetection = false;
				Game->PlaySound(SFX_BOTTLEWATER);
				BottleState[bottle] = BS_EMPTY;
				RefreshBottles();
			}
			else if(BottleState[bottle]==BS_FAIRY){
				if(Hero->HP==Hero->MaxHP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*FAIRY_HEARTS;
					BottleState[BSI_FAIRYTIMER] = 0;
					BottleState[BSI_FAIRYREVIVE] = 0;
					Game->PlaySound(SFX_FAIRY);
					Screen_Freeze(2);
					isBottleFrozen=true;
				}//end
			} else if(BottleState[bottle]==BS_MILK||BottleState[bottle]==BS_HALFMILK){
				if(Hero->HP==Hero->MaxHP){
					Game->PlaySound(SFX_ERROR);
				} else {
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*MILK_HEARTS;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			} else if(BottleState[bottle]==BS_CHATEAU){
				BottleState[BSI_BOTTLEUSED] = bottle;
				BottleState[BSI_BOTTLETIMER] = Max(FREQ_HEARTREFILL*POTION_HEARTS, POTION_MP/2);
				Screen_Freeze(2);
				isBottleFrozen=true;
				Hero->Item[INF_MAGIC]=true;
			} else if(BottleState[bottle]==BS_POE||BottleState[bottle]==BS_BPOE){
				if(Hero->HP==Hero->MaxHP){
					Game->PlaySound(SFX_ERROR);
				} else {
					int rand = Rand(0,10);
					if(!rand){
						Hero->HP=1;
					} else {
						BottleState[BSI_BOTTLEUSED] = bottle;
						BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*(rand*2);
						Screen_Freeze(2);
						isBottleFrozen=true;
					}
				}
			} else if(BottleState[bottle]==BS_BUG){
				usingBugs = 30;
				BottleState[bottle]=BS_EMPTY;
			} else if(BottleState[bottle]==BS_HOTWATER){
				springTimers[bottle]=0;
				Hero->Action = LA_ATTACKING;
				lweapon l = CreateLWeaponAt(LW_HOTWATER, Hero->X+InFrontX(Hero->Dir, 0), Hero->Y+InFrontY(Hero->Dir, 0));
				l->UseSprite(SPR_BOTTLEWATERHOT);
				l->DeadState = (l->ASpeed*l->NumFrames)-2;
				l->CollDetection = false;
				Game->PlaySound(SFX_BOTTLEWATER);
				BottleState[bottle] = BS_EMPTY;
			} else if(BottleState[bottle]==BS_MUSHROOM){
				//Nothing
			} else if(BottleState[bottle]==BS_GOLDDUST){
				//Nothing
			} else if(BottleState[bottle]==BS_FISH){
				//Nothing
			} else if(BottleState[bottle]==BS_DEKUPRINCESS){
				//Nothing
			} else if(BottleState[bottle]==BS_SEAHORSE){
				//Nothing
			}
			if(refresh)
				RefreshBottles();
		}
		int fairy = HasFairy();//start fairyRevive
		if(Hero->HP<=0&&fairy>-1){
			Hero->HP = 1;
			BottleState[BSI_BOTTLEUSED] = fairy;
			BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*FAIRY_HEARTS;
			BottleState[BSI_FAIRYTIMER] = 0;
			BottleState[BSI_FAIRYREVIVE] = 1;
			Game->PlaySound(SFX_FAIRY);
			Screen_Freeze(2);
			isBottleFrozen=true;
		}//end
	}
}


//X-------------------------------X
//|  Empty Bottle Action Scripts  |
//X-------------------------------X

ffc script Bottle_Empty{
	void run(int bottleid){
		int Angle = 0;
		if(Hero->Dir==DIR_UP)
			Angle = -90;
		else if(Hero->Dir==DIR_DOWN)
			Angle = 90;
		else if(Hero->Dir==DIR_LEFT)
			Angle = 180;
		Game->PlaySound(SFX_BOTTLESWING);
		Hero->Action = LA_ATTACKING;
		int Collected = 0;
		for(int i=-45; i<45; i+=10){
			int X = Hero->X+VectorX(12, Angle+i);
			int Y = Hero->Y+VectorY(12, Angle+i);
			Screen->DrawTile(2, X, Y, TIL_BOTTLESWING, 1, 1, CS_BOTTLESWING, -1, -1, X, Y, Angle+i+90, 0, true, 128);
			if(!Collected||Collected==BS_WATER||Collected==BS_HOTWATER){
				if(OnWater(X+8, Y+8)&&!Collected&&!BOTTLE_SETTING_NO_WATER){
					if(ScreenFlag(SF_MISC,SFM_SCRIPT2)>0){
						Collected = BS_HOTWATER;
					} else {
						Collected = BS_WATER;
					}
				}
				for(int j=1; j<=Screen->NumItems(); j++){
					item itm = Screen->LoadItem(j);
					if(itm->ID==I_FAIRY||itm->ID==I_FAIRYSTILL){
						if(RectCollision(itm->X+itm->HitXOffset, itm->Y+itm->HitYOffset, itm->X+itm->HitXOffset+itm->HitWidth, itm->Y+itm->HitYOffset+itm->HitHeight, X+4, Y+4, X+11, Y+11)){
							Collected = BS_FAIRY;
							Remove(itm);
							break;
						}
					}
				}
			}
			WaitNoAction();
		}
		if(Collected==BS_WATER){
			BottleState[bottleid] = BS_WATER;
			RefreshBottles();
			item itm = CreateItemAt(I_WATERBOTTLE, Hero->X, Hero->Y);
			itm->Pickup = IP_HOLDUP;
		}
		else if(Collected==BS_HOTWATER){
			BottleState[bottleid] = BS_HOTWATER;
			springTimers[bottleid] = trueTime + TIME_HOTWATER;
			RefreshBottles();
			item itm = CreateItemAt(I_HOTWATERBOTTLE, Hero->X, Hero->Y);
			itm->Pickup = IP_HOLDUP;
		}
		else if(Collected==BS_FAIRY){
			BottleState[bottleid] = BS_FAIRY;
			RefreshBottles();
			item itm = CreateItemAt(I_FAIRYBOTTLE, Hero->X, Hero->Y);
			itm->Pickup = IP_HOLDUP;
		}
		WaitNoAction(10);
	}
	bool OnWater(int x, int y){
		int ct = Screen->ComboT[ComboAt(x, y)];
		if(ct==CT_WATER||ct==CT_SHALLOWWATER)
			return true;
		return false;
	}
}

//end
//X----------------------------X
//|  Other Associated Scripts  |
//X----------------------------X

item script ShopBottleFill{
	void run(int state){
		FillBottle(state);
	}
}

item script BottleFill{
	void run(int str, int state){
		if(!CanFillBottle())str = STR_NOBOTTLE;
		BottleStateForTango = state;
		remchr(shopString,0);
		getBottleStateName(state,shopString);
		int args[8] = {str};
		RunFFCScript(FFC_SHOWSTRING,args);
	}
}

ffc script ItemShop{//start
	void run(int id, int strdescription, int price, int potion){
		itemdata ic = Game->LoadItemData(id);
		while(true){
			if(Hero->X>this->X-8&&Hero->X<this->X+8&&Hero->Y>this->Y&&Hero->Y<this->Y+10&&Hero->Dir==DIR_UP){
				if(Input->Press[CB_R]){
					if(fullCounter(CR_RUPEES)>=price){
						if(potion>0&&!CanFillBottle()){
							ShowMessageAndWait(STR_NOBOTTLE);
							NoAction();
						}
						else{
							item itm = CreateItemAt(id, Hero->X, Hero->Y);
							itm->Pickup = IP_HOLDUP;
							Game->DCounter[CR_RUPEES] -= price;
							for(int i=0; i<10; i++){
								WaitNoAction();
							}
						}
					}
					else{
						ShowMessageAndWait(STR_CANTAFFORD);
						NoAction();
					}
				}
			}
			DrawPrice(this, price);
			Waitframe();
		}
	}
	void DrawPrice(ffc this, int price){
		int xoff = -2;
		if(price>999)
			xoff = -8;
		else if(price>99)
			xoff = -6;
		else if(price>9)
			xoff = -4;
		Screen->DrawInteger(5, this->X+8+xoff+1, this->Y+18+1, FONT_Z3SMALL, C_BLACK, -1, -1, -1, price, 0, 128);
		Screen->DrawInteger(5, this->X+8+xoff, this->Y+18, FONT_Z3SMALL, C_WHITE, -1, -1, -1, price, 0, 128);
	}
}//end
//custom emptybottles functions
bool ClearBottle(int state){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=5; i>=0; i--){
		if(Hero->Item[bottles[i]]&&BottleState[i]==state){
			BottleState[i] = 0;
			RefreshBottles();
			return true;
		}
	}
	return false;
}
//start bottleStateNames
void getBottleStateName(int state, int deststr){//start
	if(!state){
		int str[] = "Empty Bottle";
		strcpy(deststr,str);
	} else if(state==1){
		int str[] = "Red Potion";
		strcpy(deststr,str);
	} else if(state==2){
		int str[] = "Green Potion";
		strcpy(deststr,str);
	} else if(state==3){
		int str[] = "Blue Potion";
		strcpy(deststr,str);
	} else if(state==4){
		int str[] = "Water";
		strcpy(deststr,str);
	} else if(state==5){
		int str[] = "Fairy";
		strcpy(deststr,str);
	} else if(state==6){
		int str[] = "Milk (2/2)";
		strcpy(deststr,str);
	} else if(state==7){
		int str[] = "Milk (1/2)";
		strcpy(deststr,str);
	} else if(state==8){
		int str[] = "Bugs";
		strcpy(deststr,str);
	} else if(state==9){
		int str[] = "Chateau Romani";
		strcpy(deststr,str);
	} else if(state==10){
		int str[] = "Poe";
		strcpy(deststr,str);
	} else if(state==11){
		int str[] = "Big Poe";
		strcpy(deststr,str);
	} else if(state==12){
		int str[] = "Hot Spring Water";
		strcpy(deststr,str);
	} else if(state==13){
		int str[] = "Mushroom";
		strcpy(deststr,str);
	} else if(state==14){
		int str[] = "Gold Dust";
		strcpy(deststr,str);
	} else if(state==15){
		int str[] = "Fish";
		strcpy(deststr,str);
	} else if(state==16){
		int str[] = "Deku Princess";
		strcpy(deststr,str);
	} else if(state==17){
		int str[] = "Seahorse";
		strcpy(deststr,str);
	}
}//end

int getBottleState(int bottle){
	bottle = Clamp(bottle,1,6);
	return BottleState[bottle-1];
}


//end
//end EmptyBottles
//start Bombchus
//start oldBombchus 
/*
item script Bombchu
{
	//d0 is the ffc script slot that has the
	//d1 is the step speed. 100 is one pixel.
	//d2 is the sprite. Sprite to use for the bombchu. Sprites are organized UP DOWN LEFT RIGHT.
	//Power is the damage done by the bombchu's explosion
	//The Counter reference in the pickup tab is what counter it will use.
	void run(int ffcScriptNum, int step, int sprite)
	{
		if(!Input->Press[CB_A] && !Input->Press[CB_B]) Quit();
		if(CountFFCsRunning(ffcScriptNum) == 0 && Game->Counter[this->Counter] > 0)
		{
			Game->Counter[this->Counter]--;
			Game->PlaySound(SFX_PLACE);
			int args[8] = {step, sprite, this->Power};
			RunFFCScript(ffcScriptNum, args);
		}
	}
}

ffc script Bombchu_FFC
{
	void run(int step, int sprite, int damage)
	{
		this->Data=COMBO_INVIS;
		//Create the bombchu infront of link.
		lweapon bombchu = NextToLink(LW_BOMBCHU, 0);
		bombchu->CollDetection = false;
		bombchu->Dir = Hero->Dir;
		bombchu->Step = step;
		bombchu->HitZHeight = 2;
		bombchu->UseSprite(sprite);
		int frames = bombchu->NumFrames;
		if(!frames)frames=1;
		bombchu->OriginalTile += bombchu->Dir*frames;
		bombchu->Tile = bombchu->OriginalTile;
		//Loop until it becomes invalid.
		while(bombchu->isValid())
		{
			if(!(gameframe%6))Game->PlaySound(SFX_BOMBCHU);
			//Update the sprite based off direction.
			//Declare variables to be used to detect collisions.
			bool contact;
			int dir = bombchu->Dir;
			//If the bombchu is about to go off screen expode.
			if(dir == DIR_UP) contact = (bombchu->Y - Ceiling(step/100) <= 2);
			else if(dir == DIR_DOWN) contact = (bombchu->Y + Ceiling(step/100) >= 150);
			else if(dir == DIR_LEFT) contact = (bombchu->X - Ceiling(step/100) <= 4);
			else if(dir == DIR_RIGHT) contact = (bombchu->X + Ceiling(step/100) >= 236);
			//If the bombchu collided with a npc expode.
			for(int i = Screen->NumNPCs(); i > 0 && !contact; i--)
			{
				npc n = Screen->LoadNPC(i);
				if(!n->CollDetection) continue;
				if(n->ID == NPC_ITEMFAIRY) continue;
				if(n->Type == NPCT_PEAHAT && n->Step != 0 && n->Z == 0) continue;
				if(n->Defense[NPCD_SCRIPT] == NPCDT_IGNORE) continue;
				if(Collision(n, bombchu)) contact = true;
			}
			//If the bombchu is about to hit something solid according to bombchu solidity explode.
			if(!contact)
			{
				int x = bombchu->X + AtFrontX(bombchu->Dir);
				int y = bombchu->Y + AtFrontY(bombchu->Dir);
				int combo = ComboAt(x,y);
				if(!contact)
				{
					if(Screen->ComboT[combo]==CT_BOMBCHU&&Screen->ComboI[combo]==CF_BOMBCHU1&&Screen->ComboF[combo]==CF_BOMBCHU2) contact = !Screen->isSolid(x, y);
					else contact = Screen->isSolid(x, y);
				}
				if(IsWater(combo) || IsPit(combo) || Screen->ComboT[combo] == CT_PITFALL) contact = true;
			}
			//If contact was set to true explode.
			if(contact)
			{
				lweapon blast = CreateLWeaponAt(LW_BOMBBLAST, bombchu->X, bombchu->Y);
				blast->Damage = damage;
				bombchu->DeadState = 0;
			}
			Waitframe();
		}
	}
}//end oldBombchus
*/

item script Bombchu
{
	void run(int step, int sprite)
	{
		if(countLWeaponType(LW_BOMBCHU))return;
		--Game->Counter[this->Counter];
		Game->PlaySound(SFX_PLACE);
		lweapon bombchu = NextToLink(LW_BOMBCHU, 0);
		bombchu->CollDetection = false;
		bombchu->Dir = Hero->Dir;
		bombchu->Step = step;
		bombchu->HitZHeight = 2;
		bombchu->UseSprite(sprite);
		bombchu->OriginalTile += bombchu->Dir*Max(1,bombchu->NumFrames);
		bombchu->InitD[0] = this->Power;
		bombchu->Script = this->WeaponScript;
	}
}

lweapon script Bombchu_LW
{
	void run(int damage)
	{
		while(this->isValid())
		{
			if(!(gameframe%6))Game->PlaySound(SFX_BOMBCHU);
			bool contact;
			switch(this->Dir)
			{
				case DIR_UP:
					contact = (this->Y - Ceiling(this->Step/100) <= 2);
					break;
				case DIR_DOWN:
					contact = (this->Y + Ceiling(this->Step/100) >= 150);
					break;
				case DIR_LEFT:
					contact = (this->X - Ceiling(this->Step/100) <= 4);
					break;
				case DIR_RIGHT:
					contact = (this->X + Ceiling(this->Step/100) >= 236);
			}
			//If the bombchu collided with a npc expode.
			for(int q = Screen->NumNPCs(); q > 0 && !contact; q--)
			{
				npc n = Screen->LoadNPC(q);
				if(!n->CollDetection) continue;
				if(n->ID == NPC_ITEMFAIRY) continue;
				if(n->Type == NPCT_PEAHAT && n->Step != 0 && n->Z == 0) continue;
				if(n->Defense[NPCD_SCRIPT] == NPCDT_IGNORE) continue;
				if(Collision(n, this)) contact = true;
			}
			//If the bombchu is about to hit something solid according to bombchu solidity explode.
			int x = this->X + AtFrontX(this->Dir);
			int y = this->Y + AtFrontY(this->Dir);
			int combo = ComboAt(x,y);
			while(true)
			{
				mapdata map = getLayerMapdata(getRelativeHeight(this));
				if(!contact)
				{
					int ct = map->ComboT[combo];
					if(ct==CT_BOMBCHU&&ct==CF_BOMBCHU1&&ct==CF_BOMBCHU2) contact = CanWalkM(this, map, this->Dir, Ceiling(this->Step/100));
					else contact = !CanWalkM(this, map, this->Dir, Ceiling(this->Step/100));
					if(ct==CT_PIT || ct == CT_PITR || ct == CT_PITB || ct == CT_PITD || ct == CT_WATER || ct ==CT_SWIMWARP || ct == CT_DIVEWARP  || (ct >= CT_SWIMWARPB && ct <= CT_DIVEWARPD))
						contact = true;
					else if(ct == CT_PITFALL)
					{
						--this->Misc[LWMISC_LAYERDMAP];
						continue;
					}
					else
					{
						int centerCombo = ComboAt(this->X+8,this->Y+8);
						int ci = map->ComboI[centerCombo];
						int cf = map->ComboF[centerCombo];
						if(ci == CI_RAMP)
						{
							if(cf == CF_RAMP_UP)
							{
								++this->Misc[LWMISC_LAYERDMAP];
								continue;
							}
							else if(cf == CF_RAMP_DOWN)
							{
								--this->Misc[LWMISC_LAYERDMAP];
								continue;
							}
						}
					}
				}
				break;
			}
			//If contact was set to true explode.
			if(contact)
			{
				lweapon blast = CreateLWeaponAt(LW_BOMBBLAST, this->X, this->Y);
				blast->Damage = damage;
				this->DeadState = WDS_DEAD;
			}
			Waitframe();
		}
	}
}
//end Bombchus
//start Pictograph
item script Pictograph
{
	void run()
	{
		
	}
}
//end Pictograph
//start misc
lweapon script obeyGravity
{
	void run(bool oneframe)
	{
		if(oneframe)
		{
			pitfall(this);
			return;
		}
		while(this->isValid())
		{
			pitfall(this);
			Waitframe();
		}
	}
}

void pitfall(lweapon weap)
{
	mapdata map = getLayerMapdata(getRelativeHeight(weap));
	for(int x = weap->X+3; x<weap->X+13; x+=9)
	{
		for(int y = weap->Y+9; y<weap->Y+13; y+=3)
		{
			if(map->ComboT[ComboAt(x,y)] == CT_PITFALL)
			{
				--weap->Misc[LWMISC_LAYERDMAP];
				//Reset loop to re-check next layer:
				x = weap->X+3;
				y = weap->Y+9;
				map = getLayerMapdata(getRelativeHeight(weap));
			}
		}
	}
}
//end misc

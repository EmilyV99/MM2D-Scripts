////////////////////////////////////////
//                                    //
//     MM2D Script: Global Scripts    //
//                                    //
////////////////////////////////////////
//start Init Script
global script Init
{
	void run()
	{
		//Check debug mode
		char saveName[16];
		Game->GetSaveName(saveName);
		unless(strcmp(saveName,"Link"))debugEnabled=false;
		else debugEnabled=true;
		onLaunch();
		//Starting settings
		Game->MCounter[CR_DEKUNUTS] = 20;
		Game->MCounter[CR_MAGICBEANS] = 20;
		Game->MCounter[CR_BANKBAL] = 5000;
		setGlobalVar(GVAR_DIFFICULTY,GV_MISC,1);
		//Make FFC tiles invisible
		CopyTile(TILE_INVIS,19);
		CopyTile(TILE_INVIS,39);
		//Set up tint palettes
		setGlobalVar(TINT_DAY,GV_PAL,createTintPalette(0,0,0));
		setGlobalVar(TINT_SUNSETORANGE,GV_PAL,createTintPalette(-3,-9,-14));
		setGlobalVar(TINT_NIGHT,GV_PAL,createTintPalette(-21,-23,-10));
		setGlobalVar(TINT_LENS,GV_PAL,createTintPalette(-17,-48,5));
		setGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL,true);
		//Default controls
		Controls[CONTROL_OPTIONS] = KEY_TAB;
		//TypeAString.zh setup
		setEnterEndsTyping(true);
		setAllowBackspaceDelete(true);
		setOverflowWraps(false);
		onLaunchEnd();
	}
}
//end
//start Active Script
global script Global
{
	void run()//start mainGlobal
	{
		//start Global Script Scope Vars
		int subskin = 1;
		int lastskin = -1;
		bool isLensTinted = false;
		bool refreshTime = false;
		bool scrnChanged = false;
		//end
		//Tango_ConvertVariableName("anpc");
		//Tango_ConvertFunctionName("npcend");
		while(true)
		{
			if(!(gameframe%60) || refreshTime)//Refresh time-based events every 60 frames
			{
				int month = GetSystemTime(RTC_MONTH);
				int day = GetSystemTime(RTC_DAYOFMONTH);
				subskin = 1;
				if(month == 12)
				{
					subskin = 2;
					if(day>23&&day<26)subskin = 3;
				}
				refreshTime = false;
			}
			unless(ScreenFlag(SF_VIEW,SFV_NOSUBSCREEN))
			{
				if(getGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL))
				{
					if(subskin != lastskin)
					{
						lastskin = subskin;
						reskinSubscreen(subskin);
					}
				}
				else
				{
					subskin = 1;
					if(lastskin!=1)
					{
						lastskin = 1;
						reskinSubscreen(1);
					}
				}
			}
			//clearBitmap(RT_BITMAP0);
			handleTyping();
			if(debugEnabled)testingMenu();
			//start
			if(Hero->HP!=lastHP)
			{
				if(Hero->HP < lastHP)
				{
					onLinkHurt();
				}
				lastHP = Hero->HP;
			}
			layer4Toggle();
			if(subscreen)
			{
				pressA=Input->Press[CB_A];
				Input->Press[CB_A]=false;
				Input->Button[CB_A]=false;
			}
			
			varIntegrity();
			//end
			//start FrameCounters
			if(freezeFrames>0)
			{
				NoAction();
				freezeFrames--;
			}
			++gameframe;
			gameframe%=3600;//end FrameCounters
			//start Time passing
			unless(freezeTime||(isFrozen||(slowTime&&(gameframe%2))||ScreenFlag(SF_MISC,SFM_SCRIPT1)||songFrames))
			{
				++time;
				trueTime += FRAME;
				unless(time%FRAMES_HOUR)
				{
					++hour;
					time=0;
					if(hour>=24)
					{
						hour-=24;
					}
					else if(hour==6)
					{
						++day;
					}
				}
				if(day>3)
				{
					destruction();
				}
				unpauseGradient();
			}
			else
			{
				pauseGradient();
			}
			//end Time Passing
			unless(getGlobalVar(GVAR_MGSTATE,GV_MISC)==MG_SHOOTING)
				runOmniArrows();
			Tango_Update1();
			handleOcarina();
			//start Subscreen
			if((!(getGlobalVar(GVAR_MGSTATE,GV_MISC)||isFrozen)||subscreen)&&Input->Press[CB_START]&&!ScreenFlag(SF_VIEW,SFV_NOSUBSCREEN))
			{
				toggleSubscreen();
			}
			if(subscreen)
			{
				runSubscreen();
			}
			//end Subscreen
			//start
			if(Tango_AnySlotIsActive())
			{
				unless(slotWasDisplayed)
				{
					Screen_Freeze(FREEZE_ACTION_BUT_FFC);
					slotWasDisplayed=true;
				}
			}
			else if(slotWasDisplayed)
			{
				Screen_Freeze(FREEZE_NONE);
				slotWasDisplayed=false;
			}
			razorSwordCheck();
			handleTransformations();
			handleEXItems();
			handleMasks();
			//end
			if(subscreen)//start
			{
				NoAction();
			}
			else unless(isFrozen)
			{
				warpfloors();
				varDecrements();
				heightWarp();
				checkFall();
				handleMeltableIce();
				handleFreezableWater();
			}
			checkJump(isFrozen);
			//end
			//start
			LinkActionOld=Hero->Action;
			raftingCheck();
			LinkMovement_Update1();
			unless(isFrozen)
				highLedgeFromWater();
			//end
			bool temp = getGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL);
			runExtraControls();
			if(temp != getGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL))refreshTime = true;
			handleTintPausing();
			HeroDir8 = validateDir(getPressedDir8(), (HeroDir8 & 4) ? HeroDir8 : Hero->Dir);
			Waitdraw();
			if(UsingItem(IT_LENS)&&fullCounter(CR_MAGIC)>2)
			{
				unless(isLensTinted || (getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL)))
				{
					setTint(getGlobalVar(TINT_LENS,GV_PAL),true);
					isLensTinted=true;
				}
			}
			else
			{
				if(isLensTinted)
				{
					setTint(getGlobalVar(TINT_LENS,GV_PAL),false);
					isLensTinted=false;
				}
			}
			timePalette();
			runTints();
			scrnChanged=false;
			if(lastMap!=Game->GetCurMap()||lastScreen!=Game->GetCurScreen())
			{
				scrnChanged=true;
				changedScreens();
				lastScreen = Game->GetCurScreen();
				lastMap = Game->GetCurMap();
			}
			if(lastDMap!=Game->GetCurDMap())
			{
				changedDMap();
				lastDMap = Game->GetCurDMap();
				if(lastLevel!=Game->GetCurLevel())
				{
					changedLevel();
					lastLevel = Game->GetCurLevel();
				}
			}
			unless(subscreen)
			{
				if(scrnChanged)
					layer4check();
				DrawLayer3_4();
				drawExtraLayerEffects();
				lwLoop();
				ewLoop();
				itemLoop();
				npcLoop();
			}	
			runHeightBitmap();
			clearBitmap(RT_BITMAP0,6);
			//Waitdraw();
			passiveSubscreen();
			if(!isFrozen||isBottleFrozen)
			{
				EmptyBottleGlobal();
			}
			Tango_Update2();
			if(isFrozen)LinkMovement_SetLinkSpeedBoost(0);
			LinkMovement_Update2();
			Waitframe();
		}
	}//end mainGlobal
	//start destruction
	void destruction()
	{
		unless(!Game->GetCurDMap()&&Game->GetCurScreen()==32)
		{
			if(subscreen)
			{
				toggleSubscreen();
				Waitframe();
			}
			//Hero->Warp(0,32);
			Hero->WarpEx({WT_IWARP,0,32,-1,WARP_A,WARPEFFECT_NONE,SFX_DESTRUCTION,WARPFLAGS_DESTRUCTION});
			Waitframes(2);
			u args[8];
			if(LEARNED_SONGS[SONG_SongOfTime]&&Hero->Item[IT_OCARINA])
			{
				args[0]=3;
			}
			else
			{
				args[0]=4;
			}
			RunFFCScript(FFC_SHOWSTRING, args);
		}
	}
	//end destruction
	//start extra
	void layer4Toggle()
	{
		if(Input->Press[CB_EX4])
		{
			hideLayer4 = !hideLayer4;
			layer4check();
		}
	}
	
	void layer4check()
	{
		Screen->LayerInvisible[3] = true; //Drawn by `DrawLayer3_4()`
		Screen->LayerInvisible[4] = true; //Drawn by `DrawLayer3_4()`
		Screen->LayerOpacity[4] = OP_TRANS;
	}
	
	void drawExtraLayerEffects()
	{
		if(songOfStormsRain)
		{
			Screen->DrawScreen(6,LAYERSMAP1,LAYERSCREEN_RAIN,0,0,0);
		}
		int downdmap = getDownDMap();
		if(downdmap>-1)
		{
			int screen = getDownScreen(false);
			if(screen>-1)
			{
				dmapdata ddmap = Game->LoadDMapData(downdmap);
				drawHeightLayerData(ddmap->Map,screen,false);
			}
		}
		unless(hideLayer4)
		{
			int updmap = getUpDMap();
			if(updmap>-1)
			{
				int screen = getUpScreen(false);
				if(screen>-1)
				{
					dmapdata udmap = Game->LoadDMapData(updmap);
					drawHeightLayerData(udmap->Map,screen,true);
					//printf("map,screen: %d,%d\n",udmap->Map,screen);
				}
			}
		}
	}
	
	void drawHeightLayerData(int map, int screen, bool upper)
	{
		mapdata m = Game->LoadMapData(map,screen);
		unless(m->State[ST_ITEM])
		{
			if(m->HasItem)
			{
				unless(Game->LoadItemData(m->Item)->Type == IC_STRAYFAIRY)
					HeightFastTile(upper,upper?2:3,m->ItemX,m->ItemY,loadItemTile(m->Item),loadItemTile(m->Item),OP_TRANS);
			}
		}
		for(int i = MIN_FFC; i < MAX_NONRESERVED_FFC; i++)
		{
			int data = m->FFCData[i];
			switch(m->FFCScript[i])
			{
				case FFC_CHEST:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getChestCombo(data,m->GetFFCInitD(i, 0)),m->FFCCSet[i],OP_OPAQUE);
					break;
				case FFC_OWL:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getOwlCombo(m->GetFFCInitD(i, 0)),m->FFCCSet[i],OP_OPAQUE);
					break;
				case FFC_NPC:
					int cmbo = getNPCCombo(m->FFCData[i], m->GetFFCInitD(i, 0)+0, m->GetFFCInitD(i, 1)+0, m->GetFFCInitD(i, 2)+0, m->GetFFCInitD(i, 3)+0, m->GetFFCInitD(i, 4)+0, m->GetFFCInitD(i, 5)+0, (m->GetFFCInitD(i, 7))>0);
					if(m->FFCTileWidth[i] > 1 || m->FFCTileHeight[i] > 1)
					{
						combodata cmbod = Game->LoadComboData(cmbo);
						for(int x = 0; x < m->FFCTileWidth[i]; ++x)
						{
							for(int y = 0; y < m->FFCTileHeight[i]; ++y)
							{
								HeightFastTile(upper,upper?2:3,m->FFCX[i] + (16*x),m->FFCY[i] + (16*y),cmbod->Tile + (x) + (20*y) + (gameframe % Max(cmbod->Frames,1)),m->FFCCSet[i],OP_OPAQUE);
							}
						}
					}
					else
					{
						HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],cmbo,m->FFCCSet[i],OP_OPAQUE);
					}
					break;
				case FFC_SOFTSOIL:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getSoilCombo(m->GetFFCInitD(i,4)),m->FFCCSet[i],OP_OPAQUE);
					break;
				case FFC_TORCH:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getTorchCombo(m->GetFFCInitD(i,0),m->GetFFCInitD(i,2),m->GetFFCInitD(i,3),m->GetFFCInitD(i,5)),m->FFCCSet[i],OP_OPAQUE);
					break;
				default:
					if(data==0)break;
					if(data==COMBO_INVIS)break;
					combodata cdata = Game->LoadComboData(data);
					int tile = cdata->Tile;
					int ffwidth = m->FFCTileWidth[i];
					int ffheight = m->FFCTileHeight[i];
					for(int width = 0; width < ffwidth; width++)
					{
						for(int height = 0; height < ffheight; height++)
						{
							HeightFastTile(upper,upper?2:3,m->FFCX[i]+(width*16),m->FFCY[i]+(height*16),tile+(width)+(height*20),m->FFCCSet[i],Cond((m->FFCFlags[i] & FFCBF_TRANS)>0,OP_TRANS,OP_OPAQUE));
						}
					}
			}
		}
	}
	
	void changedScreens()
	{
		songOfStormsRain = false;
		unless(floating)Hero->Invisible=false;
		setGlobalVar(GVAR_MGSTATE,GV_MISC,MG_NONE);
		Hero->BigHitbox = false;
		Items::updateItemMapdata();
		mapdata cur = CurMapdata();
		if(getGlobalBool(GVAR_DID_HEIGHTWARP, GV_MISC_BOOL))
		{
			setGlobalBool(GVAR_DID_HEIGHTWARP, GV_MISC_BOOL, false);
			cur->Pattern = PATTERN_NO_SPAWNING;
		}
		else
		{
			mapdata map = getBottomMapdata();
			for(int q = 0; q < MAX_MAPDATA_HEIGHT; ++q)
			{
				if(!heightData[q]) break;
				heightData[q]->Pattern = heightPattern[q];
				heightData[q]->HasItem = hasItemData[q];
			}
			for(int q = 0; q < MAX_MAPDATA_HEIGHT; ++q)
			{
				heightData[q] = map;
				heightPattern[q] = <EnemyPattern>(map->Pattern);
				hasItemData[q] = map->HasItem;
				if(map->HasItem && Game->LoadItemData(map->Item)->Type == IC_STRAYFAIRY && !map->State[ST_ITEM])
				{
					map->HasItem = 0;
					if(map!=cur)
					{
						item fairy = CreateItemAt(map->Item, map->ItemX, map->ItemY);
						fairy->Misc[ITEMMISC_LAYERDMAP] = Game->GetCurDMap() + 1 + getRelativeHeight(map);
						fairy->Misc[FAIRYMISC_TYPE] = FAIRY_MAPDATA;
						fairy->Misc[FAIRYMISC_VALUE] = map;
					}
				}
				map = upMapdata(map);
			}
			cur->Pattern = PATTERN_NO_SPAWNING;
			holdingBomb = false;
		}
	}
	
	void changedLevel()
	{
		for(int i = 4 * MAX_LEVEL - 1; i >= 0; i--)
		{
			torchPuzzle[i]=0;
		}
		torchPuzzleTimer=0;
		for(int soilindex = 0; soilindex < 10; soilindex++)
		{
			setSoilState(soilindex,SSSTATE_WAITING); //Reset soft soil to default state
		}
	}
	
	void changedDMap()
	{
		
	}
	
	void onLinkHurt()
	{
		arrowAimMode=false;
	}
	
	void varDecrements()
	{
		if(usingBugs>0)usingBugs--;
		if(beanCounter>0)beanCounter--;
		if(torchPuzzleTimer>0)
		{
			torchPuzzleTimer--;
			if(torchPuzzleTimer==0)
			{
				for(int i = 4 * MAX_LEVEL - 1; i >= 0; i--)
				{
					torchPuzzle[i]=0;
				}
			}
		}
		if(dekuStickLitTimer>0)dekuStickLitTimer--;
	}
	
	void varIntegrity()
	{
		if(floating<0)floating=0;
		if(Deku_flying<0)Deku_flying=0;
		if(Game->MCounter[CR_SBOMBS]>1)Game->MCounter[CR_SBOMBS]=1;//PATCHWORK//
		if(rafting&&Hero->Action!=LA_RAFTING)
		{
			canFall=true;
			rafting=false;
		}
		else if(!rafting&&Hero->Action==LA_RAFTING)
		{
			canFall=false;
			rafting=true;
		}
		if(getGlobalBool(GVAR_PICTURE_MODE,GV_MISC_BOOL)||debugCanFall)canFall=false;
	}//end
	void raftingCheck()//start rafting
	{
		if(Hero->Action==LA_RAFTING)
		{
			Rafting[RAFT_DIR]=-1;
			if(Input->Press[CB_RIGHT]&&CanWalk(Hero->X,Hero->Y,DIR_RIGHT,16,false))
			{
				Hero->X+=16;
				Hero->Action=LA_NONE;
			}
			else if(Input->Press[CB_LEFT]&&CanWalk(Hero->X,Hero->Y,DIR_LEFT,16,false))
			{
				Hero->X-=16;
				Hero->Action=LA_NONE;
			}
			else if(Input->Press[CB_UP]&&CanWalk(Hero->X,Hero->Y,DIR_UP,16,false))
			{
				Hero->Y-=16;
				Hero->Action=LA_NONE;
			}
			else if(Input->Press[CB_DOWN]&&CanWalk(Hero->X,Hero->Y,DIR_DOWN,16,false))
			{
				Hero->Y+=16;
				Hero->Action=LA_NONE;
			}
		}
		else if(Rafting[RAFT_DIR]!=-1)
		{
			NoAction();
			if(Rafting[RAFT_UP]>0)
			{
				warpUps(Rafting[RAFT_UP]);
				Rafting[RAFT_UP]=-1;
				u args[8] = {Rafting[RAFT_DIR],0,0,2};
				Rafting[RAFT_DIR] = -1;
				Waitframe();
				RunFFCScript(FFC_SOFTSOIL,args);
			}
			else
			{
				//
				Hero->Dir=Rafting[RAFT_DIR];
				if(Rafting[RAFT_X]!=-1&&Rafting[RAFT_Y]!=-1&&!(gameframe%5))
				{
					Hero->X = Rafting[RAFT_X];
					Hero->Y = Rafting[RAFT_Y];
				}
				Hero->Action = LA_RAFTING;
				if(Rafting[RAFT_DIR]==DIR_DOWN)
				{
					Input->Press[CB_DOWN]=true;
					Input->Button[CB_DOWN]=true;
				}
				else if(Rafting[RAFT_DIR]==DIR_RIGHT)
				{
					Input->Press[CB_RIGHT]=true;
					Input->Button[CB_RIGHT]=true;
				}
				else if(Rafting[RAFT_DIR]==DIR_LEFT)
				{
					Input->Press[CB_LEFT]=true;
					Input->Button[CB_LEFT]=true;
				}
				else if(Rafting[RAFT_DIR]==DIR_UP)
				{
					Input->Press[CB_UP]=true;
					Input->Button[CB_UP]=true;
				}
			}
		}
	}//end rafting
	void warpfloors()//start
	{
		if(warpNumFloors>0)
		{
			warpUps(warpNumFloors);
			warpNumFloors = 0;
		}
		else if(warpNumFloors<0)
		{
			warpDowns(-warpNumFloors);
			warpNumFloors = 0;
		}
	}//end
	void timePalette()//start
	{
		if(hour>=6-MULT_SUNRISE && hour < 6)
		{
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			unless(isActiveGradient())
			{
				runGradient(getGlobalVar(TINT_NIGHT,GV_PAL),getGlobalVar(TINT_DAY,GV_PAL),FRAMES_HOUR*MULT_SUNRISE,true);
			}
		}
		else if(hour>=18-MULT_SUNRISE && hour < 18)
		{
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			if(time == 0 && hour == 18-MULT_SUNRISE)
			{
				runGradient(getGlobalVar(TINT_DAY,GV_PAL),getGlobalVar(TINT_SUNSETORANGE,GV_PAL),FRAMES_HOUR*MULT_SUNRISE/2);
			}
			
			unless(MULT_SUNRISE%2)
			{
				if(time==0 && hour == 18-(MULT_SUNRISE/2))
				{
					runGradient(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),getGlobalVar(TINT_NIGHT,GV_PAL),1 + FRAMES_HOUR*MULT_SUNRISE/2);
				}
			}
			else
			{
				if(time==FRAMES_HOUR/2 && hour == 18-Ceiling(MULT_SUNRISE))
				{
					runGradient(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),getGlobalVar(TINT_NIGHT,GV_PAL),FRAMES_HOUR*MULT_SUNRISE/2);
				}
			}
		}
		else if(hour > 5 && hour < 18-MULT_SUNRISE)
		{
			endGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),true);
			//refreshTint();
		}
		else if(hour > 17 || hour < 6-MULT_SUNRISE)
		{
			endGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),true);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			//refreshTint();
		}
		if(isOverworldScreen())
		{
			unhideGradient();
		}
		else
		{
			hideGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),true);
		}
	}//end
	//start TestingMenu
	void testingMenu()//start
	{
		unless(dbsetup)debugSetup();
		if(debug || dbdraw)
		{
			drawDebugString(256,6*0,"Time: 00.0000",true);//Display base time, with formatting
			drawDebugInt(256-(4*4)-(2),6*0,trueTime,true);//Display integer time
			drawDebugInt(256,6*0,(trueTime%1)*10000,true);//Display decimal time
			char buf[32] = "NoSav: ";
			itoa(buf, 7, noSave ? 1 : 0);
				drawDebugString(256,6*1,buf,true);
			drawDebugString(256, 6*2, "Stray Fairies:",true);
			for(int q = 0; q < 5; ++q)
				drawDebugInt(256,6*(3+q),getGlobalVar(GVAR_FAIRY_START + q, GV_MISCRESETTABLE),true);
			drawDebugInt(256,6*8,Hero->Action,true);
		}
		unless(isFrozen)
		{
			if(Input->ReadKey[KEY_TILDE])
			{
				debug=!debug;
				Hero->CollDetection=!debug;
				canFall=!debug;
			}
			if(debug)
			{
				drawDebugString(0,0,"DEBUG MODE",false);
				drawDebugString(0,156,"   TDBG: ~ | TIME: UDLR | REF: = | FRZ: ENTER | WARP: NUMS             ",false);
				drawDebugString(0,162," REFRESH: R | DBDRAW: \\ | CANFALL: F | UPDOWN: [] | NOSAV: N-         ",false);
				//Hour manipulation
				if(Input->ReadKey[KEY_UP])
				{
					++hour;
					trueTime+=3600*FRAME;
					if(hour>23)
					{
						hour-=24;
					}
					if(hour==6)
					{
						++day;
						if(day>3)
						{
							day-=3;
							trueTime-=(3600*24*FRAME);
							trueTime-=(3600*24*FRAME);
							trueTime-=(3600*24*FRAME);
						}
					}
				}
				if(Input->ReadKey[KEY_DOWN])
				{
					--hour;
					trueTime-=3600*FRAME;
					if(hour<0)
					{
						hour+=24;
					}
					if(hour==5)
					{
						--day;
						if(day<1)
						{
							day+=3;
							trueTime+=(3600*24*FRAME);
							trueTime+=(3600*24*FRAME);
							trueTime+=(3600*24*FRAME);
						}
					}
				}
				//Day manipulation
				if(Input->ReadKey[KEY_RIGHT])
				{
					++day;
					trueTime+=(3600*24*FRAME);
					if(day>3)
					{
						day-=3;
						trueTime-=(3600*24*FRAME);
						trueTime-=(3600*24*FRAME);
						trueTime-=(3600*24*FRAME);
					}
				}
				if(Input->ReadKey[KEY_LEFT])
				{
					--day;
					trueTime-=(3600*24*FRAME);
					if(day<1)
					{
						day+=3;
						trueTime+=(3600*24*FRAME);
						trueTime+=(3600*24*FRAME);
						trueTime+=(3600*24*FRAME);
					}
				}
				if(Input->ReadKey[KEY_EQUALS])//Refill Ammo
				{
					Game->Counter[CR_BOMBS]=Game->MCounter[CR_BOMBS];
					Game->Counter[CR_RUPEES]=Game->MCounter[CR_RUPEES];
					Game->Counter[CR_ARROWS]=Game->MCounter[CR_ARROWS];
					Game->Counter[CR_SBOMBS]=Game->MCounter[CR_SBOMBS];
					Game->Counter[CR_BOMBCHUS]=Game->MCounter[CR_BOMBCHUS];
					Game->Counter[CR_DEKUNUTS]=Game->MCounter[CR_DEKUNUTS];
					Game->Counter[CR_MAGICBEANS]=Game->MCounter[CR_MAGICBEANS];
					Game->Counter[CR_MAGIC]=Game->MCounter[CR_MAGIC];
					Game->DCounter[CR_BOMBS]=0;
					Game->DCounter[CR_RUPEES]=0;
					Game->DCounter[CR_ARROWS]=0;
					Game->DCounter[CR_SBOMBS]=0;
					Game->DCounter[CR_BOMBCHUS]=0;
					Game->DCounter[CR_DEKUNUTS]=0;
					Game->DCounter[CR_MAGICBEANS]=0;
					Game->DCounter[CR_MAGIC]=0;
				}
				if(Input->ReadKey[KEY_ENTER])//Freeze time
				{
					freezeTime=!freezeTime;
					slowTime=freezeTime;
				}
				if(Input->ReadKey[KEY_MINUS_PAD])
				{
					noSave = !noSave;
				}
				if(Input->ReadKey[KEY_0])Hero->Warp(0,0x24);//Warp to test area
				if(Input->ReadKey[KEY_9])Hero->Warp(6,0x43);//Warp to Bomber's Hideout
				if(Input->ReadKey[KEY_R])Hero->PitWarp(Game->GetCurDMap(),Game->GetCurDMapScreen());//Reset the screen by pitwarping to it
				if(Input->ReadKey[KEY_BACKSLASH])dbdraw = !dbdraw;
				if(Input->ReadKey[KEY_F])debugCanFall = !debugCanFall;
				if(Input->ReadKey[KEY_OPENBRACE])warpDown();
				if(Input->ReadKey[KEY_CLOSEBRACE])warpUp();
				if(Input->ReadKey[KEY_Y])
				{
					Hero->Action = LA_RAFTING;
					debug = false;
				}
				TotalNoAction();
			}
		}
	}//end
	
	void debugSetup()//start
	{
		dbsetup=true;
		//dbdraw=true;
		noSave=true;
		Game->Cheat=4;
		for(int i = 0;i<22;i++)
		{
			LEARNED_SONGS[i]=true;
		}
		for(int i=0;i<48;i++)
		{
			if(ItemIDs[i]!=0)Hero->Item[ItemIDs[i]]=true;
		}
		//bbags
		Hero->Item[IT_BOMBBAG]=true;
		Hero->Item[IT_BOMBBAG_BIG]=true;
		Hero->Item[IT_BOMBBAG_BIGGEST]=true;
		Hero->Item[IT_BOMBBAG_POWDERKEG]=true;
		//quivs
		Hero->Item[IT_QUIVER]=true;
		Hero->Item[IT_QUIVER_BIG]=true;
		Hero->Item[IT_QUIVER_BIGGEST]=true;
		Game->MCounter[CR_LIFE]=320;
		Game->MCounter[CR_MAGIC]=MAX_MAGIC;
		Game->Counter[CR_LIFE]=320;
		Game->Counter[CR_MAGIC]=MAX_MAGIC;
		Game->MCounter[CR_BOMBCHUS]=40;
		Game->MCounter[CR_ARROWS]=50;
		Game->MCounter[CR_BOMBS]=40;
		Game->MCounter[CR_SBOMBS]=1;
		//extra
		form=FORM_HUMAN;
		mask=MASK_BUNNY;
		currMaskTile=maskTile(MASK_BUNNY);
		HMS_Cutscene.HMS_visible=true;
		HMS_Cutscene.CS1_seen=true;
	}//end
	
	void drawDebugInfo(int itID)//start
	{
		if(itID!=0)
		{
			char str[256];
			itemdata theItem = Game->LoadItemData(itID);
			theItem->GetName(str);
			drawDebugString(256,0,str,true);
		}
		if(itID>=146&&itID<=151)//BottleDebugger
		{
			char str[256];
			int bstate = getBottleState(itID-145);
			getBottleStateName(bstate,str);
			drawDebugString(256,8,str,true);
			if(bstate==BS_HOTWATER)drawDebugInt(240,16,springTimers[itID-146]);
		}
	}//end
	
	//start dbDrawFuncs
	void drawDebugString(int x, int y, char str,bool right)
	{
		int format = TF_NORMAL;
		if(right)format = TF_RIGHT;
		Screen->DrawString(7,x,y,FONT_Z3SMALL,0x01,0x00,format,str,OP_OPAQUE);
	}
	
	void drawDebugInt(int x, int y, int num, bool right)
	{
		if(right)x-=Cond(num<0,4,0) + Cond(num<10 && num > -10,4,Cond(num<100&&num>-100,8,Cond(num<1000&&num>-1000,12,16)));
		Screen->DrawInteger(7,x,y,FONT_Z3SMALL,0x01,0x00,0,0,num,0,OP_OPAQUE);
	}
	
	void drawDebugInt(int x, int y, int num)
	{
		drawDebugInt(x,y,num,false);
	}//end
	//end TestingMenu
	//start loops
	void lwLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumLWeapons(); i > 0; --i)
		{
			lweapon weap = Screen->LoadLWeapon(i);
			unless(weap->Misc[LWMISC_LAYERDMAP]) weap->Misc[LWMISC_LAYERDMAP] = THISDMAP + 1;
			switch(weap->ID)
			{
				case LW_ARROW:
					weap->ScriptTile = TILE_INVIS;
					if((weap->Misc[LWMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightAngularTile(4,weap->X+8,weap->Y+8,weap->OriginalTile + 1,weap->TileWidth,weap->TileHeight,weap->CSet,-1,-1,weap->X+8,weap->Y+8,RadtoDeg(weap->Angle),0,true,OP_OPAQUE);
					}
					else if((weap->Misc[LWMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightAngularTile(3,weap->X+8,weap->Y+8,weap->OriginalTile + 1,weap->TileWidth,weap->TileHeight,weap->CSet,-1,-1,weap->X+8,weap->Y+8,RadtoDeg(weap->Angle),0,true,OP_OPAQUE);
					}
					else
					{
						MooshDrawTile(6,weap->X+8,weap->Y+8,weap->OriginalTile + 1,1,1,weap->CSet,16,16,weap->X+8,weap->Y+8,RadtoDeg(weap->Angle),0,true,OP_OPAQUE);
					}
					break;
					
				default:
					if((weap->Misc[LWMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->OriginalTile + weap->Frame,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else if((weap->Misc[LWMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->OriginalTile + weap->Frame,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else weap->ScriptTile = -1;
			}
			weap->HitXOffset = 300 * ((weap->Misc[LWMISC_LAYERDMAP]-1)-THISDMAP) + weap->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	
	void ewLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumEWeapons(); i > 0; --i)
		{
			eweapon weap = Screen->LoadEWeapon(i);
			unless(weap->Misc[EWMISC_LAYERDMAP]) weap->Misc[EWMISC_LAYERDMAP] = THISDMAP + 1;
			switch(weap->ID)
			{
				default:
					if((weap->Misc[EWMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->Tile,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else if((weap->Misc[EWMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->Tile,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else weap->ScriptTile = -1;
			}
			weap->HitXOffset = 300 * ((weap->Misc[LWMISC_LAYERDMAP]-1)-THISDMAP) + weap->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	
	void itemLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumItems(); i > 0; --i)
		{
			item it = Screen->LoadItem(i);
			unless(it->Misc[ITEMMISC_LAYERDMAP]) it->Misc[ITEMMISC_LAYERDMAP] = THISDMAP + 1;
			switch(it->ID)
			{
				default:
					if((it->Misc[ITEMMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,it->X+it->DrawXOffset,it->Y+it->DrawYOffset,it->Tile,it->CSet,OP_OPAQUE);
						it->ScriptTile = TILE_INVIS;
					}
					else if((it->Misc[ITEMMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,it->X+it->DrawXOffset,it->Y+it->DrawYOffset,it->Tile,it->CSet,OP_OPAQUE);
						it->ScriptTile = TILE_INVIS;
					}
					else it->ScriptTile = -1;
			}
			it->HitXOffset = (300 * ((it->Misc[ITEMMISC_LAYERDMAP]-1)-THISDMAP)) + ITEMHITXOFFSET + it->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	
	void npcLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumNPCs(); i > 0; --i)
		{
			npc n = Screen->LoadNPC(i);
			unless(n->Misc[NPCMISC_LAYERDMAP]) n->Misc[NPCMISC_LAYERDMAP] = THISDMAP + 1;
			switch(n->ID)
			{
				default:
					if((n->Misc[NPCMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,n->X,n->Y,n->Tile,n->CSet,OP_OPAQUE);
						n->ScriptTile = TILE_INVIS;
					}
					else if((n->Misc[NPCMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,n->X,n->Y,n->Tile,n->CSet,OP_OPAQUE);
						n->ScriptTile = TILE_INVIS;
					}
					else n->ScriptTile = -1;
			}
			n->HitXOffset = (300 * ((n->Misc[NPCMISC_LAYERDMAP]-1)-THISDMAP)) + n->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	//end loops
	void runExtraControls()//start extraControls
	{
		if(PressControl() && (Input->ReadKey[KEY_1] || Input->ReadKey[KEY_1_PAD]))
		{
			unless(toggleGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL))reskinSubscreen(1);
		}
		GameOverMenu::checkF6();
	}//end
	void handleOcarina()//start
	{
		if(songFrames>0)
		{
			Game->FFRules[qr_NOFASTMODE] = true;
			TotalNoAction();
			ocarina_mode = false;
			unless(fakeSong)
				drawNotes();
			--songFrames;
			if(songFrames==1) Screen_Freeze(FREEZE_ACTION_BUT_FFC);
			unless(songFrames)
			{
				Game->FFRules[qr_NOFASTMODE] = false;
				if(midiToReturn!=-6&&midiToReturn<205)
					Audio->PlayMIDI(midiToReturn);
				unless(fakeSong||playedSong<0)
					activateSong(playedSong);
				playedSong=-1;
				fakeSong=false;
				unless(subscreen)
					Screen_Freeze(FREEZE_NONE);
			}
		}
		else
		{
			midiToReturn = Game->GetMIDI();
		}
		if(OC_doItemJinx)
		{
			if(Input->Button[CB_B])
			{
				Hero->ItemJinx=2;
			}
			else
			{
				OC_doItemJinx=false;
			}
		}
		if(ocarina_mode)
		{
			Screen_Freeze(FREEZE_ACTION);
			ocarina();
			Input->Press[CB_START]=false;
			Input->Button[CB_START]=false;
		}
		if(scarecrowRecord)
		{
			scarecrow();
		}
		if(ocarina_mode||scarecrowRecord||songFrames>0)
		{
			Hero->CollDetection = false;
		}
		else
		{
			Hero->CollDetection = true;
		}
	}
}//end
	void handleTintPausing()//start
	{
		if(opt[OPT_HIDE_TINT_IN_MENU]) hideAllTints(subscreen || getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL));
		else hideAllTints(false);
	}//end
//end Global Script
//start OnContinue Script
global script onFileLoad
{
	void run()
	{
		onLaunch();
		if(daysAgo() >= DAYS_TO_HINT_RESET)
		{
			resetHintBools();
			storeTime();
		}
		if(owlSaved)
		{
			owlSaved=false;
			Game->Save();
		}
		else
		{
			resetTime();
			Game->ContinueDMap=0;
			Game->ContinueScreen=0;
			Game->Save();
		}
		tintOnContinue();
		OptionsMenu.reloadOptions();
		onLaunchEnd();
	}
}//end
//start OnExit Script
global script onExit
{
	void run()
	{
		storeTime();
	}
}
//end OnExit Script
//start onLaunch
void onLaunch() //Called from `Init` and `OnContinue`
{
	ClearTrace();
	TraceS("[MM2D] Launching TLoZ: Majora's Mask 2D...\n");
	Game->DisableActiveSubscreen = true; //Disable engine subscreen.
	refreshDisable();
	testrun();
	initGame(); //Handle rando stuff here.
	OptionsMenu.init();
	arrowAimMode = false;
	Game->MCounter[CR_BOMBCHUS]=Hero->Item[IT_BOMBBAG]?40:0;
	LinkMovement_Init();
	TangoInit();
	HeroDir8 = validateDir(getPressedDir8(), Hero->Dir);
	reloadDoubleDef(); //Set defense based on Fierce Deity + Double Def reward
	//start Ocarina init
	scarecrowMode = false;
	scarecrowRecord = false;
	ocIndex = 0;
	playedSong = -1;
	songFrames = 0;
	midiToReturn = 0;
	//end Ocarina init
	subscreen = false;
	clearBitmap(RT_BITMAP0);
	setGlobalBool(GVAR_PICTURE_MODE,GV_MISC_BOOL,false);
}

void onLaunchEnd()
{
	for(int q = 0; q < susptLAST; ++q)
	{
		Game->Suspend[q] = false;
		indivFreeze[q] = false;
		forceActive[q] = false;
	}
	loadStoragePath();
	TraceS("[MM2D] Finished init\n");
}

void refreshDisable()
{
	Input->DisableButton[CB_L] = true;
	Input->DisableButton[CB_R] = true;
	Input->DisableButton[CB_MAP] = true;
	Input->DisableButton[CB_START] = true;
	for(int q = 0; q < 127; ++q)
	{
		switch(q)
		{
			//Always disable
			case KEY_F6: //Custom F6 Menu
			case KEY_ENTER: //OptionsMenu
			case KEY_ENTER_PAD: //OptionsMenu
			case KEY_BACKSPACE: //OptionsMenu
				Input->DisableKey[q] = true;
				continue;
			//Only disable if debug mode
			case KEY_TILDE:
				Input->DisableKey[q] = debugEnabled;
				continue;
			default:
				Input->DisableKey[q] = false;
		}
	}
	Input->DisableKey[Controls[CONTROL_OPTIONS]] = true;
}
//end
//start Game Init
void initGame()
{
	if(getGlobalBool(GVAR_GAMEINITIALIZED,GV_MISC_BOOL)) return; //Already initialized!
	//Do initialization things, which may take into account randomizer stuff.
	//UNFINISHED
	//From here, the standard options menu should be brought up, with a prompt when you close telling you that you can press (button) to re-open the menu at any time.
	//Then, open the rando menu, and allow choosing of rando settings.
	//Finally, run the randomizer (if chosen), and init everything.
	Items::defaultItemInit();
	Items::initUpgrade();
	Items::updateItemMapdata();
	setGlobalBool(GVAR_GAMEINITIALIZED,GV_MISC_BOOL,true);
}
//end Game Init
//start Options Menu
untyped opt[256] = {false, true, 1, 30, OptionsMenu.MENU_FONT_DEFAULT};
enum
{
	OPT_RFS,
	OPT_HIDE_TINT_IN_MENU,
	OPT_MENU_SCROLL_MULT,
	OPT_MENU_HOLD_DELAY,
	OPT_OPTIONS_FONT
};

hero script OptionsMenu
{
	//States are equivalent to the mainOption value that represents that state
	enum OptState
	{
		STATE_MAIN = -1,
		STATE_RFS,
		STATE_LT,
		STATE_TINTHIDE,
		STATE_MENU_SCROLL_SPEED,
		STATE_MENU_HOLD_DELAY,
		STATE_OPTIONSKEY,
		STATE_OPT_MENU_FONT,
		STATE_RESET_DEFAULT,
		STATE_MENU_MAX
	};
	
	int tabs[] = {STATE_RFS, STATE_OPTIONSKEY, STATE_OPT_MENU_FONT, STATE_MENU_MAX};
	enum Tab
	{
		TAB_INVALID = -1,
		TAB_OPT,
		TAB_CONTROL,
		TAB_SYSTEM,
		TAB_END
	};
	
	bitmap menu;
	
	//start Menu constants & vars
	CONFIG MENU_SPACING = 16;
	CONFIG MENU_FONT_DEFAULT = FONT_Z3SMALL;
	int MENU_FONT_HEIGHT = FONT_Z3SMALL_HEIGHT;
	CONFIG TOP_MENU = -56;
	CONFIG MENU_TAB_MARGIN = 24;
	CONFIG MENU_TOP_MARGIN_HEIGHT = 16 + MENU_TAB_MARGIN;
	CONFIG MENU_LEFT_MARGIN_WIDTH = 16;
	CONFIG MENU_RIGHT_MARGIN_WIDTH = 16;
	CONFIG MENU_BOTTOM_MARGIN_HEIGHT = 32;
	CONFIG MENU_LAYER = 7;
	CONFIG MENU_SCROLL_INC = 8;
	CONFIG MENU_SCROLL_SPEED = 8;
	COLOR MENU_TCOLOR_INACTIVE_PERM = WHITE;
	COLOR MENU_TCOLOR_INACTIVE_TEMP = LIGHTGRAY;
	COLOR MENU_TCOLOR_ACTIVE = YELLOW;
	COLOR MENU_TCOLOR_CONTROLS = DEEPRED;
	COLOR MENU_TCOLOR_TABS = LIGHTDEEPBLUE;
	//
	CONFIG MENU_ENFORCE_MARGINS = 1;
	//
	DEFINE MENU_SCREEN_WIDTH = 256;
	DEFINE NUM_MENU_BITMAPS = TAB_END + 1;
	DEFINE VIS_SCREEN_HEIGHT = 168 - TOP_MENU;
	int maxOptPerTab;
	int __MHEIGHT = (STATE_MENU_MAX * (MENU_SPACING + MENU_FONT_HEIGHT + MENU_FONT_HEIGHT)) - MENU_SPACING + MENU_TOP_MARGIN_HEIGHT + MENU_BOTTOM_MARGIN_HEIGHT;
	int OP_HEIGHT = __MHEIGHT < VIS_SCREEN_HEIGHT ? VIS_SCREEN_HEIGHT : __MHEIGHT;
	DEFINE MENU_TOP_MARGIN = TOP_MENU + MENU_TOP_MARGIN_HEIGHT;
	DEFINE MENU_LEFT_MARGIN = MENU_LEFT_MARGIN_WIDTH;
	DEFINE MENU_RIGHT_MARGIN = 255 - MENU_RIGHT_MARGIN_WIDTH;
	DEFINE MENU_BOTTOM_MARGIN = 168 - MENU_BOTTOM_MARGIN_HEIGHT;
	DEFINE MENU_TABLABEL_Y = MENU_TOP_MARGIN - FONT_Z3SMALL_HEIGHT - MENU_TAB_MARGIN;
	
	DEFINE MENU_CONTROL_X = 0;
	DEFINE MENU_CONTROL_Y = 0;
	DEFINE MENU_START_TABS_X = MENU_SCREEN_WIDTH;
	DEFINE MENU_PERM_Y = 0;
	int MENU_TEMP_Y = OP_HEIGHT;
	
	int MENU_BITMAP_HEIGHT = OP_HEIGHT * 2;
	DEFINE MENU_BITMAP_WIDTH = MENU_SCREEN_WIDTH * NUM_MENU_BITMAPS;
	DEFINE TABS_WIDTH = TAB_END * MENU_SCREEN_WIDTH;
	
	int MAX_SCROLL = OP_HEIGHT - VIS_SCREEN_HEIGHT;
	DEFINE MENU_CONTROL_LIST = MENU_SCREEN_WIDTH*2;
	//end
	void updateOptFont(int font) //start
	{
		opt[OPT_OPTIONS_FONT] = font;
		MENU_FONT_HEIGHT = Text->FontHeight(font);
		__MHEIGHT = (maxOptPerTab * (MENU_SPACING + MENU_FONT_HEIGHT + MENU_FONT_HEIGHT)) - MENU_SPACING + MENU_TOP_MARGIN_HEIGHT + MENU_BOTTOM_MARGIN_HEIGHT;
		OP_HEIGHT = __MHEIGHT < VIS_SCREEN_HEIGHT ? VIS_SCREEN_HEIGHT : __MHEIGHT;
		MENU_TEMP_Y = OP_HEIGHT;
		MAX_SCROLL = OP_HEIGHT - VIS_SCREEN_HEIGHT;
		MENU_BITMAP_HEIGHT = OP_HEIGHT * 2;
		init_bitmap(true); //Force re-create bitmap for new size
		menu->Rectangle(6, 0, 0, MENU_BITMAP_WIDTH, MENU_BITMAP_HEIGHT, 0x00, 1, 0, 0, 0, true, OP_OPAQUE); //Clear bitmap for 1 frame, for reloading
	}//end
	DEFINE MAX_FONT = FONT_LISA;
	DEFINE MIN_FONT = FONT_Z1;
	void incOptFont(int dir) //start
	{
		if(dir==DIR_UP)
		{
			do
			{
				++opt[OPT_OPTIONS_FONT];
				if(opt[OPT_OPTIONS_FONT] > MAX_FONT) opt[OPT_OPTIONS_FONT] = MIN_FONT;
			}
			until(validFont(opt[OPT_OPTIONS_FONT]));
		}
		else if(dir==DIR_DOWN)
		{
			do
			{
				--opt[OPT_OPTIONS_FONT];
				if(opt[OPT_OPTIONS_FONT] < MIN_FONT) opt[OPT_OPTIONS_FONT] = MAX_FONT;
			}
			until(validFont(opt[OPT_OPTIONS_FONT]));
		}
		updateOptFont(opt[OPT_OPTIONS_FONT]);
	} //end
	bool validFont(int font) //start
	{
		switch(font)
		{
			case FONT_ZTIME:
			case FONT_SUBSCREEN1:
			case FONT_SUBSCREEN2:
			case FONT_SUBSCREEN4:
			case FONT_GORON:
			case FONT_ZORAN:
			case FONT_HYLIAN1:
			case FONT_HYLIAN2:
			case FONT_HYLIAN3:
			case FONT_HYLIAN4:
			case FONT_DSPHANTOM:
			case FONT_APPLE2_80COL:
			case FONT_C64_HIRES:
			case FONT_COCO:
			case FONT_FDS_KANA:
			case FONT_FUTHARK:
			case FONT_HIRA:
			case FONT_JP:
			case FONT_SPECTRUM_LG:
				return false;
			default:
				return true;
		}
	} //end
	
	int optionScrollCheck(int option, int scroll)
	{
		option -= tabs[getTab(<OptState>option)];
		int optTop = menuposy(<OptState>option);
		int optBot = optTop + MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		if(optTop < scroll + (MENU_ENFORCE_MARGINS ? MENU_TOP_MARGIN_HEIGHT : 0)) return -1;
		if(optBot > scroll + VIS_SCREEN_HEIGHT - (MENU_ENFORCE_MARGINS ? MENU_BOTTOM_MARGIN_HEIGHT : 0)) return 1;
		return 0;
	}
	
	void init()
	{
		for(int q = 0; q < TAB_END; ++q)
		{
			int numopt = tabNumOpts(<Tab>q);
			if(numopt > maxOptPerTab) maxOptPerTab = numopt;
		}
		updateOptFont(opt[OPT_OPTIONS_FONT]);
		//init_bitmap(); //This is called from updateOptFont!
	}
	
	void init_bitmap()
	{
		init_bitmap(false);
	}
	void init_bitmap(bool force)
	{
		unless(menu->isAllocated()) menu = Game->CreateBitmap(MENU_BITMAP_HEIGHT, MENU_BITMAP_WIDTH);
		else if(force || !menu->isValid()) menu->Create(0, MENU_BITMAP_HEIGHT, MENU_BITMAP_WIDTH);
	}
	
	void run() //start
	{
		int frame = 0;
		init_bitmap();
		while(1)
		{
			Waitframe();
			Waitdraw();
			if(isFrozen && !getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL)) continue;
			
			if(getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL))
			{
				//Full options menu, with various global variables to be modified.
				int scroll = 0;
				int mainOption = 0;
				int subOption = 0;
				int tab = 0;
				int x = getTabPos(<Tab>tab);
				int lastLR = -1;
				int cooldown = 0;
				int inputTimer = 0;
				OptState state = STATE_MAIN;
				reloadBitmap(menu);
				int font = opt[OPT_OPTIONS_FONT];
				while(getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL))
				{
					if(getGlobalBool(GVAR_F6_MENU, GV_MISC_BOOL))
					{
						while(getGlobalBool(GVAR_F6_MENU, GV_MISC_BOOL)) Waitframe();
						TotalNoAction();
					}
					Waitdraw();
					if(font != opt[OPT_OPTIONS_FONT])
					{
						reloadBitmap(menu);
						font = opt[OPT_OPTIONS_FONT];
					}
					if(cooldown>0)--cooldown;
					++inputTimer;
					inputTimer %= opt[OPT_MENU_HOLD_DELAY];
					loadTempBitmap(menu);
					bool confirm = Input->Press[CB_A] || Input->ReadKey[KEY_ENTER] || Input->ReadKey[KEY_ENTER_PAD];
					bool deny = Input->Press[CB_B] || Input->ReadKey[KEY_BACKSPACE];
					const bool up = (Input->Press[CB_UP] || (Input->Button[CB_UP] && !inputTimer));
					const bool down = (Input->Press[CB_DOWN] || (Input->Button[CB_DOWN] && !inputTimer));
					const bool left = (Input->Press[CB_LEFT] || (Input->Button[CB_LEFT] && !inputTimer));
					const bool right = (Input->Press[CB_RIGHT] || (Input->Button[CB_RIGHT] && !inputTimer));
					//printf("%s,%s,%s,%s\n",up?"true":"false",down?"true":"false",left?"true":"false",right?"true":"false");
					if(Input->Press[CB_UP]||Input->Press[CB_DOWN]||Input->Press[CB_LEFT]||Input->Press[CB_RIGHT]) inputTimer = 0;
					//
					if(deny)
					{
						if(state == STATE_MAIN)
							setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
						else
							state = STATE_MAIN;
					}
					else if(Input->ReadKey[Controls[CONTROL_OPTIONS]])
					{
						setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
					}
					switch(state) //start
					{
						case STATE_MAIN: //start
						{
							//Scroll the menu visual based on currently selected option
							unless(mainOption-tabs[getTab(<OptState>mainOption)]) scroll = 0;
							else if(getTab(<OptState>mainOption)!=getTab(<OptState>(mainOption+1))) scroll = MAX_SCROLL;
							else if(optionScrollCheck(mainOption, scroll) != 0)
							{
								while(optionScrollCheck(mainOption, scroll) == 1)
								{
									scroll += MENU_SCROLL_INC;
								}
								while(optionScrollCheck(mainOption, scroll) == -1)
								{
									scroll -= MENU_SCROLL_INC;
								}
								scroll = VBound(scroll, MAX_SCROLL, 0);
							}
							switch(mainOption)
							{
								// "Options"
								
								case STATE_RFS:
									DrawMenuString("Flip Right-Facing Slash", menu, 2, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
									
								case STATE_LT:
									DrawMenuString("Lens Tint Color", menu, 2, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
									
								case STATE_TINTHIDE:
									DrawMenuString("Hide Tint In Menus", menu, 1, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
									
								case STATE_MENU_SCROLL_SPEED:
									DrawMenuString("Menu Scroll Speed", menu, 1, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
								
								case STATE_MENU_HOLD_DELAY:
									DrawMenuString("Menu Input Hold Delay", menu, 1, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
								
								// "Controls"
								
								case STATE_OPTIONSKEY:
									DrawMenuString("Options Menu", menu, 2, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
									
								// "System"
								
								case STATE_OPT_MENU_FONT:
									DrawMenuString("Font", menu, 1, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
									
								case STATE_RESET_DEFAULT:
									DrawMenuString("Reset All to Default", menu, 1, getTabPos(<OptState>mainOption) + MENU_LEFT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
									break;
							}
							if(confirm)
							{
								state = <OptState>mainOption;
								subOption = 0;
							}
							else if(up)
								--mainOption;
							else if(down)
								++mainOption;
							else unless(cooldown)
							{
								if(left)
								{
									lastLR = DIR_LEFT;
									--tab;
									if(tab < 0) tab += TAB_END;
									mainOption = tabs[tab];
									cooldown = 10;
								}
								else if(right)
								{
									lastLR = DIR_RIGHT;
									++tab;
									tab %= TAB_END;
									mainOption = tabs[tab];
									cooldown = 10;
								}
							}
							//Limit option scrolling to within-tab
							if(getTab(<OptState>mainOption) != tab)
							{
								if(mainOption < tabs[tab]) mainOption = tabs[tab+1] - 1;
								else mainOption = tabs[tab];
							}
							break;
						} //end
						
						case STATE_OPTIONSKEY: //start
						{
							char buf0[64];
							KeyToString(Controls[CONTROL_OPTIONS], buf0, true, true);
							DrawMenuString(buf0, menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, MENU_TCOLOR_ACTIVE, TF_RIGHT);
							if(Input->Button[CB_A]) break; //Don't take input while `A` is held
							int key = getKeyPress();
							switch(isValidKey(key))
							{
								case KV_VALID:
									Controls[CONTROL_OPTIONS] = key;
									refreshDisable(); //Ensure that the new key is disabled in-engine, and the old is not
									//Fall-through
								case KV_QUIT:
									state = STATE_MAIN;
									Game->TypingMode = false;
									break;
							}
							break;
						}//end
						
						case STATE_RFS:
						{
							DrawMenuString(opt[OPT_RFS] ? "  On" : "Off", menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, opt[OPT_RFS] ? GREEN : RED, TF_RIGHT);
							if(confirm)
								opt[OPT_RFS] = !opt[OPT_RFS];
							break;
						}
						
						case STATE_LT: //start
						{
							DEFINE PREVIEW = 0;
							DEFINE _RED = 1;
							DEFINE _GREEN = 2;
							DEFINE _BLUE = 3;
							int inc = (up) ? 1 : (down ? -1 : 0);
							if(right) ++subOption;
							else if(left) --subOption;
							subOption < 0 ? (subOption += 4) : (subOption %= 4);
							char rbuf[16], gbuf[16], bbuf[16];
							itoa(rbuf, __tintR[getGlobalVar(TINT_LENS, GV_PAL)]);
							itoa(gbuf, __tintG[getGlobalVar(TINT_LENS, GV_PAL)]);
							itoa(bbuf, __tintB[getGlobalVar(TINT_LENS, GV_PAL)]);
							strcat(rbuf, " ");
							strcat(gbuf, " ");
							DEFINE RWID = Text->StringWidth(rbuf, opt[OPT_OPTIONS_FONT]),
								GWID = Text->StringWidth(gbuf, opt[OPT_OPTIONS_FONT]),
								BWID = Text->StringWidth(bbuf, opt[OPT_OPTIONS_FONT]);
							switch(subOption)
							{
								case PREVIEW:
									DrawMenuString("Preview ", menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN - (RWID+GWID+BWID), MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, MENU_TCOLOR_ACTIVE, TF_RIGHT);
									if(confirm)
									{
										setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
										setTint(getGlobalVar(TINT_LENS, GV_PAL), true);
										hideAllTints(false);
										WaitTotalNoAction(30);
										Waitdraw();
										setTint(getGlobalVar(TINT_LENS, GV_PAL), false);
										setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, true);
									}
									break;
									
								case _RED:
									DrawMenuString(rbuf, menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN - (GWID+BWID), MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, RED, TF_RIGHT);
									__tintR[getGlobalVar(TINT_LENS, GV_PAL)] += inc;
									__tintR[getGlobalVar(TINT_LENS, GV_PAL)] = VBound(__tintR[getGlobalVar(TINT_LENS, GV_PAL)], 63, -63);
									break;
									
								case _GREEN:
									DrawMenuString(gbuf, menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN - (BWID), MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, GREEN, TF_RIGHT);
									__tintG[getGlobalVar(TINT_LENS, GV_PAL)] += inc;
									__tintG[getGlobalVar(TINT_LENS, GV_PAL)] = VBound(__tintG[getGlobalVar(TINT_LENS, GV_PAL)], 63, -63);
									break;
									
								case _BLUE:
									DrawMenuString(bbuf, menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, BLUE, TF_RIGHT);
									__tintB[getGlobalVar(TINT_LENS, GV_PAL)] += inc;
									__tintB[getGlobalVar(TINT_LENS, GV_PAL)] = VBound(__tintB[getGlobalVar(TINT_LENS, GV_PAL)], 63, -63);
									break;
							}
							break;
						}//end
						
						case STATE_TINTHIDE:
						{
							DrawMenuString(opt[OPT_HIDE_TINT_IN_MENU] ? "  On" : "Off", menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, opt[OPT_HIDE_TINT_IN_MENU] ? GREEN : RED, TF_RIGHT);
							if(confirm)
								opt[OPT_HIDE_TINT_IN_MENU] = !opt[OPT_HIDE_TINT_IN_MENU];
							break;
						}
						
						case STATE_MENU_SCROLL_SPEED:
						{
							char buf4[16] = "      x";
							if(opt[OPT_MENU_SCROLL_MULT]<1) strcat(buf4,"0.5");
							else itoa(buf4, 7, opt[OPT_MENU_SCROLL_MULT]);
							DrawMenuString(buf4, menu, 2, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, MENU_TCOLOR_ACTIVE, TF_RIGHT);
							if(up || right) opt[OPT_MENU_SCROLL_MULT] = opt[OPT_MENU_SCROLL_MULT] < 1 ? 1 : opt[OPT_MENU_SCROLL_MULT] << 1;
							else if(down || left) opt[OPT_MENU_SCROLL_MULT] >>= 1;
							opt[OPT_MENU_SCROLL_MULT] = VBound(opt[OPT_MENU_SCROLL_MULT], 8, 0.5);
							break;
						}
						
						case STATE_MENU_HOLD_DELAY:
						{
							char buf5[16] = "    ";
							itoa(buf5, 4, opt[OPT_MENU_HOLD_DELAY]);
							DrawMenuString(buf5, menu, 1, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, MENU_TCOLOR_ACTIVE, TF_RIGHT);
							if(up) opt[OPT_MENU_HOLD_DELAY] += 10;
							else if(down) opt[OPT_MENU_HOLD_DELAY] -= 10;
							else if(left) --opt[OPT_MENU_HOLD_DELAY];
							else if(right) ++opt[OPT_MENU_HOLD_DELAY];
							opt[OPT_MENU_HOLD_DELAY] = VBound(opt[OPT_MENU_HOLD_DELAY], 90, 2);
							break;
						}
						
						case STATE_OPT_MENU_FONT:
						{
							char buf[32];
							getFontName(buf, opt[OPT_OPTIONS_FONT]);
							DrawMenuString(buf, menu, 1, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, MENU_TCOLOR_ACTIVE, TF_RIGHT);
							if(down || right) incOptFont(DIR_UP);
							else if(up || left) incOptFont(DIR_DOWN);
							break;
						}
						
						case STATE_RESET_DEFAULT:
						{
							DrawMenuString("Are you sure?", menu, 1, getTabPos(<OptState>mainOption) + MENU_RIGHT_MARGIN, MENU_TEMP_Y + menuposy(<OptState>mainOption) + MENU_FONT_HEIGHT, MENU_TCOLOR_ACTIVE, TF_RIGHT);
							if(confirm)
							{
								resetAllOpts();
								setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
							}
							break;
						}
					}//end
					//printf("State: %d\nMainOpt: %d\nSubOpt: %d\nScroll: %d\n\n", state, mainOption, subOption, scroll);
					Screen->Rectangle(MENU_LAYER, 0, TOP_MENU, 256, VIS_SCREEN_HEIGHT, BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
					//start tab calcs
					int destx = getTabPos(<Tab>tab);
					//Calculate left/right distances
					if(destx != x)
					{
						int cmp = comp(destx, x);
						int ldist, rdist;
						for(int lx = x; lx != destx; --lx)
						{
							if(lx < MENU_START_TABS_X) lx += TABS_WIDTH;
							++ldist;
						}
						for(int rx = x; rx != destx; ++rx)
						{
							if(rx >= TABS_WIDTH + MENU_START_TABS_X - 1) rx -= TABS_WIDTH;
							++rdist;
						}
						x += ldist < rdist ? -(MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (rdist < ldist ? (MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (lastLR == DIR_LEFT ? -(MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]))); //Choose the closer direction
						if(cmp != comp(destx, x)) x = destx; //Prevent passing it if scroll speed is odd
						else if(x < MENU_START_TABS_X) x += TABS_WIDTH; //Wrap
						else if(x >= MENU_START_TABS_X + TABS_WIDTH) x -= TABS_WIDTH; //Wrap
					}
					//end
					
					int yoffs = (ScreenFlag(SF_VIEW,SFV_NOSUBSCREEN)) ? (TOP_MENU < 0 ? -TOP_MENU : 0) : 0;
					
					if(Input->Button[CB_START])
						menu->Blit(MENU_LAYER, RT_SCREEN, MENU_CONTROL_X, MENU_CONTROL_Y, 256, VIS_SCREEN_HEIGHT - yoffs, 0, TOP_MENU + yoffs, 256, VIS_SCREEN_HEIGHT - yoffs, 0, 0, 0, 0, 0, true);
					else
					{
						menu->Blit(MENU_LAYER, RT_SCREEN, x, scroll + MENU_PERM_Y, 256, VIS_SCREEN_HEIGHT - yoffs, 0, TOP_MENU + yoffs, 256, VIS_SCREEN_HEIGHT - yoffs, 0, 0, 0, 0, 0, true);
						menu->Blit(MENU_LAYER, RT_SCREEN, x, scroll + MENU_TEMP_Y, 256, VIS_SCREEN_HEIGHT - yoffs, 0, TOP_MENU + yoffs, 256, VIS_SCREEN_HEIGHT - yoffs, 0, 0, 0, 0, 0, true);
						int wid = MENU_BITMAP_WIDTH - x + 1;
						if(wid < 256)
						{
							menu->Blit(MENU_LAYER, RT_SCREEN, MENU_START_TABS_X, scroll + MENU_PERM_Y, 256 - wid, VIS_SCREEN_HEIGHT - yoffs, wid, TOP_MENU + yoffs, 256 - wid, VIS_SCREEN_HEIGHT - yoffs, 0, 0, 0, 0, 0, true);
							menu->Blit(MENU_LAYER, RT_SCREEN, MENU_START_TABS_X, scroll + MENU_TEMP_Y, 256 - wid, VIS_SCREEN_HEIGHT - yoffs, wid, TOP_MENU + yoffs, 256 - wid, VIS_SCREEN_HEIGHT - yoffs, 0, 0, 0, 0, 0, true);
						}
					}
					//menu->Blit(MENU_LAYER, RT_SCREEN, 0, scroll, 256, VIS_SCREEN_HEIGHT, 0, TOP_MENU, 256, VIS_SCREEN_HEIGHT, 0, 0, 0, 0, 0, true);
					if(MENU_ENFORCE_MARGINS)
					{
						Screen->Rectangle(MENU_LAYER, 0,                 TOP_MENU + yoffs,                256,                  MENU_TOP_MARGIN - 1 + yoffs, BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
						Screen->Rectangle(MENU_LAYER, 0,                 TOP_MENU + yoffs,                MENU_LEFT_MARGIN - 1, 176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
						Screen->Rectangle(MENU_LAYER, MENU_RIGHT_MARGIN, TOP_MENU + yoffs,                256,                  176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
						Screen->Rectangle(MENU_LAYER, 0,                 168 - MENU_BOTTOM_MARGIN_HEIGHT, 256,                  176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
					}
					//Tab names
					char buf1[32], buf2[32], buf3[32];
					getTabName(buf1, wrapTab(tab-1));
					getTabName(buf2, wrapTab(tab));
					getTabName(buf3, wrapTab(tab+1));
					Screen->DrawString(MENU_LAYER,  64, MENU_TABLABEL_Y + yoffs, FONT_Z3SMALL, MENU_TCOLOR_TABS, TRANSBG, TF_CENTERED, buf1, OP_OPAQUE);
					Screen->DrawString(MENU_LAYER, 128, MENU_TABLABEL_Y + yoffs, FONT_Z3SMALL, MENU_TCOLOR_TABS, TRANSBG, TF_CENTERED, buf2, OP_OPAQUE);
					Screen->DrawString(MENU_LAYER, 192, MENU_TABLABEL_Y + yoffs, FONT_Z3SMALL, MENU_TCOLOR_TABS, TRANSBG, TF_CENTERED, buf3, OP_OPAQUE);
					//Controls
					DrawStrings(MENU_LAYER, 128, MENU_BOTTOM_MARGIN + FONT_Z3SMALL_HEIGHT, FONT_Z3SMALL, MENU_TCOLOR_CONTROLS, -1, TF_CENTERED, "ENTER/(A): Confirm | BACKSPACE/(B): Back\n(START): Info | (UP)/(DOWN): Switch options\n(LEFT)/(RIGHT): Switch tabs", OP_OPAQUE, 2, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
					//
					if(debugEnabled && PressControl() && Input->ReadKey[KEY_W]) menu->Write(7, "MM2D/MenuBitmap.png", true);
					TotalNoAction();
					Waitframe();
				}
				TotalNoAction();
				reloadOptions();
				Screen_Freeze(FREEZE_NONE);
			}
			else
			{
				if(Input->ReadKey[Controls[CONTROL_OPTIONS]])
				{
					setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, true);
					Screen_Freeze(FREEZE_ACTION);
				}
			}
		}
	}//end

	int menuposy(OptState opt)
	{
		int opthei = opt - tabs[getTab(opt)];
		return MENU_TOP_MARGIN_HEIGHT + ((MENU_SPACING + MENU_FONT_HEIGHT + MENU_FONT_HEIGHT) * opthei);
	}
	
	int tabNumOpts(OptState opt)
	{
		return tabNumOpts(getTab(opt));
	}
	
	int tabNumOpts(Tab tab)
	{
		return tabs[tab+1] - tabs[tab]; 
	}
	
	//Call in OnContinue(), and when exiting options menu.
	void reloadOptions() //start
	{
		//Forcibly ensure that all option settings are in effect
		//
		//Options control should not need reloading
		//
		//Set "Flip Right-Handed Slash" on all swords
		itemdata it = Game->LoadItemData(IT_SWORD_KOKIRI);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_RAZOR);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_GILDED);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_GFAIRY);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_ZORA_BLADE);
		it->Flags[7] = opt[OPT_RFS];
		//
		//Lens tint should not need reloading
		//
		//Tint hide should not need reloading
		//
	}//end
	
	//start Drawing
	void reloadBitmap(bitmap menu) //start
	{
		menu->Rectangle(0, 0, 0, MENU_BITMAP_WIDTH, MENU_BITMAP_HEIGHT, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		int x = MENU_START_TABS_X + MENU_LEFT_MARGIN_WIDTH;
		DEFINE TOP_Y = MENU_TOP_MARGIN_HEIGHT;
		int y = TOP_Y;
		//
		// "Options"
		//
		DrawMenuString("Flip Right-Facing Slash", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		DrawMenuString("Lens Tint Color", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		DrawMenuString("Hide Tint In Menus", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		DrawMenuString("Menu Scroll Speed", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		DrawMenuString("Menu Input Hold Delay", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		//
		// "Controls"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		//
		DrawMenuString("Options Menu", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//{}Module
		//
		// "System"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		//
		//y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//Last slot.
		DrawMenuString("Font", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		DrawMenuString("Reset All to Default", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		///////////////////////
		x = MENU_CONTROL_X + 128;
		y = TOP_Y;
		//
		DrawMenuStrings("Default Lens of Truth:\n-17, -48, 5", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED, 0, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		DrawMenuStrings("When control binding:\nPress any keyboard key to bind it.\nConflicting binds may cause issues.", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED, 0, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		/*
		DrawMenuString(, menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;*/
	}//end
	
	void loadTempBitmap(bitmap menu) //start
	{
		menu->Rectangle(0, MENU_START_TABS_X, MENU_TEMP_Y, MENU_BITMAP_WIDTH, OP_HEIGHT * 2, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		int x = MENU_START_TABS_X + MENU_RIGHT_MARGIN;
		DEFINE TOP_Y = MENU_TEMP_Y + MENU_TOP_MARGIN_HEIGHT + MENU_FONT_HEIGHT; //Font offset to make it one row lower
		int y = TOP_Y;
		//
		// "Options"
		//
		DrawMenuString(opt[OPT_RFS] ? "  On" : "Off", menu, 1, x, y, opt[OPT_RFS] ? DARKGREEN : DARKRED, TF_RIGHT);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		char rbuf[16], gbuf[16], bbuf[16];
		itoa(rbuf, __tintR[getGlobalVar(TINT_LENS, GV_PAL)]);
		itoa(gbuf, __tintG[getGlobalVar(TINT_LENS, GV_PAL)]);
		itoa(bbuf, __tintB[getGlobalVar(TINT_LENS, GV_PAL)]);
		strcat(rbuf, " ");
		strcat(gbuf, " ");
		DEFINE RWID = Text->StringWidth(rbuf, opt[OPT_OPTIONS_FONT]),
			GWID = Text->StringWidth(gbuf, opt[OPT_OPTIONS_FONT]),
			BWID = Text->StringWidth(bbuf, opt[OPT_OPTIONS_FONT]);
		DrawMenuString("Preview ", menu, 1, x - (RWID+GWID+BWID), y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		DrawMenuString(rbuf, menu, 1, x - (GWID+BWID), y, DARKRED, TF_RIGHT);
		DrawMenuString(gbuf, menu, 1, x - (BWID), y, DARKGREEN, TF_RIGHT);
		DrawMenuString(bbuf, menu, 1, x, y, DARKBLUE, TF_RIGHT);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		DrawMenuString(opt[OPT_HIDE_TINT_IN_MENU] ? "  On" : "Off", menu, 2, x, y, opt[OPT_HIDE_TINT_IN_MENU] ? DARKGREEN : DARKRED, TF_RIGHT);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		char buf4[16] = "      x";
		if(opt[OPT_MENU_SCROLL_MULT]<1) strcat(buf4,"0.5");
		else itoa(buf4, 7, opt[OPT_MENU_SCROLL_MULT]);
		DrawMenuString(buf4, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		char buf5[16] = "    ";
		itoa(buf5, 4, opt[OPT_MENU_HOLD_DELAY]);
		DrawMenuString(buf5, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		//
		// "Controls"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		char buf0[64];
		KeyToString(Controls[CONTROL_OPTIONS], buf0, true, true);
		DrawMenuString(buf0, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
		// "System"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		char buf6[32];
		getFontName(buf6, opt[OPT_OPTIONS_FONT]);
		DrawMenuString(buf6, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//Reset default; no temp text
		y += MENU_FONT_HEIGHT + MENU_FONT_HEIGHT + MENU_SPACING;
		//
	}//end
	
	void DrawMenuString(char str, bitmap menu, int layer, int x, int y, int color, int format)
	{
		DrawMenuString(str, menu, layer, x, y, color, format, false);
	}
	
	void DrawMenuString(char str, bitmap menu, int layer, int x, int y, int color, int format, bool transbg)
	{
		menu->DrawString(layer, x, y, opt[OPT_OPTIONS_FONT], color, transbg ? TRANSBG : BLACK, format, str, OP_OPAQUE);
	}
	
	void DrawMenuStrings(char str, bitmap menu, int layer, int x, int y, int color, int format, int verticalSpacing, int MaxWidth)
	{
		DrawMenuStrings(str, menu, layer, x, y, color, format, false, verticalSpacing, MaxWidth);
	}
	
	void DrawMenuStrings(char str, bitmap menu, int layer, int x, int y, int color, int format, bool transbg, int verticalSpacing, int MaxWidth)
	{
		DrawStringsBitmap(menu, layer, x, y, opt[OPT_OPTIONS_FONT], color, transbg ? TRANSBG : BLACK, format, str, OP_OPAQUE, verticalSpacing, MaxWidth);
	}//end
	
	
	enum KeyValidation
	{
		KV_QUIT = -1,
		KV_INVALID,
		KV_VALID
	};
	
	KeyValidation isValidKey(int key)
	{
		switch(key)
		{
			case 0:
			case KEY_ENTER:
			case KEY_ENTER_PAD:
				return KV_INVALID;
			case KEY_BACKSPACE:
			case KEY_ESC:
				return KV_QUIT;
				
			default:
				for(int q = 0; q < 14; ++q)
				{
					if(key==Input->KeyBindings[q]) return (q==CB_B ? KV_QUIT : KV_INVALID);
				}
				return KV_VALID;
		}
	}
	
	//start Tab stuff
	Tab getTab(OptState opt)
	{
		if(opt == STATE_MAIN) return TAB_INVALID;
		int tab = 0;
		for(; tab < TAB_END; ++tab)
		{
			if(opt < tabs[tab+1]) break;
		}
		return <Tab>(tab == TAB_END ? -1 : tab);
	}
	
	int getTabPos(OptState opt)
	{
		return getTabPos(getTab(opt));
	}
	
	int getTabPos(Tab tab)
	{
		if(tab == TAB_INVALID) return -1;
		return MENU_START_TABS_X + (MENU_SCREEN_WIDTH * tab);
	}
	
	void getTabName(char buf, Tab tab)
	{
		switch(tab)
		{
			case TAB_OPT:
				strcat(buf, "Options");
				break;
				
			case TAB_CONTROL:
				strcat(buf, "Controls");
				break;
				
			case TAB_SYSTEM:
				strcat(buf, "System");
				break;
				
			default:
				if(__DEBUG) printf("[MM2D] [Error] Invalid tab %d passed to 'getTabName()'\n", tab);
		}
	}
	
	Tab wrapTab(int tab)
	{
		int t = tab;
		if(t >= TAB_END) t %= TAB_END;
		while(t <= TAB_INVALID) t += TAB_END;
		return <Tab>t;
	}
	//end
	
	void printDraws()
	{
		printf("[MM2D] [Draws] Draws this frame: %d/%d\n", Graphics->NumDraws(), Graphics->MaxDraws());
	}
	
	void resetAllOpts()
	{
		Controls[CONTROL_OPTIONS] = KEY_TAB;
		opt[OPT_RFS] = false;
		__tintR[getGlobalVar(TINT_LENS, GV_PAL)] = -17;
		__tintG[getGlobalVar(TINT_LENS, GV_PAL)] = -48;
		__tintB[getGlobalVar(TINT_LENS, GV_PAL)] = 5;
		opt[OPT_HIDE_TINT_IN_MENU] = true;
		opt[OPT_MENU_SCROLL_MULT] = 1;
		opt[OPT_MENU_HOLD_DELAY] = 30;
		updateOptFont(FONT_Z3SMALL);
	}
}
//end
//start GameOverMenu
namespace GameOverMenu
{
	enum QuitState { NONE = -1, CONTINUE, RESET_TIME, QUIT, CANCEL };
	
	//start Constants
	CONFIG MENU_LAYER = 7;
	CONFIG MENU_FONT = FONT_ACORN;
	CONFIG MENU_FONT_HEIGHT = 10;
	CONFIG MENU_SPACING = 16;
	CONFIG MENU_COLOR_ACTIVE = RED;
	CONFIG MENU_COLOR_INACTIVE = GRAY;
	//
	DEFINE SCREEN_HEIGHT = SCREEN_BOTTOM - SUBSCREEN_TOP;
	DEFINE SCREEN_VCENTER = (SCREEN_HEIGHT / 2) + SUBSCREEN_TOP;
	DEFINE SCREEN_WIDTH = SCREEN_RIGHT - SCREEN_LEFT;
	DEFINE SCREEN_HCENTER = (SCREEN_WIDTH / 2) + SCREEN_LEFT;
	//end
	
	hero script OnDeath
	{
		void run()
		{
			Hero->HP = Hero->MaxHP; //Stop heart beep
			killAllSfx();
			runGameOverMenu(false);
		}
	}

	void checkF6()
	{
		if(Input->ReadKey[KEY_F6])
		{
			FreezeState frz = Get_Freeze();
			Screen_Freeze(FREEZE_ACTION);
			pauseAllSfx();
			setGlobalBool(GVAR_F6_MENU, GV_MISC_BOOL, true);
			QuitState state = runGameOverMenu(true);
			//Bool is reset in `end()`
			resumeAllSfx();
			if(state == CANCEL) Screen_Freeze(frz);
		}
	}

	QuitState runGameOverMenu(bool allowCancel)
	{
		if(opt[OPT_HIDE_TINT_IN_MENU]) hideAllTints(true);
		QuitState state = NONE;
		int cursor = 0;
		DEFINE NUM_OPTIONS = 1 + <int>(allowCancel) + <int>(Hero->Item[IT_OCARINA]) + <int>(day < 4);
		DEFINE START_TEXT = SCREEN_VCENTER - (((NUM_OPTIONS * MENU_FONT_HEIGHT) + ((NUM_OPTIONS - 1) * MENU_SPACING)) / 2);
		int timer;
		while(state==NONE)
		{
			++timer;
			if(Input->Press[CB_DOWN] || (Input->Button[CB_DOWN] && !(timer%opt[OPT_MENU_HOLD_DELAY]))) ++cursor;
			else if(Input->Press[CB_UP] || (Input->Button[CB_UP] && !(timer%opt[OPT_MENU_HOLD_DELAY]))) --cursor;
			if(Input->Press[CB_DOWN] || Input->Press[CB_UP]) timer=0;
			while(cursor<0)cursor+=NUM_OPTIONS;
			cursor %= NUM_OPTIONS;
			Screen->Rectangle(7, SCREEN_LEFT, SUBSCREEN_TOP, SCREEN_RIGHT, SCREEN_BOTTOM, BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
			int opt = 0;
			if(day < 4)
			{
				if(Input->Press[CB_START] && cursor==opt) state = CONTINUE;
				drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, CONTINUE);
			}
			if(Hero->Item[IT_OCARINA])
			{
				if(Input->Press[CB_START] && cursor==opt) state = RESET_TIME;
				drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, RESET_TIME);
			}
			if(Input->Press[CB_START] && cursor==opt) state = QUIT;
			drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, QUIT);
			if(allowCancel)
			{
				if(Input->Press[CB_START] && cursor==opt) state = CANCEL;
				drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, CANCEL);
			}
			NoAction();
			Waitframe();
		}
		end(state);
		return state;
	}
	
	void drawOpt(int x, int y, bool active, QuitState opt) //Default overload
	{
		drawOpt(MENU_LAYER, x, y, MENU_FONT, active ? MENU_COLOR_ACTIVE : MENU_COLOR_INACTIVE, TRANS, TF_CENTERED, opt, OP_OPAQUE);
	}
	void drawOpt(int layer, int x, int y, int font, int color, int bgcolor, int format, QuitState opt, int opacity)
	{
		switch(opt)
		{
			case CONTINUE:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Continue", opacity);
				break;
			case RESET_TIME:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Reset Time", opacity);
				break;
			case QUIT:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Quit", opacity);
				break;
			case CANCEL:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Cancel", opacity);
				break;
		}
	}
	
	void end(QuitState opt)
	{
		setGlobalBool(GVAR_F6_MENU, GV_MISC_BOOL, false);
		switch(opt)
		{
			case CONTINUE:
				Hero->HP = Hero->MaxHP;
				Hero->MP = Clamp(Hero->MP, (Hero->MaxMP / 2), Hero->MaxMP);
				Screen_Freeze(FREEZE_NONE);
				Game->Continue();
				break;
			case RESET_TIME:
				fakeSong = true;
				playSong(SONGNOTES_SongOfTime);
				playedSong = -1;
				while(songFrames)
				{
					Global.handleOcarina();
					playedSong = -1;
					Waitframe();
				}
				Screen_Freeze(FREEZE_NONE);
				saveTheGame();
				resetTime();
				break;
			case QUIT:
				Screen_Freeze(FREEZE_NONE);
				Game->End();
				break;
			case CANCEL: //Do nothing! Just leave!
				Screen_Freeze(FREEZE_NONE);
				break;
		}
	}
}
//end

void testrun() //Function for testing things quickly at the start of the game
{
	//setGlobalVar(GVAR_FAIRY_START + 0, GV_MISCRESETTABLE, 3);
	return;
}//end

namespace Debug //start
{
	void printPoint(int num)
	{
		unless(__DEBUG)return;
		printf("[MM2D] [Debug] Point %d\n", num);
	}
	
	void printPoint(int num, int data)
	{
		unless(__DEBUG)return;
		printf("[MM2D] [Debug] Point %d, data %d\n", num, data);
	}
	
	void print(char str) //start
	{
		unless(__DEBUG) return;
		printf("[MM2D Debug] %s\n",str);
	}
	
	void print(char str, u q)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q);
	}
	
	void print(char str, u q, u q2)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2);
	}
	
	void print(char str, u q, u q2, u q3)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3);
	}
	
	void print(char str, u q, u q2, u q3, u q4)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3,q4);
	}
	
	void print(char str, u q, u q2, u q3, u q4, u q5)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3,q4,q5);
	}
	
	void print(char str, u q, u q2, u q3, u q4, u q5, u q6)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3,q4,q5,q6);
	}//end
}//end


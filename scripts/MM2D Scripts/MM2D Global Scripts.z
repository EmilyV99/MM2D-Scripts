////////////////////////////////////////
//                                    //
//     MM2D Script: Global Scripts    //
//                                    //
////////////////////////////////////////
//start Init Script
global script Init
{
	void run()
	{
		Log::print("Launching TLoZ: Majora's Mask 2D, firstrun Init");
		Rando::seed = SRand(); //Generate random seed
		//Check debug mode
		char saveName[16];
		Game->GetSaveName(saveName);
		debugEnabled=strcmp(saveName,"Link");
		unless(strcmp(saveName,"MM2D"))
		{
			noSave = true;
		}
		//Starting settings
		Game->MCounter[CR_DEKUNUTS] = 20;
		Game->MCounter[CR_MAGICBEANS] = 20;
		Game->MCounter[CR_BANKBAL] = 5000;
		setGlobalVar(GVAR_DIFFICULTY,GV_MISC,1);
		//Make FFC tiles invisible
		CopyTile(TILE_INVIS,19);
		CopyTile(TILE_INVIS,39);
		//Set up tint palettes
		setGlobalVar(TINT_DAY,GV_PAL,createTintPalette(0,0,0));
		setGlobalVar(TINT_SUNSETORANGE,GV_PAL,createTintPalette(-3,-9,-14));
		setGlobalVar(TINT_NIGHT,GV_PAL,createTintPalette(-21,-23,-10));
		setGlobalVar(TINT_LENS,GV_PAL,createTintPalette(-17,-48,5));
		setGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL,true);
		//Default controls
		Controls[CONTROL_OPTIONS] = KEY_TAB;
		//TypeAString.zh setup
		setEnterEndsTyping(true);
		setAllowBackspaceDelete(true);
		setOverflowWraps(false);
	}
}
//end
//start Active Script
global script Global
{
	void run()//start mainGlobal
	{
		//start Global Script Scope Vars
		int subskin = 1;
		int lastskin = -1;
		bool isLensTinted = false;
		bool refreshTime = false;
		bool scrnChanged = false;
		//end
		//Tango_ConvertVariableName("anpc");
		//Tango_ConvertFunctionName("npcend");
		while(true)
		{
			if(!(gameframe%60) || refreshTime)//Refresh time-based events every 60 frames
			{
				int month = GetSystemTime(RTC_MONTH);
				int day = GetSystemTime(RTC_DAYOFMONTH);
				subskin = 1;
				if(month == 12)
				{
					subskin = 2;
					if(day>23&&day<26)subskin = 3;
				}
				refreshTime = false;
			}
			unless(SubscreenHidden())
			{
				if(getGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL))
				{
					if(subskin != lastskin)
					{
						lastskin = subskin;
						reskinSubscreen(subskin);
					}
				}
				else
				{
					subskin = 1;
					if(lastskin!=1)
					{
						lastskin = 1;
						reskinSubscreen(1);
					}
				}
			}
			//clearBitmap(RT_BITMAP0);
			handleTyping();
			if(debugEnabled)testingMenu();
			//start
			if(Hero->HP!=lastHP)
			{
				if(Hero->HP < lastHP)
				{
					onLinkHurt();
				}
				lastHP = Hero->HP;
			}
			layer4Toggle();
			if(subscreen)
			{
				pressA=Input->Press[CB_A];
				Input->Press[CB_A]=false;
				Input->Button[CB_A]=false;
			}
			
			varIntegrity();
			//end
			//start FrameCounters
			if(freezeFrames>0)
			{
				NoAction();
				freezeFrames--;
			}
			++gameframe;
			gameframe%=3600;//end FrameCounters
			//start Time passing
			unless(freezeTime||(isFrozen||(slowTime&&(gameframe%2))||ScreenFlag(SF_MISC,SFM_SCRIPT1)||songFrames))
			{
				++time;
				trueTime += FRAME;
				unless(time%FRAMES_HOUR)
				{
					++hour;
					time=0;
					if(hour>=24)
					{
						hour-=24;
					}
					else if(hour==6)
					{
						++day;
					}
				}
				if(day>3)
				{
					destruction();
				}
				unpauseGradient();
			}
			else
			{
				pauseGradient();
			}
			//end Time Passing
			unless(getGlobalVar(GVAR_MGSTATE,GV_MISC)==MG_SHOOTING)
				runOmniArrows();
			Tango_Update1();
			handleOcarina();
			//start Subscreen
			if((!(getGlobalVar(GVAR_MGSTATE,GV_MISC)||isFrozen)||subscreen)&&Input->Press[CB_START]&&!ScreenFlag(SF_VIEW,SFV_NOSUBSCREEN))
			{
				toggleSubscreen();
			}
			if(subscreen)
			{
				runSubscreen();
			}
			//end Subscreen
			//start
			if(Tango_AnySlotIsActive())
			{
				unless(slotWasDisplayed||subscreen)
				{
					Screen_Freeze(FREEZE_ACTION_BUT_FFC);
					slotWasDisplayed=true;
				}
			}
			else if(slotWasDisplayed)
			{
				Screen_Freeze(FREEZE_NONE);
				slotWasDisplayed=false;
			}
			razorSwordCheck();
			handleTransformations();
			handleEXItems();
			handleMasks();
			//end
			if(subscreen)//start
			{
				NoAction();
			}
			else unless(isFrozen)
			{
				warpfloors();
				varDecrements();
				heightWarp();
				checkFall();
				handleMeltableIce();
				handleFreezableWater();
			}
			checkJump(isFrozen);
			//end
			//start
			LinkActionOld=Hero->Action;
			raftingCheck();
			LinkMovement_Update1();
			unless(isFrozen)
				highLedgeFromWater();
			//end
			bool temp = getGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL);
			runExtraControls();
			if(temp != getGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL))refreshTime = true;
			handleTintPausing();
			HeroDir8 = validateDir(getPressedDir8(), (HeroDir8 & 4) ? HeroDir8 : Hero->Dir);
			Waitdraw();
			if(UsingItem(IT_LENS)&&fullCounter(CR_MAGIC)>2)
			{
				unless(isLensTinted || (getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL)))
				{
					setTint(getGlobalVar(TINT_LENS,GV_PAL),true);
					isLensTinted=true;
				}
			}
			else
			{
				if(isLensTinted)
				{
					setTint(getGlobalVar(TINT_LENS,GV_PAL),false);
					isLensTinted=false;
				}
			}
			timePalette();
			runTints();
			scrnChanged=false;
			if(lastMap!=Game->GetCurMap()||lastScreen!=Game->GetCurScreen())
			{
				scrnChanged=true;
				changedScreens();
				lastScreen = Game->GetCurScreen();
				lastMap = Game->GetCurMap();
			}
			if(lastDMap!=Game->GetCurDMap())
			{
				changedDMap();
				lastDMap = Game->GetCurDMap();
				if(lastLevel!=Game->GetCurLevel())
				{
					changedLevel();
					lastLevel = Game->GetCurLevel();
				}
			}
			unless(subscreen)
			{
				if(scrnChanged)
					layer4check();
				doDrawAndLoops();
			}	
			runHeightBitmap();
			clearBitmap(RT_BITMAP0,6);
			//Waitdraw();
			passiveSubscreen();
			if(!isFrozen||isBottleFrozen)
			{
				EmptyBottleGlobal();
			}
			Tango_Update2();
			if(isFrozen)LinkMovement_SetLinkSpeedBoost(0);
			LinkMovement_Update2();
			Waitframe();
		}
	}//end mainGlobal
	//start destruction
	void destruction()
	{
		unless(!Game->GetCurDMap()&&Game->GetCurScreen()==32)
		{
			if(subscreen)
			{
				toggleSubscreen();
				Waitframe();
			}
			//Hero->Warp(0,32);
			Hero->WarpEx({WT_IWARP,0,32,-1,WARP_A,WARPEFFECT_NONE,SFX_DESTRUCTION,WARPFLAGS_DESTRUCTION});
			Waitframes(2);
			u args[8];
			if(LEARNED_SONGS[SONG_SongOfTime]&&Hero->Item[IT_OCARINA])
			{
				args[0]=3;
			}
			else
			{
				args[0]=4;
			}
			RunFFCScript(FFC_SHOWSTRING, args);
		}
	}
	//end destruction
	void doDrawAndLoops() //start
	{
		DrawLayer3_4();
		drawExtraLayerEffects();
		lwLoop();
		ewLoop();
		itemLoop();
		npcLoop();
	}//end
	//start extra
	void layer4Toggle()
	{
		if(Input->Press[CB_EX4])
		{
			hideLayer4 = !hideLayer4;
			layer4check();
		}
	}
	
	void layer4check()
	{
		Screen->LayerInvisible[3] = true; //Drawn by `DrawLayer3_4()`
		Screen->LayerInvisible[4] = true; //Drawn by `DrawLayer3_4()`
		Screen->LayerOpacity[4] = OP_TRANS;
	}
	
	void drawExtraLayerEffects()
	{
		if(songOfStormsRain)
		{
			Screen->DrawScreen(6,LAYERSMAP1,LAYERSCREEN_RAIN,0,0,0);
		}
		int downdmap = getDownDMap();
		if(downdmap>-1)
		{
			int screen = getDownScreen(false);
			if(screen>-1)
			{
				dmapdata ddmap = Game->LoadDMapData(downdmap);
				drawHeightLayerData(ddmap->Map,screen,false);
			}
		}
		unless(hideLayer4)
		{
			int updmap = getUpDMap();
			if(updmap>-1)
			{
				int screen = getUpScreen(false);
				if(screen>-1)
				{
					dmapdata udmap = Game->LoadDMapData(updmap);
					drawHeightLayerData(udmap->Map,screen,true);
					//printf("map,screen: %d,%d\n",udmap->Map,screen);
				}
			}
		}
	}
	
	void drawHeightLayerData(int map, int screen, bool upper)
	{
		mapdata m = Game->LoadMapData(map,screen);
		unless(m->State[ST_ITEM])
		{
			if(m->HasItem)
			{
				unless(Game->LoadItemData(m->Item)->Type == IC_STRAYFAIRY)
					HeightFastTile(upper,upper?2:3,m->ItemX,m->ItemY,loadItemTile(m->Item),loadItemTile(m->Item),OP_TRANS);
			}
		}
		for(int i = MIN_FFC; i < MAX_NONRESERVED_FFC; i++)
		{
			int data = m->FFCData[i];
			switch(m->FFCScript[i])
			{
				case FFC_CHEST:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getChestCombo(data,m->GetFFCInitD(i, 0)),m->FFCCSet[i],OP_OPAQUE);
					break;
				case FFC_OWL:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getOwlCombo(m->GetFFCInitD(i, 0)),m->FFCCSet[i],OP_OPAQUE);
					break;
				case FFC_NPC:
					int cmbo = getNPCCombo(m->FFCData[i], m->GetFFCInitD(i, 0)+0, m->GetFFCInitD(i, 1)+0, m->GetFFCInitD(i, 2)+0, m->GetFFCInitD(i, 3)+0, m->GetFFCInitD(i, 4)+0, m->GetFFCInitD(i, 5)+0, (m->GetFFCInitD(i, 7))>0);
					if(m->FFCTileWidth[i] > 1 || m->FFCTileHeight[i] > 1)
					{
						combodata cmbod = Game->LoadComboData(cmbo);
						for(int x = 0; x < m->FFCTileWidth[i]; ++x)
						{
							for(int y = 0; y < m->FFCTileHeight[i]; ++y)
							{
								HeightFastTile(upper,upper?2:3,m->FFCX[i] + (16*x),m->FFCY[i] + (16*y),cmbod->Tile + (x) + (20*y) + (gameframe % Max(cmbod->Frames,1)),m->FFCCSet[i],OP_OPAQUE);
							}
						}
					}
					else
					{
						HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],cmbo,m->FFCCSet[i],OP_OPAQUE);
					}
					break;
				case FFC_SOFTSOIL:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getSoilCombo(m->GetFFCInitD(i,4)),m->FFCCSet[i],OP_OPAQUE);
					break;
				case FFC_TORCH:
					HeightFastCombo(upper,upper?2:3,m->FFCX[i],m->FFCY[i],getTorchCombo(m->GetFFCInitD(i,0),m->GetFFCInitD(i,2),m->GetFFCInitD(i,3),m->GetFFCInitD(i,5)),m->FFCCSet[i],OP_OPAQUE);
					break;
				case FFC_BALLOON:
					if(getGlobalBool(m->GetFFCInitD(i,0),GV_ONETIME_TARGETS_RESETTABLE)) break;
					//fall-through
				default:
					if(data==0)break;
					if(data==COMBO_INVIS)break;
					combodata cdata = Game->LoadComboData(data);
					int tile = cdata->Tile;
					int ffwidth = m->FFCTileWidth[i];
					int ffheight = m->FFCTileHeight[i];
					for(int width = 0; width < ffwidth; width++)
					{
						for(int height = 0; height < ffheight; height++)
						{
							HeightFastTile(upper,upper?2:3,m->FFCX[i]+(width*16),m->FFCY[i]+(height*16),tile+(width)+(height*20),m->FFCCSet[i],Cond((m->FFCFlags[i] & FFCBF_TRANS)>0,OP_TRANS,OP_OPAQUE));
						}
					}
			}
		}
	}
	
	void changedScreens()
	{
		songOfStormsRain = false;
		unless(floating)Hero->Invisible=false;
		setGlobalVar(GVAR_MGSTATE,GV_MISC,MG_NONE);
		Hero->BigHitbox = false;
		Items::updateItemMapdata();
		mapdata cur = CurMapdata();
		if(getGlobalBool(GVAR_DID_HEIGHTWARP, GV_MISC_BOOL))
		{
			setGlobalBool(GVAR_DID_HEIGHTWARP, GV_MISC_BOOL, false);
			cur->Pattern = PATTERN_NO_SPAWNING;
		}
		else
		{
			mapdata map = getBottomMapdata();
			for(int q = 0; q < MAX_MAPDATA_HEIGHT; ++q)
			{
				if(!heightData[q]) break;
				heightData[q]->Pattern = heightPattern[q];
				heightData[q]->HasItem = hasItemData[q];
			}
			for(int q = 0; q < MAX_MAPDATA_HEIGHT; ++q)
			{
				heightData[q] = map;
				heightPattern[q] = <EnemyPattern>(map->Pattern);
				hasItemData[q] = map->HasItem;
				if(map->HasItem && Game->LoadItemData(map->Item)->Type == IC_STRAYFAIRY && !map->State[ST_ITEM])
				{
					map->HasItem = 0;
					if(map!=cur)
					{
						item fairy = CreateItemAt(map->Item, map->ItemX, map->ItemY);
						fairy->Misc[ITEMMISC_LAYERDMAP] = Game->GetCurDMap() + 1 + getRelativeHeight(map);
						fairy->Misc[FAIRYMISC_TYPE] = FAIRY_MAPDATA;
						fairy->Misc[FAIRYMISC_VALUE] = map;
					}
				}
				map = upMapdata(map);
			}
			cur->Pattern = PATTERN_NO_SPAWNING;
			HoldingObject = HOLD_NONE;
		}
	}
	
	void changedLevel()
	{
		for(int i = 4 * MAX_LEVEL - 1; i >= 0; i--)
		{
			torchPuzzle[i]=0;
		}
		torchPuzzleTimer=0;
		for(int soilindex = 0; soilindex < 10; soilindex++)
		{
			setSoilState(soilindex,SSSTATE_WAITING); //Reset soft soil to default state
		}
	}
	
	void changedDMap()
	{
		
	}
	
	void onLinkHurt()
	{
		arrowAimMode=false;
	}
	
	void varDecrements()
	{
		if(usingBugs>0)usingBugs--;
		if(beanCounter>0)beanCounter--;
		if(torchPuzzleTimer>0)
		{
			torchPuzzleTimer--;
			if(torchPuzzleTimer==0)
			{
				for(int i = 4 * MAX_LEVEL - 1; i >= 0; i--)
				{
					torchPuzzle[i]=0;
				}
			}
		}
		if(dekuStickLitTimer>0)dekuStickLitTimer--;
	}
	
	void varIntegrity()
	{
		if(floating<0)floating=0;
		if(Deku_flying<0)Deku_flying=0;
		if(Game->MCounter[CR_SBOMBS]>1)Game->MCounter[CR_SBOMBS]=1;//PATCHWORK//
		if(rafting&&Hero->Action!=LA_RAFTING)
		{
			canFall=true;
			rafting=false;
		}
		else if(!rafting&&Hero->Action==LA_RAFTING)
		{
			canFall=false;
			rafting=true;
		}
		if(getGlobalBool(GVAR_PICTURE_MODE,GV_MISC_BOOL)||debugCanFall)canFall=false;
	}//end
	void raftingCheck()//start rafting
	{
		if(Hero->Action==LA_RAFTING)
		{
			Rafting[RAFT_DIR]=-1;
			if(Input->Press[CB_RIGHT]&&CanWalk(Hero->X,Hero->Y,DIR_RIGHT,16,false))
			{
				Hero->X+=16;
				Hero->Action=LA_NONE;
			}
			else if(Input->Press[CB_LEFT]&&CanWalk(Hero->X,Hero->Y,DIR_LEFT,16,false))
			{
				Hero->X-=16;
				Hero->Action=LA_NONE;
			}
			else if(Input->Press[CB_UP]&&CanWalk(Hero->X,Hero->Y,DIR_UP,16,false))
			{
				Hero->Y-=16;
				Hero->Action=LA_NONE;
			}
			else if(Input->Press[CB_DOWN]&&CanWalk(Hero->X,Hero->Y,DIR_DOWN,16,false))
			{
				Hero->Y+=16;
				Hero->Action=LA_NONE;
			}
		}
		else if(Rafting[RAFT_DIR]!=-1)
		{
			NoAction();
			if(Rafting[RAFT_UP]>0)
			{
				warpUps(Rafting[RAFT_UP]);
				Rafting[RAFT_UP]=-1;
				u args[8] = {Rafting[RAFT_DIR],0,0,SSSTATE_GROWN};
				Rafting[RAFT_DIR] = -1;
				Waitframe();
				RunFFCScript(FFC_SOFTSOIL,args);
			}
			else
			{
				//
				Hero->Dir=Rafting[RAFT_DIR];
				if(Rafting[RAFT_X]!=-1&&Rafting[RAFT_Y]!=-1&&!(gameframe%8))
				{
					Hero->X = Rafting[RAFT_X];
					Hero->Y = Rafting[RAFT_Y];
				}
				Hero->Action = LA_RAFTING;
				if(Rafting[RAFT_DIR]==DIR_DOWN)
				{
					Input->Press[CB_DOWN]=true;
					Input->Button[CB_DOWN]=true;
				}
				else if(Rafting[RAFT_DIR]==DIR_RIGHT)
				{
					Input->Press[CB_RIGHT]=true;
					Input->Button[CB_RIGHT]=true;
				}
				else if(Rafting[RAFT_DIR]==DIR_LEFT)
				{
					Input->Press[CB_LEFT]=true;
					Input->Button[CB_LEFT]=true;
				}
				else if(Rafting[RAFT_DIR]==DIR_UP)
				{
					Input->Press[CB_UP]=true;
					Input->Button[CB_UP]=true;
				}
			}
		}
	}//end rafting
	void warpfloors()//start
	{
		if(warpNumFloors>0)
		{
			warpUps(warpNumFloors);
			warpNumFloors = 0;
		}
		else if(warpNumFloors<0)
		{
			warpDowns(-warpNumFloors);
			warpNumFloors = 0;
		}
	}//end
	void timePalette()//start
	{
		if(hour>=6-MULT_SUNRISE && hour < 6)
		{
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			unless(isActiveGradient())
			{
				runGradient(getGlobalVar(TINT_NIGHT,GV_PAL),getGlobalVar(TINT_DAY,GV_PAL),FRAMES_HOUR*MULT_SUNRISE,true);
			}
		}
		else if(hour>=18-MULT_SUNRISE && hour < 18)
		{
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			if(time == 0 && hour == 18-MULT_SUNRISE)
			{
				runGradient(getGlobalVar(TINT_DAY,GV_PAL),getGlobalVar(TINT_SUNSETORANGE,GV_PAL),FRAMES_HOUR*MULT_SUNRISE/2);
			}
			
			unless(MULT_SUNRISE%2)
			{
				if(time==0 && hour == 18-(MULT_SUNRISE/2))
				{
					runGradient(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),getGlobalVar(TINT_NIGHT,GV_PAL),1 + FRAMES_HOUR*MULT_SUNRISE/2);
				}
			}
			else
			{
				if(time==FRAMES_HOUR/2 && hour == 18-Ceiling(MULT_SUNRISE))
				{
					runGradient(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),getGlobalVar(TINT_NIGHT,GV_PAL),FRAMES_HOUR*MULT_SUNRISE/2);
				}
			}
		}
		else if(hour > 5 && hour < 18-MULT_SUNRISE)
		{
			endGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),true);
			//refreshTint();
		}
		else if(hour > 17 || hour < 6-MULT_SUNRISE)
		{
			endGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),true);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			//refreshTint();
		}
		if(isOverworldScreen())
		{
			unhideGradient();
		}
		else
		{
			hideGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),true);
		}
	}//end
	//start TestingMenu
	void testingMenu()//start
	{
		if(debug || dbdraw)
		{
			drawDebugString(256,6*0,"Time: 00.0000",true);//Display base time, with formatting
			drawDebugInt(256-(4*4)-(2),6*0,trueTime,true);//Display integer time
			drawDebugInt(256,6*0,(trueTime%1)*10000,true);//Display decimal time
			char buf[32] = "NoSav: ";
			itoa(buf, 7, noSave ? 1 : 0);
				drawDebugString(256,6*1,buf,true);
			drawDebugString(256, 6*2, "Stray Fairies:",true);
			for(int q = 0; q < 5; ++q)
				drawDebugInt(256,6*(3+q),getGlobalVar(GVAR_FAIRY_START + q, GV_MISCRESETTABLE),true);
			drawDebugInt(256,6*8,Hero->Action,true);
		}
		unless(isFrozen)
		{
			if(Input->ReadKey[KEY_TILDE])
			{
				debug=!debug;
				Hero->CollDetection=!debug;
				canFall=!debug;
			}
			if(debug)
			{
				drawDebugString(0,0,"DEBUG MODE",false);
				drawDebugString(0,156,"   TDBG: ~ | TIME: UDLR | REF: = | FRZ: ENTER | WARP: NUMS             ",false);
				drawDebugString(0,162," REFRESH: R | DBDRAW: \\ | CANFALL: F | UPDOWN: [] | NOSAV: N-         ",false);
				//Hour manipulation
				if(Input->ReadKey[KEY_UP])
				{
					++hour;
					trueTime+=3600*FRAME;
					if(hour>23)
					{
						hour-=24;
					}
					if(hour==6)
					{
						++day;
						if(day>3)
						{
							day-=3;
							trueTime-=(3600*24*FRAME);
							trueTime-=(3600*24*FRAME);
							trueTime-=(3600*24*FRAME);
						}
					}
				}
				if(Input->ReadKey[KEY_DOWN])
				{
					--hour;
					trueTime-=3600*FRAME;
					if(hour<0)
					{
						hour+=24;
					}
					if(hour==5)
					{
						--day;
						if(day<1)
						{
							day+=3;
							trueTime+=(3600*24*FRAME);
							trueTime+=(3600*24*FRAME);
							trueTime+=(3600*24*FRAME);
						}
					}
				}
				//Day manipulation
				if(Input->ReadKey[KEY_RIGHT])
				{
					++day;
					trueTime+=(3600*24*FRAME);
					if(day>3)
					{
						day-=3;
						trueTime-=(3600*24*FRAME);
						trueTime-=(3600*24*FRAME);
						trueTime-=(3600*24*FRAME);
					}
				}
				if(Input->ReadKey[KEY_LEFT])
				{
					--day;
					trueTime-=(3600*24*FRAME);
					if(day<1)
					{
						day+=3;
						trueTime+=(3600*24*FRAME);
						trueTime+=(3600*24*FRAME);
						trueTime+=(3600*24*FRAME);
					}
				}
				if(Input->ReadKey[KEY_EQUALS])//Refill Ammo
				{
					Game->Counter[CR_BOMBS]=Game->MCounter[CR_BOMBS];
					Game->Counter[CR_RUPEES]=Game->MCounter[CR_RUPEES];
					Game->Counter[CR_ARROWS]=Game->MCounter[CR_ARROWS];
					Game->Counter[CR_SBOMBS]=Game->MCounter[CR_SBOMBS];
					Game->Counter[CR_BOMBCHUS]=Game->MCounter[CR_BOMBCHUS];
					Game->Counter[CR_DEKUNUTS]=Game->MCounter[CR_DEKUNUTS];
					Game->Counter[CR_MAGICBEANS]=Game->MCounter[CR_MAGICBEANS];
					Game->Counter[CR_MAGIC]=Game->MCounter[CR_MAGIC];
					Game->DCounter[CR_BOMBS]=0;
					Game->DCounter[CR_RUPEES]=0;
					Game->DCounter[CR_ARROWS]=0;
					Game->DCounter[CR_SBOMBS]=0;
					Game->DCounter[CR_BOMBCHUS]=0;
					Game->DCounter[CR_DEKUNUTS]=0;
					Game->DCounter[CR_MAGICBEANS]=0;
					Game->DCounter[CR_MAGIC]=0;
				}
				if(Input->ReadKey[KEY_ENTER])//Freeze time
				{
					freezeTime=!freezeTime;
					slowTime=freezeTime;
				}
				if(Input->ReadKey[KEY_MINUS_PAD])
				{
					noSave = !noSave;
				}
				if(Input->ReadKey[KEY_0])Hero->Warp(0,0x24);//Warp to test area
				if(Input->ReadKey[KEY_9])Hero->Warp(6,0x43);//Warp to Bomber's Hideout
				if(Input->ReadKey[KEY_R])Hero->PitWarp(Game->GetCurDMap(),Game->GetCurDMapScreen());//Reset the screen by pitwarping to it
				if(Input->ReadKey[KEY_BACKSLASH])dbdraw = !dbdraw;
				if(Input->ReadKey[KEY_F])debugCanFall = !debugCanFall;
				if(Input->ReadKey[KEY_OPENBRACE])warpDown();
				if(Input->ReadKey[KEY_CLOSEBRACE])warpUp();
				if(Input->ReadKey[KEY_Y])
				{
					Hero->Action = LA_RAFTING;
					debug = false;
				}
				TotalNoAction();
			}
		}
	}//end
	
	void debugSetup()//start
	{
		dbsetup=true;
		//dbdraw=true;
		unless(DEMO)noSave=true;
		Game->Cheat=4;
		for(int i = 0;i<22;++i)
		{
			LEARNED_SONGS[i]=true;
		}
		for(int i=0;i<48;++i)
		{
			if(ItemIDs[i])Hero->Item[ItemIDs[i]]=true;
		}
		//bbags
		Hero->Item[IT_BOMBBAG]=true;
		Hero->Item[IT_BOMBBAG_BIG]=true;
		Hero->Item[IT_BOMBBAG_BIGGEST]=true;
		Hero->Item[IT_BOMBBAG_POWDERKEG]=true;
		//quivs
		Hero->Item[IT_QUIVER]=true;
		Hero->Item[IT_QUIVER_BIG]=true;
		Hero->Item[IT_QUIVER_BIGGEST]=true;
		//Misc
		Hero->Item[IT_DEKU_BUBBLE] = true;
		//Counters
		Game->MCounter[CR_LIFE]=320;
		Game->MCounter[CR_MAGIC]=256;
		Game->Counter[CR_LIFE]=320;
		Game->Counter[CR_MAGIC]=256;
		Game->MCounter[CR_BOMBCHUS]=40;
		Game->MCounter[CR_ARROWS]=50;
		Game->MCounter[CR_BOMBS]=40;
		Game->MCounter[CR_SBOMBS]=1;
		//extra
		form=FORM_HUMAN;
		Hero->Item[FORMITEM_DEKU] = false;
		unless(DEMO)
		{
			mask=MASK_BUNNY;
			currMaskTile=maskTile(MASK_BUNNY);
			HMS_Cutscene.HMS_visible=true;
			HMS_Cutscene.CS1_seen=true;
			setGlobalBool(GVAR_TATL_CUTSCENE_1,GV_MISC_BOOL,true);
		}
		else
		{
			mask = MASK_NONE;
			currMaskTile = maskTile(MASK_NONE);
		}
	}//end
	
	void drawDebugInfo(int itID)//start
	{
		if(itID!=0)
		{
			char str[256];
			itemdata theItem = Game->LoadItemData(itID);
			theItem->GetName(str);
			drawDebugString(256,0,str,true);
		}
		if(itID>=146&&itID<=151)//BottleDebugger
		{
			char str[256];
			int bstate = getBottleState(itID-145);
			getBottleStateName(bstate,str);
			drawDebugString(256,8,str,true);
			if(bstate==BS_HOTWATER)drawDebugInt(240,16,springTimers[itID-146]);
		}
	}//end
	
	//start dbDrawFuncs
	void drawDebugString(int x, int y, char str,bool right)
	{
		int format = TF_NORMAL;
		if(right)format = TF_RIGHT;
		Screen->DrawString(7,x,y,FONT_Z3SMALL,0x01,0x00,format,str,OP_OPAQUE);
	}
	
	void drawDebugInt(int x, int y, int num, bool right)
	{
		if(right)x-=Cond(num<0,4,0) + Cond(num<10 && num > -10,4,Cond(num<100&&num>-100,8,Cond(num<1000&&num>-1000,12,16)));
		Screen->DrawInteger(7,x,y,FONT_Z3SMALL,0x01,0x00,0,0,num,0,OP_OPAQUE);
	}
	
	void drawDebugInt(int x, int y, int num)
	{
		drawDebugInt(x,y,num,false);
	}//end
	//end TestingMenu
	//start loops
	void lwLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumLWeapons(); i > 0; --i)
		{
			lweapon weap = Screen->LoadLWeapon(i);
			unless(weap->Misc[LWMISC_LAYERDMAP]) weap->Misc[LWMISC_LAYERDMAP] = THISDMAP + 1;
			switch(weap->ID)
			{
				case LW_ARROW:
					weap->ScriptTile = TILE_INVIS;
					if((weap->Misc[LWMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightAngularTile(4,weap->X+8,weap->Y+8,weap->OriginalTile + 1,weap->TileWidth,weap->TileHeight,weap->CSet,-1,-1,weap->X+8,weap->Y+8,RadtoDeg(weap->Angle),0,true,OP_OPAQUE);
					}
					else if((weap->Misc[LWMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightAngularTile(3,weap->X+8,weap->Y+8,weap->OriginalTile + 1,weap->TileWidth,weap->TileHeight,weap->CSet,-1,-1,weap->X+8,weap->Y+8,RadtoDeg(weap->Angle),0,true,OP_OPAQUE);
					}
					else
					{
						MooshDrawTile(6,weap->X+8,weap->Y+8,weap->OriginalTile + 1,1,1,weap->CSet,16,16,weap->X+8,weap->Y+8,RadtoDeg(weap->Angle),0,true,OP_OPAQUE);
					}
					break;
					
				default:
					if((weap->Misc[LWMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->OriginalTile + weap->Frame,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else if((weap->Misc[LWMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->OriginalTile + weap->Frame,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else weap->ScriptTile = -1;
			}
			weap->HitXOffset = 300 * ((weap->Misc[LWMISC_LAYERDMAP]-1)-THISDMAP) + weap->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	
	void ewLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumEWeapons(); i > 0; --i)
		{
			eweapon weap = Screen->LoadEWeapon(i);
			unless(weap->Misc[EWMISC_LAYERDMAP]) weap->Misc[EWMISC_LAYERDMAP] = THISDMAP + 1;
			switch(weap->ID)
			{
				default:
					if((weap->Misc[EWMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->Tile,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else if((weap->Misc[EWMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,weap->X+weap->DrawXOffset,weap->Y+weap->DrawYOffset,weap->Tile,weap->CSet,OP_OPAQUE);
						weap->ScriptTile = TILE_INVIS;
					}
					else weap->ScriptTile = -1;
			}
			weap->HitXOffset = 300 * ((weap->Misc[LWMISC_LAYERDMAP]-1)-THISDMAP) + weap->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	
	void itemLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumItems(); i > 0; --i)
		{
			item it = Screen->LoadItem(i);
			unless(it->Misc[ITEMMISC_LAYERDMAP]) it->Misc[ITEMMISC_LAYERDMAP] = THISDMAP + 1;
			switch(it->ID)
			{
				default:
					if((it->Misc[ITEMMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,it->X+it->DrawXOffset,it->Y+it->DrawYOffset,it->Tile,it->CSet,OP_OPAQUE);
						it->ScriptTile = TILE_INVIS;
					}
					else if((it->Misc[ITEMMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,it->X+it->DrawXOffset,it->Y+it->DrawYOffset,it->Tile,it->CSet,OP_OPAQUE);
						it->ScriptTile = TILE_INVIS;
					}
					else it->ScriptTile = -1;
			}
			it->HitXOffset = (300 * ((it->Misc[ITEMMISC_LAYERDMAP]-1)-THISDMAP)) + ITEMHITXOFFSET + it->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	
	void npcLoop()
	{
		DEFINE THISDMAP = Game->GetCurDMap();
		for(int i = Screen->NumNPCs(); i > 0; --i)
		{
			npc n = Screen->LoadNPC(i);
			unless(n->Misc[NPCMISC_LAYERDMAP]) n->Misc[NPCMISC_LAYERDMAP] = THISDMAP + 1;
			switch(n->ID)
			{
				default:
					if((n->Misc[NPCMISC_LAYERDMAP]-1)>THISDMAP)
					{
						HeightFastTile(true,4,n->X,n->Y,n->Tile,n->CSet,OP_OPAQUE);
						n->ScriptTile = TILE_INVIS;
					}
					else if((n->Misc[NPCMISC_LAYERDMAP]-1)<THISDMAP)
					{
						HeightFastTile(false,3,n->X,n->Y,n->Tile,n->CSet,OP_OPAQUE);
						n->ScriptTile = TILE_INVIS;
					}
					else n->ScriptTile = -1;
			}
			n->HitXOffset = (300 * ((n->Misc[NPCMISC_LAYERDMAP]-1)-THISDMAP)) + n->Misc[SPRITE_MISC_HITXOFFSET];
		}
	}
	//end loops
	void runExtraControls()//start extraControls
	{
		if(PressControl() && (Input->ReadKey[KEY_1] || Input->ReadKey[KEY_1_PAD]))
		{
			unless(toggleGlobalBool(GVAR_B_SPECTHEME_ACTIVE,GV_MISC_BOOL))reskinSubscreen(1);
		}
	}//end
	void handleOcarina()//start
	{
		if(songFrames>0)
		{
			Game->FFRules[qr_NOFASTMODE] = true;
			TotalNoAction();
			ocarina_mode = false;
			unless(fakeSong)
				drawNotes();
			--songFrames;
			if(songFrames==1) Screen_Freeze(FREEZE_ACTION_BUT_FFC);
			unless(songFrames)
			{
				Game->FFRules[qr_NOFASTMODE] = false;
				if(midiToReturn!=-6&&midiToReturn<205)
					Audio->PlayMIDI(midiToReturn);
				unless(fakeSong||playedSong<0)
					activateSong(playedSong);
				playedSong=-1;
				fakeSong=false;
				unless(subscreen)
					Screen_Freeze(FREEZE_NONE);
			}
		}
		else
		{
			midiToReturn = Game->GetMIDI();
		}
		if(OC_doItemJinx)
		{
			if(Input->Button[CB_B])
			{
				Hero->ItemJinx=2;
			}
			else
			{
				OC_doItemJinx=false;
			}
		}
		if(ocarina_mode)
		{
			Screen_Freeze(FREEZE_ACTION);
			ocarina();
			Input->Press[CB_START]=false;
			Input->Button[CB_START]=false;
		}
		if(scarecrowRecord)
		{
			scarecrow();
		}
		if(ocarina_mode||scarecrowRecord||songFrames>0)
		{
			Hero->CollDetection = false;
		}
		else
		{
			Hero->CollDetection = true;
		}
	}
}//end
	void handleTintPausing()//start
	{
		if(opt[OPT_HIDE_TINT_IN_MENU]) hideAllTints(subscreen || getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL));
		else hideAllTints(false);
	}//end
//end Global Script
//start OnSaveLoad Script
global script onFileLoad
{
	void run()
	{
		Log::print("Launching TLoZ: Majora's Mask 2D, loading from save...");
		if(daysAgo() >= DAYS_TO_HINT_RESET)
		{
			resetHintBools();
			storeTime();
		}
		if(owlSaved)
		{
			owlSaved=false;
			Game->Save();
		}
		else
		{
			resetTime();
			Game->ContinueDMap=0;
			Game->ContinueScreen=0;
			Game->Save();
		}
		tintOnContinue();
		OptionsMenu.reloadOptions();
	}
}//end
//start OnExit Script
global script onExit
{
	void run()
	{
		storeTime();
	}
}
//end OnExit Script
//start OnLaunch Script
global script OnLaunch
{
	void run()
	{
		Debug::print("Starting ONLAUNCH");
		gameframe = -1;
		Game->DisableActiveSubscreen = true; //Disable engine subscreen.
		refreshDisable();
		testrun();
		Game->FFRules[qr_NOFASTMODE] = true;
		RunTitleScreen();
		Game->FFRules[qr_NOFASTMODE] = false;
		OptionsMenu.init();
		initGame(); //Handle rando stuff here.
		Audio->PlayMIDI(0);
		arrowAimMode = false;
		Game->MCounter[CR_BOMBCHUS]=Hero->Item[IT_BOMBBAG]?40:0;
		LinkMovement_Init();
		TangoInit();
		HeroDir8 = validateDir(getPressedDir8(), Hero->Dir);
		reloadDoubleDef(); //Set defense based on Fierce Deity + Double Def reward
		//start Ocarina init
		scarecrowMode = false;
		scarecrowRecord = false;
		ocIndex = 0;
		playedSong = -1;
		songFrames = 0;
		midiToReturn = 0;
		//end Ocarina init
		subscreen = false;
		clearBitmap(RT_BITMAP0);
		setGlobalBool(GVAR_PICTURE_MODE,GV_MISC_BOOL,false);
		Screen_Freeze(FREEZE_FORCE_NONE);
		loadStoragePath();
		if(debugEnabled)Global.debugSetup();
		passiveSubscreen();
		Log::print("Finished init");
	}
	
	void RunTitleScreen()
	{
		bitmap ts = Game->CreateBitmap(256,224);
		ts->DrawScreen(0, 1, 0x00, 0, 24, 0);
		int waitCount = -640;
		int frameCount = -160;
		DEFINE FRAMES_START_VISIBLE = 32;
		Audio->PlayMIDI(MIDI_TITLE);
		while(true)
		{
			ts->Blit(7, RT_SCREEN, 0, 0, 256, 224, 0, -56, 256, 224, 0, 0, 0, 0, 0, false);
			Graphics->ClearTint();
			if(waitCount<0)
			{
				DEFINE T = Div(waitCount,10);
				++waitCount;
				Graphics->Tint(T,T,T);
			}
			else
				++frameCount;
			if(frameCount > 0)
			{
				if(frameCount & FRAMES_START_VISIBLE)
					Screen->DrawString(7,128,128-24, FONT_GBORACLEP, 0x01, 0x0F, TF_CENTERED, "Press Start", OP_OPAQUE);
				frameCount%(FRAMES_START_VISIBLE<<1);
				if(Input->Press[CB_START]) break;
			}
			if(getGlobalBool(GVAR_GAMEINITIALIZED,GV_MISC_BOOL) && Input->Press[CB_START]) break;
			Waitframe();
		}
	}
}

void refreshDisable()
{
	Input->DisableButton[CB_L] = true;
	Input->DisableButton[CB_R] = true;
	Input->DisableButton[CB_MAP] = true;
	Input->DisableButton[CB_START] = true;
	for(int q = 0; q < 127; ++q)
	{
		switch(q)
		{
			//Always disable
			case KEY_ENTER: //OptionsMenu
			case KEY_ENTER_PAD: //OptionsMenu
			case KEY_BACKSPACE: //OptionsMenu
				Input->DisableKey[q] = true;
				continue;
			//Only disable if debug mode
			case KEY_TILDE:
				Input->DisableKey[q] = debugEnabled;
				continue;
			default:
				Input->DisableKey[q] = false;
		}
	}
	Input->DisableKey[Controls[CONTROL_OPTIONS]] = true;
}
//end
//start OnContGame Script
global script OnContGame
{
	void run()
	{
		Hero->HP = Hero->MaxHP; //Refill life
		Hero->MP = Clamp(Hero->MP, (Hero->MaxMP/2), Hero->MaxMP); //Restore up to 50% magic
	}
}//end
//start Game Init
void initGame()
{
	if(getGlobalBool(GVAR_GAMEINITIALIZED,GV_MISC_BOOL)) return; //Already initialized!
	//Do initialization things, which may take into account randomizer stuff.
	OptionsMenu.runGameSetupMenu(); //Game setup menu!
	Items::initUpgrade();
	if(Rando::getFlag(Rando::FLAG_ACTIVE))
	{
		Rando::randoItemInit();
	}
	else
	{
		Items::defaultItemInit();
	}
	Items::updateItemMapdata();
	setGlobalBool(GVAR_GAMEINITIALIZED,GV_MISC_BOOL,true);
}
//end Game Init
//start Options Menu
untyped opt[256] = {false, true, 1, 30, OptionsMenu.MENU_FONT_DEFAULT, false, false};
enum
{
	OPT_RFS,
	OPT_HIDE_TINT_IN_MENU,
	OPT_MENU_SCROLL_MULT,
	OPT_MENU_HOLD_DELAY,
	OPT_OPTIONS_FONT,
	OPT_INFDUR_RAZSWORD,
	OPT_SKIPBEAVER
};

hero script OptionsMenu
{
	using namespace Rando;
	//States are equivalent to the mainOption value that represents that state
	enum OptMenuState
	{
		OPTMENUSTATE_MAIN = -1,
		OPTMENUSTATE_RFS, //Right-Facing Slast
		OPTMENUSTATE_LT, //Lens Tint
		OPTMENUSTATE_TINTHIDE, //Hide Tint in Menus
		OPTMENUSTATE_MENU_SCROLL_SPEED, //as on tin
		OPTMENUSTATE_MENU_HOLD_DELAY, //as on tin
		OPTMENUSTATE_OPTIONSKEY, //Control setting
		OPTMENUSTATE_OPT_MENU_FONT, //as on tin
		OPTMENUSTATE_RESET_DEFAULT, //Reset all opts to default
		OPTMENUSTATE_MENU_MAX
	};
	enum SetupMenuState
	{
		SETUPMENUSTATE_MAIN = -1,
		SETUPMENUSTATE_BEGINGAME,
		SETUPMENUSTATE_OPTIONS, //Open options menu
		SETUPMENUSTATE_INFDUR_RAZORSWORD, //Razor sword doesn't break
		SETUPMENUSTATE_SKIP_BEAVER, //Item for beaver race is given when you walk in
		SETUPMENUSTATE_RANDOMIZE, //Should the game be randomized?
		SETUPMENUSTATE_SEED, //Randomizer seed entry; substates 'random' and 'enter'
		SETUPMENUSTATE_START_SOS, //Start with Song of Soaring`
		//SETUPMENUSTATE_ITEMSONGS, //Randomize songs with items
		SETUPMENUSTATE_MENU_MAX
	};
	
	OptMenuState optmenutabs[] = {OPTMENUSTATE_RFS, OPTMENUSTATE_OPTIONSKEY, OPTMENUSTATE_OPT_MENU_FONT, OPTMENUSTATE_MENU_MAX};
	enum OptMenuTab
	{
		OPTMENUTAB_INVALID = -1,
		OPTMENUTAB_OPT,
		OPTMENUTAB_CONTROL,
		OPTMENUTAB_SYSTEM,
		OPTMENUTAB_END
	};
	SetupMenuState setupmenutabs[] = {SETUPMENUSTATE_BEGINGAME, SETUPMENUSTATE_RANDOMIZE, SETUPMENUSTATE_START_SOS, SETUPMENUSTATE_MENU_MAX};
	enum SetupMenuTab
	{
		SETUPMENUTAB_INVALID = -1,
		SETUPMENUTAB_SETUP, //Main setup stuff `Razor sword does not break`,`Skip Beaver Races`
		SETUPMENUTAB_RANDOMAIN, //Rando mode settings; Keysanity, Boss shuffle, etc; and suboptions that rely on mode
		SETUPMENUTAB_RANDOFLAGS, //Misc rando settings, which don't are about mode; `Songs Randomize With Items`,`Start with Song of Soaring`,etc
		SETUPMENUTAB_END
	};
	
	bitmap optmenu, setupmenu;
	
	//start Menu constants & vars
	CONFIG MENU_SPACING = 16;
	CONFIG MENU_FONT_DEFAULT = FONT_Z3SMALL;
	CONFIG MENU_TAB_MARGIN = 24;
	CONFIG MENU_TOP_MARGIN_HEIGHT = 16 + MENU_TAB_MARGIN;
	CONFIG MENU_LEFT_MARGIN_WIDTH = 16;
	CONFIG MENU_RIGHT_MARGIN_WIDTH = 16;
	CONFIG MENU_BOTTOM_MARGIN_HEIGHT = 32;
	CONFIG MENU_LAYER = 7;
	CONFIG MENU_SCROLL_INC = 8;
	CONFIG MENU_SCROLL_SPEED = 8;
	COLOR MENU_TCOLOR_INACTIVE_PERM = WHITE;
	COLOR MENU_TCOLOR_INACTIVE_TEMP = LIGHTGRAY;
	COLOR MENU_TCOLOR_DEACTIVATED = DARKGRAY;
	COLOR MENU_TCOLOR_ACTIVE = YELLOW;
	COLOR MENU_TCOLOR_CONTROLS = DEEPRED;
	COLOR MENU_TCOLOR_TABS = LIGHTDEEPBLUE;
	//
	CONFIG MENU_ENFORCE_MARGINS = 1;
	//
	DEFINE MENU_SCREEN_WIDTH = 256;
	DEFINE M_NUM_MENU_BITMAPS = OPTMENUTAB_END + 1;
	DEFINE S_NUM_MENU_BITMAPS = SETUPMENUTAB_END + 1;
	DEFINE MENU_LEFT_MARGIN = MENU_LEFT_MARGIN_WIDTH;
	DEFINE MENU_RIGHT_MARGIN = 255 - MENU_RIGHT_MARGIN_WIDTH;
	DEFINE MENU_BOTTOM_MARGIN = 168 - MENU_BOTTOM_MARGIN_HEIGHT;
	
	DEFINE MENU_CONTROL_X = 0;
	DEFINE MENU_CONTROL_Y = 0;
	DEFINE MENU_START_TABS_X = MENU_SCREEN_WIDTH;
	DEFINE MENU_PERM_Y = 0;
	
	DEFINE M_MENU_BITMAP_WIDTH = MENU_SCREEN_WIDTH * M_NUM_MENU_BITMAPS;
	DEFINE S_MENU_BITMAP_WIDTH = MENU_SCREEN_WIDTH * S_NUM_MENU_BITMAPS;
	DEFINE M_TABS_WIDTH = OPTMENUTAB_END * MENU_SCREEN_WIDTH;
	DEFINE S_TABS_WIDTH = SETUPMENUTAB_END * MENU_SCREEN_WIDTH;
	
	DEFINE MENU_CONTROL_LIST = MENU_SCREEN_WIDTH*2;
	int MenuVars[MSV_MAX];
	enum MV
	{
		MSV_MENU_FONT_HEIGHT,
		MV_MAX_OPT_PER_TAB,
		SV_MAX_OPT_PER_TAB,
		MV_MHEIGHT,
		SV_MHEIGHT,
		MV_OPHEIGHT,
		SV_OPHEIGHT,
		MV_TEMPY,
		SV_TEMPY,
		MV_BMPHEIGHT,
		SV_BMPHEIGHT,
		MV_MAXSCROLL,
		SV_MAXSCROLL,
		MSV_TOP_MENU,
		MSV_VIS_SCREEN_HEIGHT,
		MSV_TOP_MARGIN,
		MSV_TABLABEL_Y,
		MSV_MAX
	};
	//end
	void updateSize() //start
	{
		MenuVars[MSV_TOP_MENU] = SubscreenHidden() ? 0 : -56;
		MenuVars[MSV_VIS_SCREEN_HEIGHT] = 168 - MenuVars[MSV_TOP_MENU];
		MenuVars[MSV_TOP_MARGIN] = MenuVars[MSV_TOP_MENU] + MENU_TOP_MARGIN_HEIGHT;
		MenuVars[MSV_TABLABEL_Y] = MenuVars[MSV_TOP_MARGIN] - FONT_Z3SMALL_HEIGHT - MENU_TAB_MARGIN;
	}//end
	void updateOptFont(int font) //start
	{
		updateSize();
		opt[OPT_OPTIONS_FONT] = font;
		MenuVars[MSV_MENU_FONT_HEIGHT] = Text->FontHeight(font);
		MenuVars[MV_MHEIGHT] = (MenuVars[MV_MAX_OPT_PER_TAB] * (MENU_SPACING + MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT])) - MENU_SPACING + MENU_TOP_MARGIN_HEIGHT + MENU_BOTTOM_MARGIN_HEIGHT;
		MenuVars[SV_MHEIGHT] = (MenuVars[SV_MAX_OPT_PER_TAB] * (MENU_SPACING + MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT])) - MENU_SPACING + MENU_TOP_MARGIN_HEIGHT + MENU_BOTTOM_MARGIN_HEIGHT;
		MenuVars[MV_OPHEIGHT] = MenuVars[MV_MHEIGHT] < MenuVars[MSV_VIS_SCREEN_HEIGHT] ? MenuVars[MSV_VIS_SCREEN_HEIGHT] : MenuVars[MV_MHEIGHT];
		MenuVars[SV_OPHEIGHT] = MenuVars[SV_MHEIGHT] < MenuVars[MSV_VIS_SCREEN_HEIGHT] ? MenuVars[MSV_VIS_SCREEN_HEIGHT] : MenuVars[SV_MHEIGHT];
		MenuVars[MV_TEMPY] = MenuVars[MV_OPHEIGHT];
		MenuVars[SV_TEMPY] = MenuVars[SV_OPHEIGHT];
		MenuVars[MV_MAXSCROLL] = MenuVars[MV_OPHEIGHT] - MenuVars[MSV_VIS_SCREEN_HEIGHT];
		MenuVars[SV_MAXSCROLL] = MenuVars[SV_OPHEIGHT] - MenuVars[MSV_VIS_SCREEN_HEIGHT];
		MenuVars[MV_BMPHEIGHT] = MenuVars[MV_OPHEIGHT] * 2;
		MenuVars[SV_BMPHEIGHT] = MenuVars[SV_OPHEIGHT] * 2;
		init_menu_bitmap(true); //Force re-create bitmap for new size
		init_setup_bitmap(true); //Force re-create bitmap for new size
		optmenu->Rectangle(0, 0, 0, M_MENU_BITMAP_WIDTH, MenuVars[MV_BMPHEIGHT], 0x00, 1, 0, 0, 0, true, OP_OPAQUE); //Clear bitmap for 1 frame, for reloading
		reloadMenuBitmap(optmenu);
		//Not needed for setup bitmap as this cannot be called while it is active.
	}//end
	DEFINE MAX_FONT = FONT_LISA;
	DEFINE MIN_FONT = FONT_Z1;
	void incOptFont(int dir) //start
	{
		if(dir==DIR_UP)
		{
			do
			{
				++opt[OPT_OPTIONS_FONT];
				if(opt[OPT_OPTIONS_FONT] > MAX_FONT) opt[OPT_OPTIONS_FONT] = MIN_FONT;
			}
			until(validFont(opt[OPT_OPTIONS_FONT]));
		}
		else if(dir==DIR_DOWN)
		{
			do
			{
				--opt[OPT_OPTIONS_FONT];
				if(opt[OPT_OPTIONS_FONT] < MIN_FONT) opt[OPT_OPTIONS_FONT] = MAX_FONT;
			}
			until(validFont(opt[OPT_OPTIONS_FONT]));
		}
		updateOptFont(opt[OPT_OPTIONS_FONT]);
	} //end
	bool validFont(int font) //start
	{
		switch(font)
		{
			case FONT_ZTIME:
			case FONT_SUBSCREEN1:
			case FONT_SUBSCREEN2:
			case FONT_SUBSCREEN4:
			case FONT_GORON:
			case FONT_ZORAN:
			case FONT_HYLIAN1:
			case FONT_HYLIAN2:
			case FONT_HYLIAN3:
			case FONT_HYLIAN4:
			case FONT_DSPHANTOM:
			case FONT_APPLE2_80COL:
			case FONT_C64_HIRES:
			case FONT_COCO:
			case FONT_FDS_KANA:
			case FONT_FUTHARK:
			case FONT_HIRA:
			case FONT_JP:
			case FONT_SPECTRUM_LG:
				return false;
			default:
				return true;
		}
	} //end
	
	//start scrollcheck
	int optionScrollCheck(OptMenuState option, int scroll)
	{
		option = <OptMenuState>(option - optmenutabs[getTab(option)]);
		int optTop = menuposy(option);
		int optBot = optTop + MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		if(optTop < scroll + (MENU_ENFORCE_MARGINS ? MENU_TOP_MARGIN_HEIGHT : 0)) return -1;
		if(optBot > scroll + MenuVars[MSV_VIS_SCREEN_HEIGHT] - (MENU_ENFORCE_MARGINS ? MENU_BOTTOM_MARGIN_HEIGHT : 0)) return 1;
		return 0;
	}
	
	int optionScrollCheck(SetupMenuState option, int scroll)
	{
		option = <SetupMenuState>(option - setupmenutabs[getTab(option)]);
		int optTop = menuposy(option);
		int optBot = optTop + MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		if(optTop < scroll + (MENU_ENFORCE_MARGINS ? MENU_TOP_MARGIN_HEIGHT : 0)) return -1;
		if(optBot > scroll + MenuVars[MSV_VIS_SCREEN_HEIGHT] - (MENU_ENFORCE_MARGINS ? MENU_BOTTOM_MARGIN_HEIGHT : 0)) return 1;
		return 0;
	}
	//end
	
	//start init stuff
	void init()
	{
		for(int q = 0; q < OPTMENUTAB_END; ++q)
		{
			int numopt = tabNumOpts(<OptMenuTab>q);
			if(numopt > MenuVars[MV_MAX_OPT_PER_TAB]) MenuVars[MV_MAX_OPT_PER_TAB] = numopt;
		}
		for(int q = 0; q < SETUPMENUTAB_END; ++q)
		{
			int numopt = tabNumOpts(<SetupMenuTab>q);
			if(numopt > MenuVars[SV_MAX_OPT_PER_TAB]) MenuVars[SV_MAX_OPT_PER_TAB] = numopt;
		}
		updateSize();
		updateOptFont(opt[OPT_OPTIONS_FONT]);
	}
	
	void init_menu_bitmap()
	{
		init_menu_bitmap(false);
	}
	void init_menu_bitmap(bool force)
	{
		unless(optmenu->isAllocated()) optmenu = Game->CreateBitmap(M_MENU_BITMAP_WIDTH, MenuVars[MV_BMPHEIGHT]);
		else if(force || !optmenu->isValid()) optmenu->Create(0, M_MENU_BITMAP_WIDTH, MenuVars[MV_BMPHEIGHT]);
	}
	
	void init_setup_bitmap()
	{
		init_setup_bitmap(false);
	}
	void init_setup_bitmap(bool force)
	{
		unless(setupmenu->isAllocated()) setupmenu = Game->CreateBitmap(M_MENU_BITMAP_WIDTH, MenuVars[MV_BMPHEIGHT]);
		else if(force || !setupmenu->isValid()) setupmenu->Create(0, M_MENU_BITMAP_WIDTH, MenuVars[MV_BMPHEIGHT]);
	}
	//end
	
	void run() //start
	{
		init_menu_bitmap();
		while(1)
		{
			Waitframe();
			Waitdraw();
			runOptMenu(); //run each frame
		}
	}//end

	void runOptMenu() //start
	{
		if(isFrozen && !getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL)) return;
		
		if(getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL))
		{
			//Full options menu, with various global variables to be modified.
			int scroll = 0;
			int mainOption = 0;
			int subOption = 0;
			int tab = 0;
			int x = getTabPos(<OptMenuTab>tab);
			int lastLR = -1;
			int cooldown = 0;
			int inputTimer = 0;
			OptMenuState state = OPTMENUSTATE_MAIN;
			updateOptFont(opt[OPT_OPTIONS_FONT]);
			hidePassive(true);
			FlashScreen(BLACK, true);
			Audio->AdjustSFXVolume(30);
			WaitTotalNoAction();
			Waitdraw();
			reloadMenuBitmap(optmenu);
			while(getGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL))
			{
				Waitdraw();
				if(cooldown>0)--cooldown;
				++inputTimer;
				inputTimer %= opt[OPT_MENU_HOLD_DELAY];
				loadMenuTempBitmap(optmenu);
				bool confirm = Input->Press[CB_A] || Input->ReadKey[KEY_ENTER] || Input->ReadKey[KEY_ENTER_PAD];
				bool deny = Input->Press[CB_B] || Input->ReadKey[KEY_BACKSPACE];
				const bool up = (Input->Press[CB_UP] || (Input->Button[CB_UP] && !inputTimer));
				const bool down = (Input->Press[CB_DOWN] || (Input->Button[CB_DOWN] && !inputTimer));
				const bool left = (Input->Press[CB_LEFT] || (Input->Button[CB_LEFT] && !inputTimer));
				const bool right = (Input->Press[CB_RIGHT] || (Input->Button[CB_RIGHT] && !inputTimer));
				if(Input->Press[CB_UP]||Input->Press[CB_DOWN]||Input->Press[CB_LEFT]||Input->Press[CB_RIGHT]) inputTimer = 0;
				
				if(confirm||deny||up||down||left||right) Audio->PlaySound(SFX_MENU_BEEP);
				
				if(deny)
				{
					if(state == OPTMENUSTATE_MAIN)
						setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
					else
						state = OPTMENUSTATE_MAIN;
				}
				else if(Input->ReadKey[Controls[CONTROL_OPTIONS]])
				{
					setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
				}
				switch(state) //start
				{
					case OPTMENUSTATE_MAIN: //start
					{
						//Scroll the menu visual based on currently selected option
						unless(mainOption-optmenutabs[getTab(<OptMenuState>mainOption)]) scroll = 0;
						//else if(getTab(<OptMenuState>mainOption)!=getTab(<OptMenuState>(mainOption+1))) scroll = MenuVars[MV_MAXSCROLL];
						else if(optionScrollCheck(<OptMenuState>mainOption, scroll) != 0)
						{
							while(optionScrollCheck(<OptMenuState>mainOption, scroll) == 1)
							{
								scroll += MENU_SCROLL_INC;
							}
							while(optionScrollCheck(<OptMenuState>mainOption, scroll) == -1)
							{
								scroll -= MENU_SCROLL_INC;
							}
							scroll = VBound(scroll, MenuVars[MV_MAXSCROLL], 0);
						}
						switch(mainOption)
						{
							// "Options"
							
							case OPTMENUSTATE_RFS:
								DrawMenuString("Flip Right-Facing Slash", optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
								
							case OPTMENUSTATE_LT:
								DrawMenuString("Lens Tint Color", optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
								
							case OPTMENUSTATE_TINTHIDE:
								DrawMenuString("Hide Tint In Menus", optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
								
							case OPTMENUSTATE_MENU_SCROLL_SPEED:
								DrawMenuString("Menu Scroll Speed", optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
							
							case OPTMENUSTATE_MENU_HOLD_DELAY:
								DrawMenuString("Menu Input Hold Delay", optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
							
							// "Controls"
							
							case OPTMENUSTATE_OPTIONSKEY:
								DrawMenuString("Options Menu", optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
								
							// "System"
							
							case OPTMENUSTATE_OPT_MENU_FONT:
								DrawMenuString("Font", optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
								
							case OPTMENUSTATE_RESET_DEFAULT:
								DrawMenuString("Reset All to Default", optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
						}
						if(confirm)
						{
							state = <OptMenuState>mainOption;
							subOption = 0;
						}
						else if(up)
							--mainOption;
						else if(down)
							++mainOption;
						else unless(cooldown)
						{
							if(left)
							{
								lastLR = DIR_LEFT;
								--tab;
								if(tab < 0) tab += OPTMENUTAB_END;
								mainOption = optmenutabs[tab];
								cooldown = 10;
							}
							else if(right)
							{
								lastLR = DIR_RIGHT;
								++tab;
								tab %= OPTMENUTAB_END;
								mainOption = optmenutabs[tab];
								cooldown = 10;
							}
						}
						//Limit option scrolling to within-tab
						mainOption = wrapOpt(<OptMenuState>mainOption, tab);
						break;
					} //end
					
					case OPTMENUSTATE_OPTIONSKEY: //start
					{
						char buf0[64];
						KeyToString(Controls[CONTROL_OPTIONS], buf0, true, true);
						DrawMenuString(buf0, optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
						if(Input->Button[CB_A]) break; //Don't take input while `A` is held
						int key = getKeyPress();
						switch(isValidKey(key))
						{
							case KV_VALID:
								Controls[CONTROL_OPTIONS] = key;
								refreshDisable(); //Ensure that the new key is disabled in-engine, and the old is not
								//Fall-through
							case KV_QUIT:
								state = OPTMENUSTATE_MAIN;
								Game->TypingMode = false;
								break;
						}
						break;
					}//end
					
					case OPTMENUSTATE_RFS:
					{
						DrawMenuString(opt[OPT_RFS] ? "  On" : "Off", optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], opt[OPT_RFS] ? GREEN : RED, TF_RIGHT);
						if(confirm)
							opt[OPT_RFS] = !opt[OPT_RFS];
						break;
					}
					
					case OPTMENUSTATE_LT: //start
					{
						DEFINE PREVIEW = 0;
						DEFINE _RED = 1;
						DEFINE _GREEN = 2;
						DEFINE _BLUE = 3;
						int inc = (up) ? 1 : (down ? -1 : 0);
						if(right) ++subOption;
						else if(left) --subOption;
						subOption < 0 ? (subOption += 4) : (subOption %= 4);
						char rbuf[16], gbuf[16], bbuf[16];
						itoa(rbuf, __tintR[getGlobalVar(TINT_LENS, GV_PAL)]);
						itoa(gbuf, __tintG[getGlobalVar(TINT_LENS, GV_PAL)]);
						itoa(bbuf, __tintB[getGlobalVar(TINT_LENS, GV_PAL)]);
						strcat(rbuf, " ");
						strcat(gbuf, " ");
						DEFINE RWID = Text->StringWidth(rbuf, opt[OPT_OPTIONS_FONT]),
							GWID = Text->StringWidth(gbuf, opt[OPT_OPTIONS_FONT]),
							BWID = Text->StringWidth(bbuf, opt[OPT_OPTIONS_FONT]);
						switch(subOption)
						{
							case PREVIEW:
								DrawMenuString("Preview ", optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN - (RWID+GWID+BWID), MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
								if(confirm)
								{
									if(gameframe==-1)
									{
										setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
										setTint(getGlobalVar(TINT_LENS, GV_PAL), true);
										runTints();
										while(Input->Button[CB_A] || Input->Key[KEY_ENTER] || Input->Key[KEY_ENTER_PAD])
										{
											FlashScreen(GRAY, true);
											Waitframe();
										}
										setTint(getGlobalVar(TINT_LENS, GV_PAL), false);
										runTints();
										setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, true);
									}
									else
									{
										setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
										setTint(getGlobalVar(TINT_LENS, GV_PAL), true);
										hideAllTints(false);
										while(Input->Button[CB_A] || Input->Key[KEY_ENTER] || Input->Key[KEY_ENTER_PAD])
											Waitframe();
										Waitdraw();
										setTint(getGlobalVar(TINT_LENS, GV_PAL), false);
										setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, true);
									}
								}
								break;
								
							case _RED:
								DrawMenuString(rbuf, optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN - (GWID+BWID), MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], RED, TF_RIGHT);
								__tintR[getGlobalVar(TINT_LENS, GV_PAL)] += inc;
								__tintR[getGlobalVar(TINT_LENS, GV_PAL)] = VBound(__tintR[getGlobalVar(TINT_LENS, GV_PAL)], 63, -63);
								break;
								
							case _GREEN:
								DrawMenuString(gbuf, optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN - (BWID), MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], GREEN, TF_RIGHT);
								__tintG[getGlobalVar(TINT_LENS, GV_PAL)] += inc;
								__tintG[getGlobalVar(TINT_LENS, GV_PAL)] = VBound(__tintG[getGlobalVar(TINT_LENS, GV_PAL)], 63, -63);
								break;
								
							case _BLUE:
								DrawMenuString(bbuf, optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], BLUE, TF_RIGHT);
								__tintB[getGlobalVar(TINT_LENS, GV_PAL)] += inc;
								__tintB[getGlobalVar(TINT_LENS, GV_PAL)] = VBound(__tintB[getGlobalVar(TINT_LENS, GV_PAL)], 63, -63);
								break;
						}
						break;
					}//end
					
					case OPTMENUSTATE_TINTHIDE:
					{
						DrawMenuString(opt[OPT_HIDE_TINT_IN_MENU] ? "  On" : "Off", optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], opt[OPT_HIDE_TINT_IN_MENU] ? GREEN : RED, TF_RIGHT);
						if(confirm)
							opt[OPT_HIDE_TINT_IN_MENU] = !opt[OPT_HIDE_TINT_IN_MENU];
						break;
					}
					
					case OPTMENUSTATE_MENU_SCROLL_SPEED:
					{
						char buf4[16] = "      x";
						if(opt[OPT_MENU_SCROLL_MULT]<1) strcat(buf4,"0.5");
						else itoa(buf4, 7, opt[OPT_MENU_SCROLL_MULT]);
						DrawMenuString(buf4, optmenu, 2, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
						if(up || right) opt[OPT_MENU_SCROLL_MULT] = opt[OPT_MENU_SCROLL_MULT] < 1 ? 1 : opt[OPT_MENU_SCROLL_MULT] << 1;
						else if(down || left) opt[OPT_MENU_SCROLL_MULT] >>= 1;
						opt[OPT_MENU_SCROLL_MULT] = VBound(opt[OPT_MENU_SCROLL_MULT], 8, 0.5);
						break;
					}
					
					case OPTMENUSTATE_MENU_HOLD_DELAY:
					{
						char buf5[16] = "    ";
						itoa(buf5, 4, opt[OPT_MENU_HOLD_DELAY]);
						DrawMenuString(buf5, optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
						if(up) opt[OPT_MENU_HOLD_DELAY] += 10;
						else if(down) opt[OPT_MENU_HOLD_DELAY] -= 10;
						else if(left) --opt[OPT_MENU_HOLD_DELAY];
						else if(right) ++opt[OPT_MENU_HOLD_DELAY];
						opt[OPT_MENU_HOLD_DELAY] = VBound(opt[OPT_MENU_HOLD_DELAY], 90, 2);
						break;
					}
					
					case OPTMENUSTATE_OPT_MENU_FONT:
					{
						char buf[32];
						getFontName(buf, opt[OPT_OPTIONS_FONT]);
						DrawMenuString(buf, optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
						if(down || right) incOptFont(DIR_UP);
						else if(up || left) incOptFont(DIR_DOWN);
						break;
					}
					
					case OPTMENUSTATE_RESET_DEFAULT:
					{
						DrawMenuString("Are you sure?", optmenu, 1, getTabPos(<OptMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[MV_TEMPY] + menuposy(<OptMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
						if(confirm)
						{
							resetAllOpts();
							setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, false);
						}
						break;
					}
				}//end
				//printf("State: %d\nMainOpt: %d\nSubOpt: %d\nScroll: %d\n\n", state, mainOption, subOption, scroll);
				Screen->Rectangle(MENU_LAYER, 0, MenuVars[MSV_TOP_MENU], 256, MenuVars[MSV_VIS_SCREEN_HEIGHT], BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
				//start tab calcs
				int destx = getTabPos(<OptMenuTab>tab);
				//Calculate left/right distances
				if(destx != x)
				{
					int cmp = comp(destx, x);
					int ldist, rdist;
					for(int lx = x; lx != destx; --lx)
					{
						if(lx < MENU_START_TABS_X) lx += M_TABS_WIDTH;
						++ldist;
					}
					for(int rx = x; rx != destx; ++rx)
					{
						if(rx >= M_TABS_WIDTH + MENU_START_TABS_X - 1) rx -= M_TABS_WIDTH;
						++rdist;
					}
					x += ldist < rdist ? -(MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (rdist < ldist ? (MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (lastLR == DIR_LEFT ? -(MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]))); //Choose the closer direction
					if(cmp != comp(destx, x)) x = destx; //Prevent passing it if scroll speed is odd
					else if(x < MENU_START_TABS_X) x += M_TABS_WIDTH; //Wrap
					else if(x >= MENU_START_TABS_X + M_TABS_WIDTH) x -= M_TABS_WIDTH; //Wrap
				}
				//end
				
				int yoffs = (ScreenFlag(SF_VIEW,SFV_NOSUBSCREEN)) ? (MenuVars[MSV_TOP_MENU] < 0 ? -MenuVars[MSV_TOP_MENU] : 0) : 0;
				
				if(Input->Button[CB_START])
					optmenu->Blit(MENU_LAYER, RT_SCREEN, MENU_CONTROL_X, MENU_CONTROL_Y, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, MenuVars[MSV_TOP_MENU] + yoffs, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
				else
				{
					optmenu->Blit(MENU_LAYER, RT_SCREEN, x, scroll + MENU_PERM_Y, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, MenuVars[MSV_TOP_MENU] + yoffs, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
					optmenu->Blit(MENU_LAYER, RT_SCREEN, x, scroll + MenuVars[MV_TEMPY], 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, MenuVars[MSV_TOP_MENU] + yoffs, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
					int wid = M_MENU_BITMAP_WIDTH - x + 1;
					if(wid < 256)
					{
						optmenu->Blit(MENU_LAYER, RT_SCREEN, MENU_START_TABS_X, scroll + MENU_PERM_Y, 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, wid, MenuVars[MSV_TOP_MENU] + yoffs, 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
						optmenu->Blit(MENU_LAYER, RT_SCREEN, MENU_START_TABS_X, scroll + MenuVars[MV_TEMPY], 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, wid, MenuVars[MSV_TOP_MENU] + yoffs, 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
					}
				}
				//optmenu->Blit(MENU_LAYER, RT_SCREEN, 0, scroll, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT], 0, MenuVars[MSV_TOP_MENU], 256, MenuVars[MSV_VIS_SCREEN_HEIGHT], 0, 0, 0, 0, 0, true);
				if(MENU_ENFORCE_MARGINS)
				{
					Screen->Rectangle(MENU_LAYER, 0,                 MenuVars[MSV_TOP_MENU] + yoffs,                256,                  MenuVars[MSV_TOP_MARGIN] - 1 + yoffs, BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
					Screen->Rectangle(MENU_LAYER, 0,                 MenuVars[MSV_TOP_MENU] + yoffs,                MENU_LEFT_MARGIN - 1, 176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
					Screen->Rectangle(MENU_LAYER, MENU_RIGHT_MARGIN, MenuVars[MSV_TOP_MENU] + yoffs,                256,                  176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
					Screen->Rectangle(MENU_LAYER, 0,                 168 - MENU_BOTTOM_MARGIN_HEIGHT, 256,                  176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
				}
				//OptMenuTab names
				char buf1[32], buf2[32], buf3[32];
				getTabName(buf1, wrapOptTab(<OptMenuTab>(tab-1)));
				getTabName(buf2, wrapOptTab(<OptMenuTab>tab));
				getTabName(buf3, wrapOptTab(<OptMenuTab>(tab+1)));
				Screen->DrawString(MENU_LAYER,  64, MenuVars[MSV_TABLABEL_Y] + yoffs, FONT_Z3SMALL, MENU_TCOLOR_TABS, TRANSBG, TF_CENTERED, buf1, OP_OPAQUE);
				Screen->DrawString(MENU_LAYER, 128, MenuVars[MSV_TABLABEL_Y] + yoffs, FONT_Z3SMALL, MENU_TCOLOR_TABS, TRANSBG, TF_CENTERED, buf2, OP_OPAQUE);
				Screen->DrawString(MENU_LAYER, 192, MenuVars[MSV_TABLABEL_Y] + yoffs, FONT_Z3SMALL, MENU_TCOLOR_TABS, TRANSBG, TF_CENTERED, buf3, OP_OPAQUE);
				//Controls
				DrawStrings(MENU_LAYER, 128, MENU_BOTTOM_MARGIN + FONT_Z3SMALL_HEIGHT, FONT_Z3SMALL, MENU_TCOLOR_CONTROLS, -1, TF_CENTERED, "ENTER/(A): Confirm | BACKSPACE/(B): Back\n(START): Info | (UP)/(DOWN): Switch options\n(LEFT)/(RIGHT): Switch Tabs", OP_OPAQUE, 2, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
				//
				if(debugEnabled && PressControl() && Input->ReadKey[KEY_W]) optmenu->Write(7, "MM2D/MenuBitmap.png", true);
				TotalNoAction();
				Waitframe();
			}
			Audio->AdjustSFXVolume(100);
			TotalNoAction();
			reloadOptions();
			Screen_Freeze(FREEZE_NONE);
			hidePassive(false);
		}
		else
		{
			if(Input->ReadKey[Controls[CONTROL_OPTIONS]])
			{
				setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, true);
				Screen_Freeze(FREEZE_ACTION);
			}
		}
	}//end
	
	void runGameSetupMenu() //start
	{
		bool hasReleasedStart;
		Screen_Freeze(FREEZE_ACTION);
		int scroll = 0;
		int mainOption = 0;
		int subOption = 0;
		int tab = 0;
		int x = getTabPos(<SetupMenuTab>tab);
		int lastLR = -1;
		int cooldown = 0;
		int inputTimer = 0;
		SetupMenuState state = SETUPMENUSTATE_MAIN;
		updateOptFont(opt[OPT_OPTIONS_FONT]);
		hidePassive(true);
		Audio->AdjustSFXVolume(30);
		WaitTotalNoAction();
		while(true)
		{
			Waitdraw();
			unless(Input->Button[CB_START]) hasReleasedStart = true;
			if(cooldown>0)--cooldown;
			++inputTimer;
			inputTimer %= opt[OPT_MENU_HOLD_DELAY];
			reloadSetupBitmap(setupmenu); //Unlike opt menu, this needs reloading every frame, for disabled options!
			loadSetupTempBitmap(setupmenu);
			bool confirm = Input->Press[CB_A] || Input->ReadKey[KEY_ENTER] || Input->ReadKey[KEY_ENTER_PAD];
			bool deny = Input->Press[CB_B] || Input->ReadKey[KEY_BACKSPACE];
			const bool up = (Input->Press[CB_UP] || (Input->Button[CB_UP] && !inputTimer));
			const bool down = (Input->Press[CB_DOWN] || (Input->Button[CB_DOWN] && !inputTimer));
			const bool left = (Input->Press[CB_LEFT] || (Input->Button[CB_LEFT] && !inputTimer));
			const bool right = (Input->Press[CB_RIGHT] || (Input->Button[CB_RIGHT] && !inputTimer));
			if(Input->Press[CB_UP]||Input->Press[CB_DOWN]||Input->Press[CB_LEFT]||Input->Press[CB_RIGHT]) inputTimer = 0;
			
			if(confirm||deny||up||down||left||right) Audio->PlaySound(SFX_MENU_BEEP);
			
			if(deny)
			{
				if(state != SETUPMENUSTATE_MAIN)
					state = SETUPMENUSTATE_MAIN;
			}
			switch(state) //start
			{
				case SETUPMENUSTATE_MAIN: //start
				{
					//Scroll the menu visual based on currently selected option
					unless(mainOption-setupmenutabs[getTab(<SetupMenuState>mainOption)]) scroll = 0;
					//else if(getTab(<SetupMenuState>mainOption)!=getTab(<SetupMenuState>(mainOption+1))) scroll = MenuVars[SV_MAXSCROLL];
					else if(optionScrollCheck(<SetupMenuState>mainOption, scroll) != 0)
					{
						while(optionScrollCheck(<SetupMenuState>mainOption, scroll) == 1)
						{
							scroll += MENU_SCROLL_INC;
						}
						while(optionScrollCheck(<SetupMenuState>mainOption, scroll) == -1)
						{
							scroll -= MENU_SCROLL_INC;
						}
						scroll = VBound(scroll, MenuVars[SV_MAXSCROLL], 0);
					}
					if(canSel(<SetupMenuTab>tab))
					{
						switch(mainOption)
						{
							// "Setup"
							
							case SETUPMENUSTATE_BEGINGAME:
								DrawMenuString("Begin Game", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
							
							case SETUPMENUSTATE_OPTIONS:
								DrawMenuString("Options", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
							
							case SETUPMENUSTATE_INFDUR_RAZORSWORD:
								DrawMenuString("Razor Sword Never Breaks", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
								
							case SETUPMENUSTATE_SKIP_BEAVER:
								DrawMenuString("Skip Beaver Race", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
							
							// "Rando"
							
							case SETUPMENUSTATE_RANDOMIZE:
								DrawMenuString("Randomizer", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
							
							case SETUPMENUSTATE_SEED:
								DrawMenuString("Seed", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
								
							// "RandFlags"
							
							case SETUPMENUSTATE_START_SOS:
								DrawMenuString("Start With Song of Soaring", setupmenu, 1, getTabPos(<SetupMenuState>mainOption) + MENU_LEFT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption), MENU_TCOLOR_ACTIVE, TF_NORMAL);
								break;
						}
						if(confirm)
						{
							state = <SetupMenuState>mainOption;
							subOption = 0;
						}
						else if(up)
						{
							mainOption = wrapOpt(<SetupMenuState>(mainOption-1), tab);
							until(canSel(<SetupMenuState>(mainOption)))
							{
								mainOption = wrapOpt(<SetupMenuState>(mainOption-1), tab);
							};
						}
						else if(down)
						{
							mainOption = wrapOpt(<SetupMenuState>(mainOption+1), tab);
							until(canSel(<SetupMenuState>(mainOption)))
							{
								mainOption = wrapOpt(<SetupMenuState>(mainOption+1), tab);
							};
						}
					}
					unless(cooldown)
					{
						if(left)
						{
							lastLR = DIR_LEFT;
							--tab;
							if(tab < 0) tab += SETUPMENUTAB_END;
							mainOption = setupmenutabs[tab];
							cooldown = 10;
						}
						else if(right)
						{
							lastLR = DIR_RIGHT;
							++tab;
							tab %= SETUPMENUTAB_END;
							mainOption = setupmenutabs[tab];
							cooldown = 10;
						}
					}
					break;
				} //end
				
				case SETUPMENUSTATE_BEGINGAME: //start
				{
					DrawMenuString("Are you sure?", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
					if(confirm)
					{
						Screen_Freeze(FREEZE_FORCE_NONE);
						hidePassive(false);
						return;
					}
					break;
				}//end
				
				case SETUPMENUSTATE_OPTIONS: //start
				{
					DrawMenuString("Open?", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
					if(confirm)
					{
						setGlobalBool(GVAR_OPTIONS_MENU, GV_MISC_BOOL, true);
						runOptMenu();
						Screen_Freeze(FREEZE_ACTION);
						continue; //continue to top of `while(true)`, for next frame
					}
					break;
				}//end
				
				case SETUPMENUSTATE_INFDUR_RAZORSWORD:
				{
					DrawMenuString(opt[OPT_INFDUR_RAZSWORD] ? "  True" : " False", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], opt[OPT_INFDUR_RAZSWORD] ? GREEN : RED, TF_RIGHT);
					if(confirm)
						opt[OPT_INFDUR_RAZSWORD] = !opt[OPT_INFDUR_RAZSWORD];
					break;
				}
				
				case SETUPMENUSTATE_SKIP_BEAVER:
				{
					DrawMenuString(opt[OPT_SKIPBEAVER] ? "  True" : " False", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], opt[OPT_SKIPBEAVER] ? GREEN : RED, TF_RIGHT);
					if(confirm)
						opt[OPT_SKIPBEAVER] = !opt[OPT_SKIPBEAVER];
					break;
				}
				
				case SETUPMENUSTATE_RANDOMIZE:
				{
					const bool rand = Rando::getFlag(Rando::FLAG_ACTIVE);
					DrawMenuString(rand ? "  On" : " Off", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], rand ? GREEN : RED, TF_RIGHT);
					if(confirm)
						Rando::setFlag(Rando::FLAG_ACTIVE, !rand);
					break;
				}
				
				case SETUPMENUSTATE_SEED:
				{
					char buf[16];
					ftoia(buf, Rando::seed); //Float to Integer Ascii, basically ftoa but w/o decimal
					DrawMenuString(buf, setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], MENU_TCOLOR_ACTIVE, TF_RIGHT);
					if(confirm)
					{
						TotalNoAction();
						runSeedSelectMenu();
						TotalNoAction();
						continue; //continue to top of `while(true)`, for next frame
					}
					break;
				}
				
				case SETUPMENUSTATE_START_SOS:
				{
					const bool startsos = Rando::getFlag(Rando::FLAG_START_SOS);
					DrawMenuString(startsos ? "  True" : " False", setupmenu, 2, getTabPos(<SetupMenuState>mainOption) + MENU_RIGHT_MARGIN, MenuVars[SV_TEMPY] + menuposy(<SetupMenuState>mainOption) + MenuVars[MSV_MENU_FONT_HEIGHT], startsos ? GREEN : RED, TF_RIGHT);
					if(confirm)
						Rando::setFlag(Rando::FLAG_START_SOS, !startsos);
					break;
				}
			}//end
			//printf("State: %d\nMainOpt: %d\nSubOpt: %d\nScroll: %d\n\n", state, mainOption, subOption, scroll);
			Screen->Rectangle(MENU_LAYER, 0, MenuVars[MSV_TOP_MENU], 256, MenuVars[MSV_VIS_SCREEN_HEIGHT], BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
			//start tab calcs
			int destx = getTabPos(<SetupMenuTab>tab);
			//Calculate left/right distances
			if(destx != x)
			{
				int cmp = comp(destx, x);
				int ldist, rdist;
				for(int lx = x; lx != destx; --lx)
				{
					if(lx < MENU_START_TABS_X) lx += S_TABS_WIDTH;
					++ldist;
				}
				for(int rx = x; rx != destx; ++rx)
				{
					if(rx >= S_TABS_WIDTH + MENU_START_TABS_X - 1) rx -= S_TABS_WIDTH;
					++rdist;
				}
				x += ldist < rdist ? -(MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (rdist < ldist ? (MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (lastLR == DIR_LEFT ? -(MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]) : (MENU_SCROLL_SPEED * opt[OPT_MENU_SCROLL_MULT]))); //Choose the closer direction
				if(cmp != comp(destx, x)) x = destx; //Prevent passing it if scroll speed is odd
				else if(x < MENU_START_TABS_X) x += S_TABS_WIDTH; //Wrap
				else if(x >= MENU_START_TABS_X + S_TABS_WIDTH) x -= S_TABS_WIDTH; //Wrap
			}
			//end
			
			int yoffs = SubscreenHidden() ? (MenuVars[MSV_TOP_MENU] < 0 ? -MenuVars[MSV_TOP_MENU] : 0) : 0;
			
			if(Input->Button[CB_START] && hasReleasedStart)
				setupmenu->Blit(MENU_LAYER, RT_SCREEN, MENU_CONTROL_X, MENU_CONTROL_Y, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, MenuVars[MSV_TOP_MENU] + yoffs, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
			else
			{
				setupmenu->Blit(MENU_LAYER, RT_SCREEN, x, scroll + MENU_PERM_Y, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, MenuVars[MSV_TOP_MENU] + yoffs, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
				setupmenu->Blit(MENU_LAYER, RT_SCREEN, x, scroll + MenuVars[SV_TEMPY], 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, MenuVars[MSV_TOP_MENU] + yoffs, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
				int wid = M_MENU_BITMAP_WIDTH - x + 1;
				if(wid < 256)
				{
					setupmenu->Blit(MENU_LAYER, RT_SCREEN, MENU_START_TABS_X, scroll + MENU_PERM_Y, 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, wid, MenuVars[MSV_TOP_MENU] + yoffs, 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
					setupmenu->Blit(MENU_LAYER, RT_SCREEN, MENU_START_TABS_X, scroll + MenuVars[SV_TEMPY], 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, wid, MenuVars[MSV_TOP_MENU] + yoffs, 256 - wid, MenuVars[MSV_VIS_SCREEN_HEIGHT] - yoffs, 0, 0, 0, 0, 0, true);
				}
			}
			//setupmenu->Blit(MENU_LAYER, RT_SCREEN, 0, scroll, 256, MenuVars[MSV_VIS_SCREEN_HEIGHT], 0, MenuVars[MSV_TOP_MENU], 256, MenuVars[MSV_VIS_SCREEN_HEIGHT], 0, 0, 0, 0, 0, true);
			if(MENU_ENFORCE_MARGINS)
			{
				Screen->Rectangle(MENU_LAYER, 0,                 MenuVars[MSV_TOP_MENU] + yoffs,                256,                  MenuVars[MSV_TOP_MARGIN] - 1 + yoffs, BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
				Screen->Rectangle(MENU_LAYER, 0,                 MenuVars[MSV_TOP_MENU] + yoffs,                MENU_LEFT_MARGIN - 1, 176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
				Screen->Rectangle(MENU_LAYER, MENU_RIGHT_MARGIN, MenuVars[MSV_TOP_MENU] + yoffs,                256,                  176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
				Screen->Rectangle(MENU_LAYER, 0,                 168 - MENU_BOTTOM_MARGIN_HEIGHT, 256,                  176,                         BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
			}
			//SetupMenuTab names
			char buf1[32], buf2[32], buf3[32];
			SetupMenuTab currtabs[3] = {wrapSetupTab(<SetupMenuTab>(tab-1)),wrapSetupTab(<SetupMenuTab>tab),wrapSetupTab(<SetupMenuTab>(tab+1))};
			getTabName(buf1, currtabs[0]);
			getTabName(buf2, currtabs[1]);
			getTabName(buf3, currtabs[2]);
			Screen->DrawString(MENU_LAYER,  64, MenuVars[MSV_TABLABEL_Y] + yoffs, FONT_Z3SMALL, canSel(currtabs[0]) ? MENU_TCOLOR_TABS : MENU_TCOLOR_DEACTIVATED, TRANSBG, TF_CENTERED, buf1, OP_OPAQUE);
			Screen->DrawString(MENU_LAYER, 128, MenuVars[MSV_TABLABEL_Y] + yoffs, FONT_Z3SMALL, canSel(currtabs[1]) ? MENU_TCOLOR_TABS : MENU_TCOLOR_DEACTIVATED, TRANSBG, TF_CENTERED, buf2, OP_OPAQUE);
			Screen->DrawString(MENU_LAYER, 192, MenuVars[MSV_TABLABEL_Y] + yoffs, FONT_Z3SMALL, canSel(currtabs[2]) ? MENU_TCOLOR_TABS : MENU_TCOLOR_DEACTIVATED, TRANSBG, TF_CENTERED, buf3, OP_OPAQUE);
			//Controls
			DrawStrings(MENU_LAYER, 128, MENU_BOTTOM_MARGIN + FONT_Z3SMALL_HEIGHT, FONT_Z3SMALL, MENU_TCOLOR_CONTROLS, -1, TF_CENTERED, "ENTER/(A): Confirm | BACKSPACE/(B): Back\n(START): Info | (UP)/(DOWN): Switch options\n(LEFT)/(RIGHT): Switch Tabs", OP_OPAQUE, 2, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
			//
			if(debugEnabled && PressControl() && Input->ReadKey[KEY_W]) setupmenu->Write(7, "MM2D/SetupMenuBitmap.png", true);
			TotalNoAction();
			Waitframe();
		}
		Audio->AdjustSFXVolume(100);
		TotalNoAction();
		reloadOptions();
		Screen_Freeze(FREEZE_NONE);
	}//end
	
	void runSeedSelectMenu() //start
	{
		DEFINE SCREEN_HCENTER = 128;
		DEFINE M_TOP = SubscreenHidden() ? 0 : -56;
		DEFINE SCREEN_VCENTER = (((SCREEN_BOTTOM-8) - M_TOP) / 2) + M_TOP;
		int pos;
		char seedbuf[16];
		ftoia(seedbuf, Rando::seed);
		while(true)
		{
			FlashScreen(BLACK, true); //Full-screen black rect
			const bool confirm = Input->Press[CB_A] || Input->ReadKey[KEY_ENTER];
			const bool deny = Input->Press[CB_B] || Input->ReadKey[KEY_BACKSPACE];
			const bool up = Input->Press[CB_UP];
			const bool down = Input->Press[CB_DOWN];
			if(confirm||deny||up||down) Audio->PlaySound(SFX_MENU_BEEP);
			if(deny) return;
			if(up||down) pos = (pos+1)%2;
			DrawStrings(7, SCREEN_HCENTER, SCREEN_VCENTER-10, opt[OPT_OPTIONS_FONT], (pos==0) ? MENU_TCOLOR_ACTIVE : MENU_TCOLOR_INACTIVE_PERM, BLACK, TF_CENTERED, "Random", OP_OPAQUE, 2, 256);
			DrawStrings(7, SCREEN_HCENTER, SCREEN_VCENTER+10, opt[OPT_OPTIONS_FONT], (pos==1) ? MENU_TCOLOR_ACTIVE : MENU_TCOLOR_INACTIVE_PERM, BLACK, TF_CENTERED, seedbuf, OP_OPAQUE, 2, 256);
			switch(pos)
			{
				case 0:
					if(confirm)
					{
						Rando::seed = SRand();
						remchr(seedbuf, 0);
						ftoia(seedbuf, Rando::seed);
					}
					break;
				case 1:
					if(confirm)
					{
						startTypingMode(11, TMODE_NUMERIC);
						while(true)
						{
							FlashScreen(BLACK, true); //Full-screen black rect
							handleTyping();
							char buf[16];
							getType(buf);
							unless(typingJustEnded())
							{
								DrawStrings(7, SCREEN_HCENTER, SCREEN_VCENTER, opt[OPT_OPTIONS_FONT], MENU_TCOLOR_ACTIVE, BLACK, TF_CENTERED, buf, OP_OPAQUE, 2, 256);
							}
							else
							{
								Rando::seed = iatof(buf);
								Debug::print("Seed Text %s converts to %f", buf, Rando::seed);
								break;
							}
							Waitframe();
						}
					}
					remchr(seedbuf, 0);
					ftoia(seedbuf, Rando::seed);
					break;
			}
			Waitframe();
		}
	}//end
	
	int menuposy(OptMenuState opt)
	{
		int opthei = opt - optmenutabs[getTab(opt)];
		return MENU_TOP_MARGIN_HEIGHT + ((MENU_SPACING + MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT]) * opthei);
	}
	
	int menuposy(SetupMenuState opt)
	{
		int opthei = opt - setupmenutabs[getTab(opt)];
		return MENU_TOP_MARGIN_HEIGHT + ((MENU_SPACING + MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT]) * opthei);
	}
	
	int tabNumOpts(OptMenuState opt)
	{
		return tabNumOpts(getTab(opt));
	}
	
	int tabNumOpts(OptMenuTab tab)
	{
		return optmenutabs[tab+1] - optmenutabs[tab]; 
	}
	
	int tabNumOpts(SetupMenuState opt)
	{
		return tabNumOpts(getTab(opt));
	}
	
	int tabNumOpts(SetupMenuTab tab)
	{
		return setupmenutabs[tab+1] - setupmenutabs[tab]; 
	}
	
	//Call in OnSaveLoad, and when exiting options menu.
	void reloadOptions() //start
	{
		//Forcibly ensure that all option settings are in effect
		//
		//Set "Flip Right-Handed Slash" on all swords
		itemdata it = Game->LoadItemData(IT_SWORD_KOKIRI);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_RAZOR);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_GILDED);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_GFAIRY);
		it->Flags[7] = opt[OPT_RFS];
		it = Game->LoadItemData(IT_SWORD_ZORA_BLADE);
		it->Flags[7] = opt[OPT_RFS];
		//
	}//end
	
	//start Drawing
	void reloadMenuBitmap(bitmap menu) //start
	{
		menu->Rectangle(0, 0, 0, M_MENU_BITMAP_WIDTH, MenuVars[MV_BMPHEIGHT], 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		int x = MENU_START_TABS_X + MENU_LEFT_MARGIN_WIDTH;
		DEFINE TOP_Y = MENU_TOP_MARGIN_HEIGHT;
		int y = TOP_Y;
		//
		// "Options"
		//
		DrawMenuString("Flip Right-Facing Slash", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Lens Tint Color", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Hide Tint In Menus", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Menu Scroll Speed", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Menu Input Hold Delay", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		//
		// "Controls"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		//
		DrawMenuString("Options Menu", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		//
		// "System"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		//
		//y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//Last slot.
		DrawMenuString("Font", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		DrawMenuString("Reset All to Default", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		///////////////////////
		x = MENU_CONTROL_X + 128;
		y = TOP_Y;
		//
		DrawMenuStrings("Default Lens of Truth:\n-17, -48, 5", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED, 0, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuStrings("When control binding:\nPress any keyboard key to bind it.\nConflicting binds may cause issues.", menu, 0, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED, 0, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		/*
		DrawMenuString(, menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;*/
	}//end
	
	void loadMenuTempBitmap(bitmap menu) //start
	{
		menu->Rectangle(0, MENU_START_TABS_X, MenuVars[MV_TEMPY], M_MENU_BITMAP_WIDTH, MenuVars[MV_OPHEIGHT] * 2, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		int x = MENU_START_TABS_X + MENU_RIGHT_MARGIN;
		DEFINE TOP_Y = MenuVars[MV_TEMPY] + MENU_TOP_MARGIN_HEIGHT + MenuVars[MSV_MENU_FONT_HEIGHT]; //Font offset to make it one row lower
		int y = TOP_Y;
		//
		// "Options"
		//
		DrawMenuString(opt[OPT_RFS] ? "  On" : "Off", menu, 1, x, y, opt[OPT_RFS] ? DARKGREEN : DARKRED, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		char rbuf[16], gbuf[16], bbuf[16];
		itoa(rbuf, __tintR[getGlobalVar(TINT_LENS, GV_PAL)]);
		itoa(gbuf, __tintG[getGlobalVar(TINT_LENS, GV_PAL)]);
		itoa(bbuf, __tintB[getGlobalVar(TINT_LENS, GV_PAL)]);
		strcat(rbuf, " ");
		strcat(gbuf, " ");
		DEFINE RWID = Text->StringWidth(rbuf, opt[OPT_OPTIONS_FONT]),
			GWID = Text->StringWidth(gbuf, opt[OPT_OPTIONS_FONT]),
			BWID = Text->StringWidth(bbuf, opt[OPT_OPTIONS_FONT]);
		DrawMenuString("Preview ", menu, 1, x - (RWID+GWID+BWID), y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		DrawMenuString(rbuf, menu, 1, x - (GWID+BWID), y, DARKRED, TF_RIGHT);
		DrawMenuString(gbuf, menu, 1, x - (BWID), y, DARKGREEN, TF_RIGHT);
		DrawMenuString(bbuf, menu, 1, x, y, DARKBLUE, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString(opt[OPT_HIDE_TINT_IN_MENU] ? "  On" : "Off", menu, 2, x, y, opt[OPT_HIDE_TINT_IN_MENU] ? DARKGREEN : DARKRED, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		char buf4[16] = "      x";
		if(opt[OPT_MENU_SCROLL_MULT]<1) strcat(buf4,"0.5");
		else itoa(buf4, 7, opt[OPT_MENU_SCROLL_MULT]);
		DrawMenuString(buf4, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		char buf5[16] = "    ";
		itoa(buf5, 4, opt[OPT_MENU_HOLD_DELAY]);
		DrawMenuString(buf5, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		//
		// "Controls"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		char buf0[64];
		KeyToString(Controls[CONTROL_OPTIONS], buf0, true, true);
		DrawMenuString(buf0, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		// "System"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		char buf6[32];
		getFontName(buf6, opt[OPT_OPTIONS_FONT]);
		DrawMenuString(buf6, menu, 1, x, y, MENU_TCOLOR_INACTIVE_TEMP, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//Reset default; no temp text
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
	}//end
	
	void reloadSetupBitmap(bitmap menu) //start
	{
		const bool rand = Rando::getFlag(Rando::FLAG_ACTIVE);
		menu->Rectangle(0, 0, 0, M_MENU_BITMAP_WIDTH, MenuVars[SV_BMPHEIGHT], 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		int x = MENU_START_TABS_X + MENU_LEFT_MARGIN_WIDTH;
		DEFINE TOP_Y = MENU_TOP_MARGIN_HEIGHT;
		int y = TOP_Y;
		//
		// "Setup"
		//
		DrawMenuString("Begin Game", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Options", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Razor Sword Never Breaks", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Skip Beaver Race", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		//
		// "Rando"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		//
		DrawMenuString("Randomizer", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString("Seed", menu, 1, x, y, rand ? MENU_TCOLOR_INACTIVE_PERM : MENU_TCOLOR_DEACTIVATED, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//{}Module
		//
		// "RandFlags"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		//
		//y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//Last slot.
		DrawMenuString("Start With Song of Soaring", menu, 1, x, y, rand ? MENU_TCOLOR_INACTIVE_PERM : MENU_TCOLOR_DEACTIVATED, TF_NORMAL);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		///////////////////////
		x = MENU_CONTROL_X + 128;
		y = TOP_Y;
		//
		DrawMenuStrings("The function of each setting is listed in 'MM2D/readme.txt'", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED, 0, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		/*
		DrawMenuStrings("", menu, 1, x, y, MENU_TCOLOR_INACTIVE_PERM, TF_CENTERED, 0, 256-(MENU_RIGHT_MARGIN_WIDTH + MENU_LEFT_MARGIN_WIDTH));
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;*/
	} //end
	
	void loadSetupTempBitmap(bitmap menu) //start
	{
		const bool rand = Rando::getFlag(Rando::FLAG_ACTIVE);
		menu->Rectangle(0, MENU_START_TABS_X, MenuVars[MV_TEMPY], M_MENU_BITMAP_WIDTH, MenuVars[MV_OPHEIGHT] * 2, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		int x = MENU_START_TABS_X + MENU_RIGHT_MARGIN;
		DEFINE TOP_Y = MenuVars[SV_TEMPY] + MENU_TOP_MARGIN_HEIGHT + MenuVars[MSV_MENU_FONT_HEIGHT]; //Font offset to make it one row lower
		int y = TOP_Y;
		//
		// "Setup"
		//
		//BLANK
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//BLANK
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString(opt[OPT_INFDUR_RAZSWORD] ? "  True" : " False", menu, 1, x, y, opt[OPT_INFDUR_RAZSWORD] ? DARKGREEN : DARKRED, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		DrawMenuString(opt[OPT_SKIPBEAVER] ? "  True" : " False", menu, 1, x, y, opt[OPT_SKIPBEAVER] ? DARKGREEN : DARKRED, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		// "Rando"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		DrawMenuString(rand ? "  On" : " Off", menu, 1, x, y, rand ? DARKGREEN : DARKRED, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		char buf[16];
		ftoia(buf, Rando::seed); //Float to Integer Ascii, basically ftoa but w/o decimal
		DrawMenuString(buf, menu, 1, x, y, rand ? MENU_TCOLOR_INACTIVE_TEMP : MENU_TCOLOR_DEACTIVATED, TF_RIGHT);
		//
		// "RandFlags"
		//
		x += MENU_SCREEN_WIDTH;
		y = TOP_Y;
		const bool StartSoS = Rando::getFlag(Rando::FLAG_START_SOS);
		DrawMenuString(StartSoS ? "  True" : " False", menu, 1, x, y, rand ? (StartSoS ? DARKGREEN : DARKRED) : MENU_TCOLOR_DEACTIVATED, TF_RIGHT);
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
		y += MenuVars[MSV_MENU_FONT_HEIGHT] + MenuVars[MSV_MENU_FONT_HEIGHT] + MENU_SPACING;
		//
	} //end
	
	//start DrawMenuString(s)
	void DrawMenuString(char str, bitmap menu, int layer, int x, int y, int color, int format)
	{
		DrawMenuString(str, menu, layer, x, y, color, format, false);
	}
	
	void DrawMenuString(char str, bitmap menu, int layer, int x, int y, int color, int format, bool transbg)
	{
		menu->DrawString(layer, x, y, opt[OPT_OPTIONS_FONT], color, transbg ? TRANSBG : BLACK, format, str, OP_OPAQUE);
	}
	
	void DrawMenuStrings(char str, bitmap menu, int layer, int x, int y, int color, int format, int verticalSpacing, int MaxWidth)
	{
		DrawMenuStrings(str, menu, layer, x, y, color, format, false, verticalSpacing, MaxWidth);
	}
	
	void DrawMenuStrings(char str, bitmap menu, int layer, int x, int y, int color, int format, bool transbg, int verticalSpacing, int MaxWidth)
	{
		DrawStringsBitmap(menu, layer, x, y, opt[OPT_OPTIONS_FONT], color, transbg ? TRANSBG : BLACK, format, str, OP_OPAQUE, verticalSpacing, MaxWidth);
	}//end
	//end
	
	enum KeyValidation
	{
		KV_QUIT = -1,
		KV_INVALID,
		KV_VALID
	};
	
	KeyValidation isValidKey(int key)
	{
		switch(key)
		{
			case 0:
			case KEY_ENTER:
			case KEY_ENTER_PAD:
				return KV_INVALID;
			case KEY_BACKSPACE:
			case KEY_ESC:
				return KV_QUIT;
				
			default:
				for(int q = 0; q < 14; ++q)
				{
					if(key==Input->KeyBindings[q]) return (q==CB_B ? KV_QUIT : KV_INVALID);
				}
				return KV_VALID;
		}
	}
	
	//start OptMenuTab stuff
	OptMenuTab getTab(OptMenuState opt)
	{
		if(opt == OPTMENUSTATE_MAIN) return OPTMENUTAB_INVALID;
		int tab = 0;
		for(; tab < OPTMENUTAB_END; ++tab)
		{
			if(opt < optmenutabs[tab+1]) break;
		}
		return <OptMenuTab>(tab == OPTMENUTAB_END ? -1 : tab);
	}
	
	int getTabPos(OptMenuState opt)
	{
		return getTabPos(getTab(opt));
	}
	
	int getTabPos(OptMenuTab tab)
	{
		if(tab == OPTMENUTAB_INVALID) return -1;
		return MENU_START_TABS_X + (MENU_SCREEN_WIDTH * tab);
	}
	
	void getTabName(char buf, OptMenuTab tab)
	{
		switch(tab)
		{
			case OPTMENUTAB_OPT:
				strcat(buf, "Options");
				break;
				
			case OPTMENUTAB_CONTROL:
				strcat(buf, "Controls");
				break;
				
			case OPTMENUTAB_SYSTEM:
				strcat(buf, "System");
				break;
				
			default:
				Debug::print("[Error] Invalid tab %d passed to 'getTabName()'", tab);
		}
	}
	
	OptMenuTab wrapOptTab(OptMenuTab tab)
	{
		int t = tab;
		if(t >= OPTMENUTAB_END) t %= OPTMENUTAB_END;
		while(t <= OPTMENUTAB_INVALID) t += OPTMENUTAB_END;
		return <OptMenuTab>t;
	}
	
	SetupMenuTab wrapOptTab(SetupMenuTab tab)
	{
		int t = tab;
		if(t >= SETUPMENUTAB_END) t %= SETUPMENUTAB_END;
		while(t <= SETUPMENUTAB_INVALID) t += SETUPMENUTAB_END;
		return <SetupMenuTab>t;
	}
	
	OptMenuState wrapOpt(OptMenuState opt, int tab)
	{
		if(getTab(opt) != tab)
		{
			if(opt < optmenutabs[tab]) return <OptMenuState>(optmenutabs[tab+1] - 1);
			else if(opt > optmenutabs[tab]) return optmenutabs[tab];
		}
		return opt;
	}
	
	SetupMenuState wrapOpt(SetupMenuState opt, int tab)
	{
		if(getTab(opt) != tab)
		{
			if(opt < setupmenutabs[tab]) return <SetupMenuState>(setupmenutabs[tab+1] - 1);
			else if(opt > setupmenutabs[tab]) return setupmenutabs[tab];
		}
		return opt;
	}
	//end
	
	//start SetupMenuTab stuff
	SetupMenuTab getTab(SetupMenuState opt)
	{
		if(opt == SETUPMENUSTATE_MAIN) return SETUPMENUTAB_INVALID;
		int tab = 0;
		for(; tab < SETUPMENUTAB_END; ++tab)
		{
			if(opt < setupmenutabs[tab+1]) break;
		}
		return <SetupMenuTab>(tab == SETUPMENUTAB_END ? -1 : tab);
	}
	
	int getTabPos(SetupMenuState opt)
	{
		return getTabPos(getTab(opt));
	}
	
	int getTabPos(SetupMenuTab tab)
	{
		if(tab == SETUPMENUTAB_INVALID) return -1;
		return MENU_START_TABS_X + (MENU_SCREEN_WIDTH * tab);
	}
	
	void getTabName(char buf, SetupMenuTab tab)
	{
		switch(tab)
		{
			case SETUPMENUTAB_SETUP:
				strcat(buf, "Setup");
				break;
				
			case SETUPMENUTAB_RANDOMAIN:
				strcat(buf, "Rando");
				break;
				
			case SETUPMENUTAB_RANDOFLAGS:
				strcat(buf, "RandFlags");
				break;
				
			default:
				Debug::print("[Error] Invalid tab %d passed to 'getTabName()'", tab);
		}
	}
	
	SetupMenuTab wrapSetupTab(int t)
	{
		if(t >= SETUPMENUTAB_END) t %= SETUPMENUTAB_END;
		while(t <= SETUPMENUTAB_INVALID) t += SETUPMENUTAB_END;
		return <SetupMenuTab>t;
	}
	
	bool canSel(SetupMenuState opt)
	{
		switch(opt)
		{
			case SETUPMENUSTATE_SEED:
			case SETUPMENUSTATE_START_SOS:
				return Rando::getFlag(Rando::FLAG_ACTIVE);
			default: return true;
		}
	}
	
	bool canSel(SetupMenuTab tab)
	{
		switch(tab)
		{
			case SETUPMENUTAB_RANDOFLAGS:
				return Rando::getFlag(Rando::FLAG_ACTIVE);
			default: return true;
		}
	}
	//end
	
	void printDraws()
	{
		Log::print("[Draws] Draws this frame: %d/%d", Graphics->NumDraws(), Graphics->MaxDraws());
	}
	
	void resetAllOpts()
	{
		Controls[CONTROL_OPTIONS] = KEY_TAB;
		opt[OPT_RFS] = false;
		__tintR[getGlobalVar(TINT_LENS, GV_PAL)] = -17;
		__tintG[getGlobalVar(TINT_LENS, GV_PAL)] = -48;
		__tintB[getGlobalVar(TINT_LENS, GV_PAL)] = 5;
		opt[OPT_HIDE_TINT_IN_MENU] = true;
		opt[OPT_MENU_SCROLL_MULT] = 1;
		opt[OPT_MENU_HOLD_DELAY] = 30;
		updateOptFont(MENU_FONT_DEFAULT);
	}
}
//end
//start GameOverMenu
namespace GameOverMenu
{
	enum QuitState { NONE = -1, CONTINUE, RESET_TIME, QUIT, CANCEL };
	
	//start Constants
	CONFIG MENU_LAYER = 7;
	CONFIG MENU_FONT = FONT_ACORN;
	CONFIG MENU_FONT_HEIGHT = 10;
	CONFIG MENU_SPACING = 16;
	CONFIG MENU_COLOR_ACTIVE = RED;
	CONFIG MENU_COLOR_INACTIVE = GRAY;
	//
	DEFINE SCREEN_WIDTH = SCREEN_RIGHT - SCREEN_LEFT;
	DEFINE SCREEN_HCENTER = (SCREEN_WIDTH / 2) + SCREEN_LEFT;
	//end
	
	hero script OnDeath
	{
		void run()
		{
			Hero->HP = Hero->MaxHP; //Stop heart beep
			killAllSfx();
			runGameOverMenu(false);
		}
	}

	global script OnF6
	{
		void run()
		{
			FreezeState frz = Get_Freeze();
			pauseAllSfx();
			runGameOverMenu(true);
			resumeAllSfx();
			Screen_Freeze(frz);
		}
	}

	QuitState runGameOverMenu(bool allowCancel)
	{
		if(opt[OPT_HIDE_TINT_IN_MENU]) hideAllTints(true);
		QuitState state = NONE;
		int cursor = 0;
		DEFINE NUM_OPTIONS = 1 + <int>(allowCancel) + <int>(Hero->Item[IT_OCARINA]) + <int>(day < 4);
		DEFINE M_TOP = SubscreenHidden() ? 0 : -56;
		DEFINE VCENTER = (((SCREEN_BOTTOM-8) - M_TOP) / 2) + M_TOP;
		DEFINE START_TEXT = VCENTER - (((NUM_OPTIONS * MENU_FONT_HEIGHT) + ((NUM_OPTIONS - 1) * MENU_SPACING)) / 2);
		int timer;
		while(state==NONE)
		{
			++timer;
			if(Input->Press[CB_DOWN] || (Input->Button[CB_DOWN] && !(timer%opt[OPT_MENU_HOLD_DELAY]))) ++cursor;
			else if(Input->Press[CB_UP] || (Input->Button[CB_UP] && !(timer%opt[OPT_MENU_HOLD_DELAY]))) --cursor;
			if(Input->Press[CB_DOWN] || Input->Press[CB_UP]) timer=0;
			while(cursor<0)cursor+=NUM_OPTIONS;
			cursor %= NUM_OPTIONS;
			Screen->Rectangle(7, SCREEN_LEFT, M_TOP, SCREEN_RIGHT, SCREEN_BOTTOM, BLACK, 1, 0, 0, 0, true, OP_OPAQUE);
			int opt = 0;
			if(day < 4)
			{
				if(Input->Press[CB_START] && cursor==opt) state = CONTINUE;
				drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, CONTINUE);
			}
			if(Hero->Item[IT_OCARINA])
			{
				if(Input->Press[CB_START] && cursor==opt) state = RESET_TIME;
				drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, RESET_TIME);
			}
			if(Input->Press[CB_START] && cursor==opt) state = QUIT;
			drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, QUIT);
			if(allowCancel)
			{
				if(Input->Press[CB_START] && cursor==opt) state = CANCEL;
				drawOpt(SCREEN_HCENTER, START_TEXT + (opt * (MENU_FONT_HEIGHT + MENU_SPACING)), cursor==opt++, CANCEL);
			}
			NoAction();
			Waitframe();
		}
		end(state);
		return state;
	}
	
	void drawOpt(int x, int y, bool active, QuitState opt) //Default overload
	{
		drawOpt(MENU_LAYER, x, y, MENU_FONT, active ? MENU_COLOR_ACTIVE : MENU_COLOR_INACTIVE, TRANS, TF_CENTERED, opt, OP_OPAQUE);
	}
	void drawOpt(int layer, int x, int y, int font, int color, int bgcolor, int format, QuitState opt, int opacity)
	{
		switch(opt)
		{
			case CONTINUE:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Continue", opacity);
				break;
			case RESET_TIME:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Reset Time", opacity);
				break;
			case QUIT:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Quit", opacity);
				break;
			case CANCEL:
				Screen->DrawString(layer, x, y, font, color, bgcolor, format, "Cancel", opacity);
				break;
		}
	}
	
	void end(QuitState opt)
	{
		switch(opt)
		{
			case CONTINUE:
				Screen_Freeze(FREEZE_NONE);
				Game->Continue();
				break;
			case RESET_TIME:
				fakeSong = true;
				playSong(SONGNOTES_SongOfTime);
				playedSong = -1;
				while(songFrames)
				{
					Global.handleOcarina();
					playedSong = -1;
					Waitframe();
				}
				saveTheGame();
				resetTime();
				break;
			case QUIT:
				Screen_Freeze(FREEZE_NONE);
				Game->End();
				break;
			case CANCEL: //Do nothing! Just leave!
				Screen_Freeze(FREEZE_NONE);
				break;
		}
	}
}
//end

void testrun() //Function for testing things quickly at the start of the game
{
	return;
}//end

namespace Debug //start
{
	void printPoint(int num)
	{
		unless(__DEBUG)return;
		printf("[MM2D] [Debug] Point %d\n", num);
	}
	
	void printPoint(int num, int data)
	{
		unless(__DEBUG)return;
		printf("[MM2D] [Debug] Point %d, data %d\n", num, data);
	}
	
	void print(char str) //start
	{
		unless(__DEBUG) return;
		printf("[MM2D Debug] %s\n",str);
	}
	
	void print(char str, u q)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q);
	}
	
	void print(char str, u q, u q2)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2);
	}
	
	void print(char str, u q, u q2, u q3)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3);
	}
	
	void print(char str, u q, u q2, u q3, u q4)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3,q4);
	}
	
	void print(char str, u q, u q2, u q3, u q4, u q5)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3,q4,q5);
	}
	
	void print(char str, u q, u q2, u q3, u q4, u q5, u q6)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D Debug] %s\n",str);
		printf(buf,q,q2,q3,q4,q5,q6);
	}//end
}//end

namespace Log //start
{
	void print(char str) //start
	{
		unless(__DEBUG) return;
		printf("[MM2D] %s\n",str);
	}
	
	void print(char str, u q)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D] %s\n",str);
		printf(buf,q);
	}
	
	void print(char str, u q, u q2)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D] %s\n",str);
		printf(buf,q,q2);
	}
	
	void print(char str, u q, u q2, u q3)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D] %s\n",str);
		printf(buf,q,q2,q3);
	}
	
	void print(char str, u q, u q2, u q3, u q4)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D] %s\n",str);
		printf(buf,q,q2,q3,q4);
	}
	
	void print(char str, u q, u q2, u q3, u q4, u q5)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D] %s\n",str);
		printf(buf,q,q2,q3,q4,q5);
	}
	
	void print(char str, u q, u q2, u q3, u q4, u q5, u q6)
	{
		unless(__DEBUG) return;
		char buf[1024];
		sprintf(buf,"[MM2D] %s\n",str);
		printf(buf,q,q2,q3,q4,q5,q6);
	}//end
}//end

////////////////////////////////////////
//                                    //
//   MM2D Script: Game Environment    //
//                                    //
////////////////////////////////////////

//start MeltableIce
void handleMeltableIce(){
	for(int i=1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if((weap->ID==LW_ARROW&&arrowType==ARRTYPE_FIRE)||weap->ID==LW_HOTWATER){
				int combos[4] = {ComboAt(weap->X,weap->Y),ComboAt(weap->X+15,weap->Y),ComboAt(weap->X,weap->Y+15),ComboAt(weap->X+15,weap->Y+15)};
				for(int i=0;i<4;i++){
					if(Screen->ComboI[combos[i]]==CF_SCRIPT_ICE){
						Screen->ComboD[combos[i]]--;
					}
				}
			}
		}
	}
}
//end MeltableIce
//start FreezableWater
void handleFreezableWater(){
	for(int i=1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if(weap->ID==LW_ARROW&&arrowType==ARRTYPE_ICE){
				int combos[4] = {ComboAt(weap->X,weap->Y),ComboAt(weap->X+15,weap->Y),ComboAt(weap->X,weap->Y+15),ComboAt(weap->X+15,weap->Y+15)};
				for(int i=0;i<4;i++){
					if(Screen->ComboI[combos[i]]==CF_SCRIPT1&&Screen->ComboT[combos[i]]==CT_WATER){
						Screen->ComboD[combos[i]]++;
					}
				}
			}
		}
	}
}
//end FreezableWater
//start LedgeTooHighFromWater
bool wasOnWaterLedge = false;
void highLedgeFromWater(){
	if(!wasOnWaterLedge){
		if(Link->Action==LA_SWIMMING || Link->Action==LA_DIVING){
			if(LinkOnFlagMod(CF_NOWATERLEDGE2,0,LinkMovement[LM_STICKY]*3,0,true)||(form!=1&&LinkOnFlagMod(CF_NOWATERLEDGE,0,LinkMovement[LM_STICKY]*3,0,true))){
				if(LinkMovement[LM_STICKX]==0){
					if(LinkMovement[LM_STICKY]==1){
						Link->Dir=DIR_DOWN;
					} else if (LinkMovement[LM_STICKY]==-1){
						Link->Dir=DIR_UP;
					}
				}
				Link->InputDown=false;
				Link->InputUp=false;
				LinkMovement_SetLinkSpeedBoost(0);
			}
			if(LinkOnFlagMod(CF_NOWATERLEDGE2,LinkMovement[LM_STICKX]*3,0,0,true)||(form!=1&&LinkOnFlagMod(CF_NOWATERLEDGE,LinkMovement[LM_STICKX]*3,0,0,true))){
				if(LinkMovement[LM_STICKY]==0){
					if(LinkMovement[LM_STICKX]==1){
						Link->Dir=DIR_RIGHT;
					} else if (LinkMovement[LM_STICKX]==-1){
						Link->Dir=DIR_LEFT;
					}
				}
				Link->InputLeft=false;
				Link->InputRight=false;
				LinkMovement_SetLinkSpeedBoost(0);
			}
		} else {
			wasOnWaterLedge=LinkOnFlag(CF_NOWATERLEDGE)||LinkOnFlag(CF_NOWATERLEDGE2);
		}
	} else {
		wasOnWaterLedge=LinkOnFlag(CF_NOWATERLEDGE)||LinkOnFlag(CF_NOWATERLEDGE2);
	}
}

//end LedgeTooHighFromWater
//start Climb
ffc script climb{
	void run(int dir, int blockheight){
		int lspdboost = Ceiling(1.5+LinkMovement_GetLinkSpeedBoost());
		int width = this->EffectWidth;
		int height = this->EffectHeight;
		int bottomheight = height;
		if(Link->BigHitbox)bottomheight-=8;
		while(true){
			if(!isFrozen&&(blockheight>2||form==1||(blockheight==2&&(!form||form==2)))){
				if(dir==DIR_UP||dir==4){
					if(Link->Y>=this->Y-(16+lspdboost)){//start inputdown
						if(Link->Y<=this->Y-16){
							if(Link->X>=this->X-15){
								if(Link->X<=this->X+(width-1)){
									if(Link->InputDown){
										if(Link->Y!=this->Y-16)Link->Y=this->Y-16;
										Link->Dir=DIR_DOWN;
										if(Link->X>=this->X+(width-4)){
											if(CanWalk(Link->X,Link->Y,DIR_RIGHT,Abs(Link->X-(this->X+width)),false))Link->X=this->X+width;
										} else if(Link->X<=this->X-12)if(CanWalk(Link->X,Link->Y,DIR_LEFT,Abs(Link->X-this->X-16),false))Link->X=this->X-16;
									}
									Link->InputDown=false;
									Link->PressDown=false;
								}
							}
						}//end
					}
				}
				if(dir==DIR_DOWN||dir==4){
					if(Link->Y<=this->Y+(bottomheight+lspdboost)){//start inputup
						if(Link->Y>=this->Y+bottomheight){
							if(Link->X>=this->X-15){
								if(Link->X<=this->X+(width-1)){
									if(Link->InputUp){
										if(Link->Y!=this->Y+bottomheight)Link->Y=this->Y+bottomheight;
										Link->Dir=DIR_UP;
										if(Link->X>=this->X+(width-4)){
											if(CanWalk(Link->X,Link->Y,DIR_RIGHT,Abs(Link->X-(this->X+width)),false))Link->X=this->X+width;
										} else if(Link->X<=this->X-12)if(CanWalk(Link->X,Link->Y,DIR_LEFT,Abs(Link->X-this->X-16),false))Link->X=this->X-16;
									}
									Link->InputUp=false;
									Link->PressUp=false;
								}
							}
						}//end
					}
				}
				if(dir==DIR_LEFT||dir==4){
					if(Link->X>=this->X-(16+lspdboost)){//start inputright
						if(Link->X<=this->X-16){
							if(Link->Y<=this->Y+(bottomheight-1)){
								if(Link->Y>=this->Y-15){
									if(Link->InputRight){
										if(Link->X!=this->X-16)Link->X=this->X-16;
										Link->Dir=DIR_RIGHT;
										if(Link->Y>=this->Y+(bottomheight-4)){
											if(CanWalk(Link->X,Link->Y,DIR_DOWN,Abs(Link->Y-(this->Y+bottomheight)),false))Link->Y=this->Y+bottomheight;
										} else if(Link->Y<=this->Y-12)if(CanWalk(Link->X,Link->Y,DIR_UP,Abs(Link->Y-(this->Y-16)),false))Link->Y=this->Y-16;
									}
									Link->InputRight=false;
									Link->PressRight=false;
								}
							}
						}//end
					}
				}
				if(dir==DIR_RIGHT||dir==4){
					if(Link->X<=this->X+(width+lspdboost)){//start inputleft
						if(Link->X>=this->X+width){
							if(Link->Y>=this->Y-15){
								if(Link->Y<=this->Y+(bottomheight-1)){
									if(Link->InputLeft){
										if(Link->X!=this->X+width)Link->X=this->X+width;
										Link->Dir=DIR_LEFT;
										if(Link->Y>=this->Y+(bottomheight-4)){
											if(CanWalk(Link->X,Link->Y,DIR_DOWN,Abs(Link->Y-(this->Y+bottomheight)),false))Link->Y=this->Y+bottomheight;
										} else if(Link->Y<=this->Y-12)if(CanWalk(Link->X,Link->Y,DIR_UP,Abs(Link->Y-(this->Y-16)),false))Link->Y=this->Y-16;
									}
									Link->InputLeft=false;
									Link->PressLeft=false;
								}
							}
						}//end
					}
				}
			}
			Waitframe();
		}
	}
}
//end
//start Warp
ffc script warpCustomReturn{
	//Dirs: 0=Tile, 1=Up, 2=Down, 3=Left, 4=Right
	void run(int dmap, int screen, int X, int Y, int side){
		side-=1;
		switch(side){
			case DIR_UP:{
				while(true){
					if(!isFrozen&&Link->Y<=1&&(Link->PressUp||Link->InputUp)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			case DIR_DOWN:{
				while(true){
					if(!isFrozen&&Link->Y>=159&&(Link->PressDown||Link->InputDown)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			case DIR_LEFT:{
				while(true){
					if(!isFrozen&&Link->X<=1&&(Link->PressLeft||Link->InputLeft)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			case DIR_RIGHT:{
				while(true){
					if(!isFrozen&&Link->X>=239&&(Link->PressRight||Link->InputRight)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			default:{
				while(true){
					if(!isFrozen&&(Abs(Link->X-this->X)<=14&&Abs(Link->Y-this->Y)<=14)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
		}
	}
}
//end FFC warp
//start SoftSoil
ffc script SoftSoil
{
	void run(int raftDir, int screensUp, bool gskull, int startState, int index)
	{
		this->X = GridX(this->X);
		this->Y = GridY(this->Y);
		int waitTime = 0;
		if(startState==SSSTATE_GROWN)
		{
			this->X=GridX(Link->X+8);
			this->Y=GridY(Link->Y+8);
		}
		if(startState)setSoilState(index,startState);
		while(true)
		{
			int state = getSoilState(index);
			if(state!=SSSTATE_ACTIVE)
			{
				if(state==SSSTATE_WAITING)this->Data = COMBO_SOIL;
				if(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8)
				{
					if(usingBugs>0&&!gskull)
					{
						usingBugs=0;
						Waitframes(120);
						int numitems = Rand(3,6);
						for(int i=0;i<numitems;i++)
						{
							int itemPick = Rand(1,100);
							int id = 0;
							if(itemPick<=33)id=0;
							else if(itemPick<=60)id=1;
							else if(itemPick<=70)id=38;
							else if(itemPick<=75)id=87;
							else if(itemPick<=85)id=73;
							else if(itemPick<=95)id=80;
							else id = 156;
							int x = Clamp(this->X+Rand(-32,32),0,240);
							int y = Clamp(this->Y+Rand(-32,32),0,160);
							item itm1 = CreateItemAt(id,x,y);
							itm1->Pickup=IP_TIMEOUT;
						}
					}
					else if(usingBugs>0)
					{
						//UNFINISHED // Spawn Gold Skulltula
						usingBugs=0;
					}
					if(beanCounter>0)
					{
						state = SSSTATE_PLANTED;
						Game->Counter[CR_MAGICBEANS]--;
						beanCounter=0;
					}
				}
			} 
			if(state==SSSTATE_PLANTED)
			{
				this->Data = COMBO_BEANSPROUT;
				if(playedSong==SONG_SongOfStorms)
				{
					state=SSSTATE_GROWN;
				}
				else
				{
					for(int i=1; i<=Screen->NumLWeapons(); i++)
					{
						lweapon l = Screen->LoadLWeapon(i);
						if((l->ID==LW_WATER||l->ID==LW_HOTWATER)&&Collision(this, l))
						{
							state = SSSTATE_GROWN;
							break;
						}
					}
				}
			}
			if(state==SSSTATE_GROWN)
			{
				this->Data = COMBO_BEANPLANT;
				if(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8)
				{
					Link->X = this->X;
					Link->Y = this->Y;
					//if(startState==2)Waitframe();
					Rafting[RAFT_DIR] = raftDir;
					Rafting[RAFT_UP] = screensUp;
					if(startState==2)
					{
						Rafting[RAFT_X] = this->X - 5*dirX(raftDir);
						Rafting[RAFT_Y] = this->Y - 5*dirY(raftDir);
					}
					else
					{
						Rafting[RAFT_X] = -1;
						Rafting[RAFT_Y] = -1;
					}
					state = SSSTATE_ACTIVE;
					canFall=false;
					waitTime=5;
				}
			}
			if(state == SSSTATE_ACTIVE)
			{
				if(Link->Action==LA_RAFTING)
				{
					if(startState==2)
					{
						this->Data = COMBO_INVIS;
					}
					else
					{
						this->Data = COMBO_SOIL;
					}
				}
				if(waitTime>0)
				{
					waitTime--;
				}
				else if(!Link->Action==LA_RAFTING)
				{
					if(startState==SSSTATE_GROWN)
					{
						Quit();
					}
					else
					{
						state = SSSTATE_GROWN;
						Rafting[RAFT_DIR] = -1;
						Rafting[RAFT_UP] = -1;
					}
				}
				setSoilState(index,state);
			}
			Waitframe();
		}
	}
}

int getSoilCombo(int index)
{
	switch(getSoilState(index))
	{
		case SSSTATE_WAITING:
			return COMBO_SOIL;
		case SSSTATE_PLANTED:
			return COMBO_BEANSPROUT;
		case SSSTATE_GROWN:
			return COMBO_BEANPLANT;
	}
	return COMBO_INVIS;
}

item script MagicBean
{
	void run()
	{
		if(Game->Counter[CR_MAGICBEANS]>0)
			beanCounter=10;
	}
}

//end SoftSoil
//start ladder/vine
ffc script LadderClimb{
	void run(int climbtime, int dir, int floorsUp){
		int ctime = 0;
		while(true){
			if(ctime>=climbtime){
				Link->X+=dirX(dir)*16;
				Link->Y+=dirY(dir)*16;
				warpNumFloors=floorsUp;
			}
			switch(dir){
				case DIR_UP:{
					if(Link->Y==this->Y){
						if(Link->InputUp)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
				case DIR_DOWN:{
					if(Link->Y==this->Y){
						if(Link->InputDown)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
				case DIR_LEFT:{
					if(Link->X==this->X){
						if(Link->InputLeft)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
				case DIR_RIGHT:{
					if(Link->X==this->X){
						if(Link->InputRight)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
			}
		}
	}
}
//end ladder/vine
//start TorchPuzzle
//Torch puzzles!
//defNum should be a 16-bit number with the first X bits filled, where X is 16 - the total number of torches.
//thisNum should be a 16-bit number where exactly 1 bit is true, with each torch in the puzzle having a seperate bit.
//timer is the total timer for the puzzle completion.
//puzzleNum is a unique number for each puzzle
//defNum and timer and puzzleNum should be the same for all torches, thisNum should be different for every torch.
ffc script TorchPuzzle{
	void run(int thisNum, int defNum, int unlitCombo, int litCombo, int timer, int puzzleNum, bool noSecretSFX)
	{
		if(!torchPuzzleStates[puzzleNum])
		{
			bool lit = false;
			torchPuzzle[puzzleNum] |= defNum;
			if(torchPuzzle[puzzleNum] & thisNum)
			{
				this->Data = litCombo;
				lit = true;
			}
			else
			{
				this->Data = unlitCombo;
			}
			while(!torchPuzzleStates[puzzleNum])
			{
				if(!lit)
				{
					if(torchLight(this))
					{
						if(!torchPuzzleTimer)torchPuzzleTimer=timer;
						lit = true;
						this->Data = litCombo;
						torchPuzzle[puzzleNum] |= thisNum;
					}
				}
				else
				{
					stickLight(this);
					if(!torchPuzzleTimer)
					{
						lit = false;
						this->Data = unlitCombo;
						torchPuzzle[puzzleNum] = defNum;
					}
					if(torchPuzzle[puzzleNum]==1111111111111111b)
					{
						torchPuzzleStates[puzzleNum]=true;
						if(!noSecretSFX)Game->PlaySound(SFX_SECRET);
					}
				}
				Waitframe();
			}
		}
		this->Data = litCombo;
		while(true)
		{
			stickLight(this);
			Waitframe();
		}
	}
}

int getTorchCombo(int torchnum, int unlitCombo, int litCombo, int puzzleNum)
{
	if(torchPuzzleStates[puzzleNum]) return litCombo;
	return Cond((torchPuzzle[puzzleNum] & torchnum) > 0,litCombo,unlitCombo);
}

ffc script LitTorch
{
	void run(){
		while(true)
		{
			stickLight(this);
			Waitframe();
		}
	}
}

bool torchLight(ffc torch)
{
	for(int i = 1;i<=Screen->NumLWeapons();i++)
	
	{
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()&&weap->ID==LW_DEKUSTICK){
			if(!dekuStickLitTimer)continue;
			return Collision(torch, weap);
		}
		else if(weap->isValid()&&weap->ID==LW_ARROW&&arrowType==ARRTYPE_FIRE)
		{
			return Collision(torch, weap);
		}
	}
}

void stickLight(ffc torch){
	if(dekuStickLitTimer!=DEKU_MAX_TIMER){
		for(int i = 1;i<=Screen->NumLWeapons();i++){
			lweapon weap = Screen->LoadLWeapon(i);
			if(weap->isValid()&&weap->ID==LW_DEKUSTICK){
				if(Collision(torch, weap)){
					dekuStickLitTimer=DEKU_MAX_TIMER;
				}
			} else if(weap->isValid()&&weap->ID==LW_ARROW&&!arrowType){
				if(Collision(torch, weap)){
					arrowType=ARRTYPE_FIRE;
					weap->UseSprite(SPRITE_FIREARROW);
					if(weap->Dir==DIR_RIGHT){
						weap->Tile+=1;
						weap->Flip=0;
					} else if(weap->Dir==DIR_LEFT){
						weap->Tile+=1;
						weap->Flip=1;
					}
				}
			}
		}
	}
}

ffc script TorchSecrets
{
	void run(int numPuzzle)
	{
		this->Data=COMBO_INVIS;
		while(!torchPuzzleStates[numPuzzle])Waitframe();
		Screen->TriggerSecrets();
	}
}

item script dekuStick
{
	void run()
	{
		if(!Link->PressB)Quit();
		for(int i = 1;i<=Screen->NumLWeapons();i++)
		{
			lweapon weap = Screen->LoadLWeapon(i);
			if(weap->isValid()&&weap->ID==LW_DEKUSTICK)
			{
				Quit();
			}
		}
		lweapon stick = CreateLWeaponAt(LW_DEKUSTICK,Link->X+InFrontX(Link->Dir,0),Link->Y+InFrontY(Link->Dir,0));
		stick->Dir = Link->Dir;
		if(dekuStickLitTimer>0)
		{
			stick->Tile = TILE_DEKUSTICK_LIT + stick->Dir;
			stick->OriginalTile = stick->Tile;
		}
		else
		{
			stick->Tile = TILE_DEKUSTICK_UNLIT + stick->Dir;
			stick->OriginalTile = stick->Tile;
		}
		stick->Step = 0;
		stick->CollDetection = false;
		stick->DeadState = 15;
		freezeFrames+=15;
		Link->Action = LA_ATTACKING;
	}
}
//end TorchPuzzle
//start owlStatue
int owlStates = 0000000000b;
int getOwlCombo(int index)
{
	if(owlStates&Pow(2,index)) return COMBO_OWLON;
	return COMBO_OWLOFF;
}
ffc script owlStatue//start
{
	void run(int index,bool isFake)
	{
		int trueValue = Pow(2,index);
		if((owlStates & trueValue)==trueValue)
		{
			this->Data=COMBO_OWLON;
		}
		else
		{
			this->Data=COMBO_OWLOFF;
		}
		while(!isFake)
		{
			if(!form)
			{
				for(int i=0;i<countLWeaponType(LW_SWORD);i++)
				{
					lweapon weap = loadLWeaponType(LW_SWORD,i);
					if(weap->isValid()&&Collision(weap,this))
					{
						Waitframes(2);
						this->Data=COMBO_OWLON;
						owlStates|=trueValue;
						while(weap->isValid())Waitframe();
						Waitframe();
						quickSave(Game->GetCurDMapScreen(),Game->GetCurDMap());
					}
				}
			}
			Waitframe();
		}
	}
}//end
void warpToOwl(int index)//start
{
	switch(index)
	{
		case 0:
			Link->Warp(1,0x6B);
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
	}// UNFINISHED / add more owls
}//end
void quickSave(int scrn, int dmap)//start
{
	tangoTemp=false;
	ShowMessageAndWait(43);
	if(tangoTemp)
	{
		owlSaved=true;
		Game->ContinueDMap=dmap;
		Game->ContinueScreen=scrn;
		saveTheGame();
		Game->End();
	}
}//end
//end owlStatue
//start chests
ffc script chest
{
	void run(int itemID, int index, bool fake, bool killAllEnemies)
	{
		if(this->Data==COMBO_INVIS||!this->Data)this->Data=COMBO_CHEST;
		int closed = this->Data;
		int open = this->Data+1;
		if(getChestState(index))this->Data=open;
		if(killAllEnemies&&EnemiesAlive())this->Data=COMBO_INVIS;
		bool solid = (!(this->X%16)&&!(this->Y%16))&&!this->Flags[FFCF_TRANS];
		if(solid&&(!killAllEnemies||getChestState(index)))Screen->ComboD[ComboAt(this->X,this->Y)]=COMBO_SOLID;
		while(!fake)
		{
			if(getChestState(index))
			{
				this->Data=open;
				while(true)
				{
					if(!solid)ffcSolid(this);
					Waitframe();
				}
			}
			else
			{
				while(killAllEnemies&&EnemiesAlive())Waitframe();
				if(killAllEnemies)
				{
					killAllEnemies=false;
					Game->PlaySound(SFX_CHEST_APPEAR);
					this->Data=closed;
					if(solid)Screen->ComboD[ComboAt(this->X,this->Y)]=COMBO_SOLID;
				}
				if(!solid)ffcSolid(this);
				if(Link->PressA&&AgainstComboBase(this->X,this->Y))
				{
					Link->PressA=false;Link->InputA=false;
					if(Link->Item[itemID])
					{
						itemID=1;
					}
					this->Data=open;
					item itm = CreateItemAt(itemID,Link->X,Link->Y);
					itm->Pickup=IP_HOLDUP;
					setChestState(index,true);
				}
			}
			Waitframe();
		}
	}
	bool AgainstComboBase(int x, int y)
	{
		return Link->Z == 0 && ((Link->Dir == DIR_UP && Link->Y == y+8 && Abs(Link->X-x) < 8)||(Link->Dir == DIR_DOWN && Link->Y == y-16 && Abs(Link->X-x) < 8)||(Link->Dir == DIR_LEFT && Link->X == x+16 && Abs(Link->Y-y) < 8)||(Link->Dir == DIR_RIGHT && Link->X == x-16 && Abs(Link->Y-y) < 8));
    }
}

int getChestCombo(int data, int index)
{
	if(data == COMBO_INVIS || data == 0)data = COMBO_CHEST;
	if(getChestState(index))data++;
	return data;
}
//end chests

import "std.zh"
//GVARs used: 0-7 misc
//start typedefs
typedef const int GVAR;
typedef const int DEFINE;
//end typedefs

import "scripts/string.zh"
import "scripts/ffcscript.zh"
import "scripts/LinkMovement.zh"
import "tango.zh"
import "tango/font/GUI.zh"
import "tango/font/MajoraFont.zh"
import "ghost.zh"
import "scripts/TypeAString v1-1.zh"
import "scripts/Tint.zh"
//start ghost imports
import "scripts/ghost/Skulltula.z"
//end
//start GLOBAL Global
//start Ocarina Global Variables
//A combo representing the pressed button, with a transparent background
const int NOTETILE_A = 892;
const int NOTETILE_DOWN = 894;
const int NOTETILE_RIGHT = 893;
const int NOTETILE_LEFT = 895;
const int NOTETILE_UP = 896;
//The CSet to draw the given combo in
const int NOTECSET_A = 0;
const int NOTECSET_DOWN = 0;
const int NOTECSET_RIGHT = 0;
const int NOTECSET_LEFT = 0;
const int NOTECSET_UP = 0;
//The SFX id for the given note SFX (or use the default IDs, just be sure to use the same ones in ZQuest!)
int NOTESOUND_A = 200;
int NOTESOUND_DOWN = 201;
int NOTESOUND_RIGHT = 202;
int NOTESOUND_LEFT = 203;
int NOTESOUND_UP = 204;

bool DISPLAYTEXTONSONGLEARN = true;
//Sound FX to play if the played song is not a valid song
const int SFX_ERROR = 64;
//List of songs:
int SONGNOTES_SongOfTime[] = {3,1,2,3,1,2,0,0};
int SONGNOTES_EponasSong[] = {5,4,3,5,4,3,0,0};
int SONGNOTES_SongOfStorms[] = {1,2,5,1,2,5,0,0};
int SONGNOTES_GoronsLullaby[] = {1,3,4,1,3,4,3,1};
int SONGNOTES_OathToOrder[] = {3,2,1,2,3,5,0,0};
int SONGNOTES_SongOfSoaring[] = {2,4,5,2,4,5,0,0};
int SONGNOTES_SongOfHealing[] = {4,3,2,4,3,2,0,0};
int SONGNOTES_ElegyOfEmptiness[] = {3,4,3,2,3,5,4,0};
int SONGNOTES_NewWaveBossaNova[] = {4,5,4,3,2,4,3,0};
int SONGNOTES_SongOfDoubleTime[] = {3,3,1,1,2,2,0,0};
int SONGNOTES_SongOfInvertedTime[] = {2,1,3,2,1,3,0,0};
int SONGNOTES_SonataOfAwakening[] = {5,4,5,4,1,3,1,0};
int SONGNOTES_ScarecrowsSong[8];
//Add custom songs:
//Put a name directly after the underscore, and numbers for notes in each spot.
//A=1,DOWN=2,RIGHT=3,LEFT=4,UP=5, and if the song is less than 8 notes, fill the ending spots with 0s. The // before the line of code must also be removed for the song to function.
//int[] SONGNOTES_ = {,,,,,,,};
//Song indexes
const int SONG_SongOfTime = 0;
const int SONG_EponasSong = 2;
const int SONG_SongOfStorms = 4;
const int SONG_GoronsLullaby = 12;
const int SONG_OathToOrder = 13;
const int SONG_SongOfSoaring = 14;
const int SONG_SongOfHealing = 15;
const int SONG_ElegyOfEmptiness = 16;
const int SONG_NewWaveBossaNova = 17;
const int SONG_SongOfDoubleTime = 18;
const int SONG_SongOfInvertedTime = 19;
const int SONG_SonataOfAwakening = 20;
const int SONG_ScarecrowsSong = 21;
//Song MIDI IDs -- set these to the number of the MIDI you want to play, which should be the song played.
const int SONGMIDI_SongOfTime = 213;
const int SONGMIDI_EponasSong = 225;
const int SONGMIDI_SongOfStorms = 221;
const int SONGMIDI_GoronsLullaby = 237;
const int SONGMIDI_OathToOrder = 249;
const int SONGMIDI_SongOfSoaring = 229;
const int SONGMIDI_SongOfHealing = 217;
const int SONGMIDI_ElegyOfEmptiness = 245;
const int SONGMIDI_NewWaveBossaNova = 241;
const int SONGMIDI_SongOfDoubleTime = 205;
const int SONGMIDI_SongOfInvertedTime = 209;
const int SONGMIDI_SonataOfAwakening = 233;
//ScarecrowsSong has no SONGSOUND! This is intentional, though other songs should all have one!
bool LEARNED_SONGS[22];
//Constants
const int NOTE_A = 1;
const int NOTE_DOWN = 2;
const int NOTE_RIGHT = 3;
const int NOTE_LEFT = 4;
const int NOTE_UP = 5;
const int NULL_NOTE = 0;
const int FRAMESOFSONGFREEZE = 600;
//Variables
bool ocarina_mode = false;
int ocIndex = 0;
int currSong[8];
int playedSong = -1;
int songFrames = 0;
int midiToReturn = 0;
bool scarecrowMode = false;
bool scarecrowRecord = false;
bool OC_doItemJinx = false;
//end Ocarina Global Variables
//start Subscreen Global Variables
const int COMBO_FRZ1 = 13826;
const int COMBO_FRZ2 = 13827;
const int MAP_SUBSCREEN = 1;
const int SCRN_SUBSCREEN_ITEM = 48;
const int SCRN_SUBSCREEN_MAP_OVERWORLD = 96;
const int SCRN_SUBSCREEN_MAP_DUNGEON = 80;
const int SCRN_SUBSCREEN_KEY = 64;
const int TILE_REMAINS1UL = 0;
const int TILE_REMAINS2UL = 0;
const int TILE_REMAINS3UL = 0;
const int TILE_REMAINS4UL = 0;
const int CURSOR_ITEM = 45;
const int CURSOR_CSET = 5;
const int LARGE_CURSOR_ITEM = 85;
const int DMAP_TOTAL = 3;
const int I_REMAINS1 = 158;
const int I_REMAINS2 = 159;
const int I_REMAINS3 = 160;
const int I_REMAINS4 = 161;
const int I_DEKUSTICK = 138;
bool subscreen = false;
int subState = 0;
int cursorPos = 0;
int ITEM_LOCS[] = {33,34,35,36,37,38,41,42,43,44,45,46,49,50,51,52,53,54,57,58,59,60,61,62,65,66,67,68,69,70,73,74,75,76,77,78,81,82,83,84,85,86,89,90,91,92,93,94};
int KEY_LOCS[] = {27,51,52,53,54,55,57,61,67,68,69,70,71,97,99,101,103,105,91};
int QUAD_LOCS[] = {27,57,61,91};
int MAP_LOCS[] = {0};
int DUNGMAP_LOCS[] = {0};
bool DUNGEONS[] = {false,false,false,false};
//
int cursorIndex = 0;
int itemIndex = 0;
const int ITEM_MAX_INDEX = 48;
const int KEY_MAX_INDEX = 19;
const int MAP_MAX_INDEX = 0;
const int DUNGMAP_MAX_INDEX = 0;
int ItemIDs[] = {187,188,189,190,191,144,31,13,14,57,137,0,192,193,194,195,196,127,3,139,138,140,153,0,197,198,199,200,201,131,48,0,53,52,211,0,202,203,204,205,206,207,146,147,148,149,150,151};
//Passive:
const int PASSIVE_TOP = -56;
const int AX = 123;
const int AY = -27;
const int BX = 163;
const int BY = -27;
const int EX1X = 184;
const int EX1Y = -46;
const int EX2X = 205;
const int EX2Y = -27;
const int LX = 144;
const int LY = -46;
const int RX = 226;
const int RY = -46;
const int MASKX = 184;
const int MASKY = -22;
const int DAYSTART_X = 91;
const int DAYSTART_Y = -24;
const int DAYNUM_X = 112;
const int DAYNUM_Y = -24;
const int TIMESTART_X = 88;
const int TIMESTART_Y = -15;
int NumberTiles[] = {12630,12631,12632,12633,12634,12635,12636,12637,12638,12639};
const int SEMICOLON = 12612;
const int TILE_NOTE_DEFAULT = 12614;
const int TILE_DROP = 12590;
const int CSET_DROP = 0;
const int I_TAEL_1 = 212;
const int I_TAEL_2 = 213;
const int TAEL_X = 95;
const int TAEL_Y = -45;
const int CR_BOMBCHUS = 7;
const int CR_DEKUNUTS = 8;
//end Subscreen Global Variables
//start Pit Global Variables
int floating = 0;
int floatDir = 0;
bool canFall = true;
bool rafting = false;
const int CT_PITFALL = 142;//Script 1 Combo Type
const int CT_LEDGE = 143;//Script 2 Combo Type
const int SFX_JUMPING = 45;
//end Pit Global Variables
//start EX Item Button Global Variables
int EX1_item = 0;
int EX2_item = 0;
int B_item = 0;
//end EX Item Button Global Variables
//start FormVars
const int ITEM_POUND = 54;
const int ITEM_BUBBLE = 25;
const int ITEM_DEKUNUT = 140;
const int COMBO_LILYPAD = 7372;
const int SPRITE_NONE = 89;
const int MAGICCOST_SPIKEROLL = 1;
const int EVERYXFRAMES_SPIKEROLL = 10;
const int NPCMISC_LASTSPIKEHIT = 0;
const int SFX_DEKUHOP = 89;
const int SFX_GORONCURL = 65;
const int SFX_GORONUNCURL = 66;
const int SFX_DEKUDIVE = 67;
const int SFX_DEKULAUNCH = 68;
const int SFX_DEKUFLIGHT = 69;
const int SFX_DEKUSPIN = 70;
const int SFX_GORONPUNCH = 71;
const int SFX_GORONPOUND = 72;
const int SFX_GORONROLL_BEGIN = 73;
const int SFX_GORONROLL_LOOP = 74;
const int SFX_GORONROLL_SPEEDUP = 75;
const int SFX_GORONROLL_SPEEDLOOP = 76;
const int SPEEDBOOST_BUNNY_WATER = 0.51;
const int SPEEDBOOST_BUNNY_LAND = 1.02;
const int SPEEDBOOST_ZORA_WATER = 1.5;
int Deku_floating = 60;
int Deku_flying = 0;
int DekuFlightSpeedMod = -.5;
bool curled = false;
int useItem = 0;
int timeRolling = 0;
int spikeStartTime = 0;
bool spikedRolling = false;
//end FormVars
//start Rafting vars
int Rafting[4] = {-1,-1,-1,-1};
const int RAFT_DIR = 0;
const int RAFT_UP = 1;
const int RAFT_X = 2;
const int RAFT_Y = 3;
//end Rafting vars
//start Misc global vars
//start Sound Constants
const int MIDI_THESTORM = 204;
const int SFX_SHIELD = 63;
const int SFX_DEKUNUT_SNAP = 79;
const int SFX_DEKUNUT_FREEZE = 80;
//end Sound Constants
//start LayerScreens
const int LAYERSMAP1 = 2;
const int LAYERSCREEN_RAIN = 0x00; 
const int LAYERSCREEN_SAVING = 0x10;
//end LayerScreens
//start Times
const int FRAME = 0.0001;
const int FRAMES_SECOND = 1;
int FRAMES_MINUTE = 60;
int FRAMES_HOUR = 3600;
int TIME_SECOND = FRAMES_SECOND*FRAME;
int TIME_MINUTE = FRAMES_MINUTE*FRAME;
int TIME_HOUR = FRAMES_HOUR*FRAME;
//end
//start Item Constants
const int I_MASK_ALLNIGHT = 188;
const int I_BOMBBAG_BIG = 82;
const int I_QUIVER_BIG = 75;
const int I_BOMBBAG_BIGGEST = 83;
const int I_QUIVER_BIGGEST = 76;
const int I_MASK_BLAST = 189;
const int I_BOMBBAG = 81;
const int I_BOMBBAG_POWDERKEG = 106;
const int I_BOMBCHUS = 139;
const int I_BOMBS = 3;
const int I_BOWARROW = 13;
const int I_MASK_BREMEN = 193;
const int I_MASK_BUNNYHOOD = 194;
const int I_MASK_CAPTAINHAT = 205;
const int I_DEKUSPINCHARGE = 135;
const int I_MASK_CIRCUS = 198;
const int I_MASK_COUPLES = 200;
const int I_MASK_DEKU = 144;
const int I_DEKUNUTS = 140;
const int I_MASK_DONGERO = 195;
const int I_DOUBLEDEF = 208;
const int I_MASK_DEITY = 207;
const int I_FIREARROWS = 14;
const int I_FLIPPERS2 = 214;
const int I_MASK_GARO = 204;
const int I_MASK_GIANT = 206;
const int I_MASK_GIBDO = 203;
const int I_SWORD_GILDED = 7;
const int I_MASK_GORON = 127;
const int I_MASK_GFAIRY = 191;
const int I_SWORD_GFAIRY = 211;
const int I_HYLIANSHIELD = 8;
const int I_ICEARROWS = 57;
const int I_MASK_KAFEI = 199;
const int I_MASK_KAMARO = 202;
const int I_MASK_KEATON = 192;
const int I_SWORD_KOKIRI = 5;
const int I_LETTERKAFEI = 183;
const int I_LIGHTARROWS = 137;
const int I_MAGICBEANS = 153;
const int I_MASK_SCENTS = 196;
const int I_MASK_TRUTH = 201;
const int I_MIRRORSHIELD = 37;
const int I_MOONSTEAR = 178;
const int I_DEED_MOUNTAIN = 181;
const int I_OCARINA = 31;
const int I_DEED_OCEAN = 182;
const int I_PENDANTOFMEMORIES = 185;
const int I_MASK_POSTMANSHAT = 187;
const int I_POWDERKEG = 48;
const int I_QUIVER = 74;
const int I_SWORD_RAZOR = 6;
const int I_MASK_ROMANI = 197;
const int I_ROOMKEY = 186;
const int I_SPECIALDELIVERY = 184;
const int I_MASK_STONE = 190;
const int I_DEED_SWAMP = 180;
const int I_DEED_TOWN = 179;
const int I_INFMAG = 152;
const int I_MASK_ZORA = 131;
//end
//start Palette
GVAR GV_PAL = 1000;
DEFINE NUM_PAL = 4;
GVAR TINT_DAY = 0;
GVAR TINT_SUNSETORANGE = 1;
GVAR TINT_NIGHT = 2;
GVAR TINT_LENS = 3;
//end Palette
//start MISC
const int COMBO_INVIS = 4;
const int COMBO_SOLID = 38408;
const int TILE_INVIS = 5;
const int CR_MAGICBEANS = 9;
const int RAZSWORD_USES = 100;
const int RAZSWORD_ID = 6;
const int INF_MAGIC = 152;
const int DEKU_MAX_TIMER = 240;
const int ARRTYPE_FIRE = 1;
const int ARRTYPE_ICE = 2;
const int ARRTYPE_LIGHT = 3;
const int SPRITE_FIREARROW = 90;
const int FFC_SHOWSTRING = 16;
const int FFC_CHEST = 12;
const int FFC_CHANGENAME = 24;
const int FFCMISC_DRAWTRANS_COMBOSTORE = 15;
bool torchPuzzleStates[8];
int torchPuzzleTimer = 0;
int dekuStickLitTimer = 0;
int torchPuzzleState = 0000000000000000b;
int torchPuzzles = 0000000000000000b;
int swordCounter = 0;
int time = 0;
int hour = 6;
int day = 1;
int gameframe = 0;
int usingItem = 0;
bool slowTime = false;
int LinkActionOld = 0;
bool hasMirrorShield = false;
int freezeFrames = 0;
int arrowType = 0;//1=fire,2=ice,3=light
int floatPix = 2;
bool slotWasDisplayed = false;
bool pressA = false;
bool fakeSong = false;
bool hideLayer4 = false;
int lastScreen = -1;
int lastMap = -1;
int lastLevel = -1;
int lastDMap = -1;
bool songOfStormsRain = false;
bool isFrozen = false;
bool owlSaved = false;
int trueTime = 0;
bool isBottleFrozen = false;
bool tangoTemp = false;
int tangoTempI = 0;
int warpNumFloors = 0;
bool freezeTime = false;
bool debug = false;
bool dbsetup = false;
bool dbdraw = false;
bool debugEnabled = false;
//end MISC
//end Misc global vars
//start Init Script
global script Init{
	void run(){
		Game->DisableActiveSubscreen=true;
		CopyTile(TILE_INVIS,19);
		CopyTile(TILE_INVIS,39);
		Game->MCounter[CR_DEKUNUTS] = 20;
		Game->MCounter[CR_MAGICBEANS] = 20;
		Game->MCounter[CR_BANKBAL] = 5000;
		setGlobalVar(GVAR_DIFFICULTY,GV_MISC,1);
		int saveName[16];
		Game->GetSaveName(saveName);
		if(!strcmp(saveName,"Venrob"))debugEnabled=true;
		setGlobalVar(TINT_DAY,GV_PAL,createTintPalette(0,0,0));
		setGlobalVar(TINT_SUNSETORANGE,GV_PAL,createTintPalette(-3,-9,-14));
		setGlobalVar(TINT_NIGHT,GV_PAL,createTintPalette(-21,-23,-10));
		setGlobalVar(TINT_LENS,GV_PAL,createTintPalette(-17,-48,5));
	}
}
//end
//start Active Script
global script Global{
	void run(){//start mainGlobal
		bool isLensTinted = false;
		setEnterEndsTyping(true);
		setAllowBackspaceDelete(true);
		setOverflowWraps(false);
		//start init
		ClearTrace();
		TraceS("Launching TLoZ: Majora's Mask 2D...");TraceNL();
		if(Link->Item[81])Game->MCounter[CR_BOMBCHUS]=40;
		bool scrnChanged = false;
		LinkMovement_Init();
		TangoInit();
		StartGhostZH();
		//start Ocarina init
		scarecrowMode = false;
		scarecrowRecord = false;
		ocIndex = 0;
		playedSong = -1;
		songFrames = 0;
		midiToReturn = 0;
		//end Ocarina init
		subscreen = false;
		//end init
		//start Global Script Scope Vars
		lweapon zoraBoom1;
		lweapon zoraBoom2;
		//end
		//Tango_ConvertVariableName("anpc");
		//Tango_ConvertFunctionName("npcend");
		while(true){
			handleTyping();
			if(debugEnabled)testingMenu();
			//start
			if(scrnChanged){
				scrnChanged=false;
				layer4check();
			}
			if(lastMap!=Game->GetCurMap()||lastScreen!=Game->GetCurScreen()){
				scrnChanged=true;
				changedScreens();
				lastScreen = Game->GetCurScreen();
				lastMap = Game->GetCurMap();
			}
			if(lastDMap!=Game->GetCurDMap()){
				changedDMap();
				lastDMap = Game->GetCurDMap();
				if(lastLevel!=Game->GetCurLevel()){
					changedLevel();
					lastLevel = Game->GetCurLevel();
				}
			}
			layer4Toggle();
			if(subscreen){
				pressA=Link->PressA;
				Link->PressA=false;
				Link->InputA=false;
			}
			varIntegrity();
			//end
			//start FrameCounters
			if(freezeFrames>0){
				NoAction();
				freezeFrames--;
			}
			gameframe++;
			if(gameframe>=3600){
				gameframe=0;
			}//end FrameCounters
			//start Time passing
			bool timeIsNotFrozen = (!isFrozen&&(!slowTime||!(gameframe%2))&&(!ScreenFlag(SF_MISC,SFM_SCRIPT1))&&!songFrames);
			if(!freezeTime&&timeIsNotFrozen){//freezeTime is a debug, and should ONLY apply to this block, not other sections that use `timeIsNotFrozen`.
				time++;
				trueTime+= FRAME;
				if(time%FRAMES_HOUR == 0){
					hour++;
					time=0;
					if(hour>=24){
						hour-=24;
					} else if(hour==6){
						day++;
					}
				}
				if(day>3){
					destruction();
				}
				unpauseGradient();
			}
			else
			{
				pauseGradient();
			}
			//end Time Passing
			bombCheck();
			Tango_Update1();
			//start Ocarina loop
			if(songFrames>0){
				/*if(Game->CappedFPS){
					saveFPSstate();
					Game->CappedFPS=false;
				}*/
				TotalNoAction();
				ocarina_mode = false;
				Screen_Freeze(2);
				if(!fakeSong)
					drawNotes();
				songFrames--;
				if(!songFrames){
					loadFPSstate();
					if(midiToReturn!=-6&&midiToReturn<205)
						Audio->PlayMIDI(midiToReturn);
					if(!fakeSong&&playedSong>-1)
						activateSong(playedSong);
					playedSong=-1;
					fakeSong=false;
					if(!subscreen)
						Screen_Freeze(0);
				}
			} else {
				midiToReturn = Game->GetMIDI();
			}
			if(OC_doItemJinx){
				if(Link->InputB){
					Link->ItemJinx=2;
				} else {
					OC_doItemJinx=false;
				}
			}
			if(ocarina_mode){
				ocarina();
				Link->PressStart=false;
				Link->InputStart=false;
			}
			if(scarecrowRecord){
				scarecrow();
			}
			if(ocarina_mode||scarecrowRecord||songFrames>0){
				Link->CollDetection = false;
			} else {
				Link->CollDetection = true;
			}
			//end Ocarina loopz
			//start Subscreen
			if((!isFrozen||subscreen)&&Link->PressStart&&!ScreenFlag(SF_VIEW,SFV_NOSUBSCREEN)){
				toggleSubscreen();
			}
			if(subscreen){
				runSubscreen();
			}
			//end Subscreen
			//start
			if(Tango_AnySlotIsActive()){
				Screen_Freeze(1);
				slotWasDisplayed=true;
			} else if(slotWasDisplayed){
				Screen_Freeze(0);
				slotWasDisplayed=false;
			}
			Link->PressStart=false;
			Link->InputStart=false;
			razorSwordCheck();
			//transformaitons
			handleTransformations(zoraBoom1,zoraBoom2);
			if(Game->Misc[0]!=Debug->Null()){
				zoraBoom1=Game->Misc[0];
				Game->Misc[0]=Debug->Null();
			}
			if(Game->Misc[1]!=Debug->Null()){
				zoraBoom2=Game->Misc[1];
				Game->Misc[1]=Debug->Null();
			}
			//
			handleEXItems();
			handleMasks();
			//end
			if(subscreen){//start
				NoAction();
			} else if(!isFrozen){
				warpfloors();
				varDecrements();
				checkJump();
				heightWarp();
				checkFall();
				handleMeltableIce();
				handleFreezableWater();
			}//end
			//start
			LinkActionOld=Link->Action;
			raftingCheck();
			LinkMovement_Update1();
			if(!isFrozen)
				highLedgeFromWater();
			Link->PressR=false;Link->InputR=false;
			Link->PressL=false;Link->InputL=false;
			Overhead_Update();
			drawExtraLayerEffects();
			UpdateGhostZH1();
			//end
			if(UsingItem(53)&&fullCounter(CR_MAGIC)>2){
				if(!isLensTinted){
					setTint(getGlobalVar(TINT_LENS,GV_PAL),true);
					isLensTinted=true;
				}
			} else {
				if(isLensTinted){
					setTint(getGlobalVar(TINT_LENS,GV_PAL),false);
					isLensTinted=false;
				}
			}
			timePalette();
			runTints();
			Waitdraw();			
			passiveSubscreen();
			if(!isFrozen||isBottleFrozen){
				EmptyBottleGlobal();
			}
			Tango_Update2();
			UpdateGhostZH2();
			if(isFrozen)LinkMovement_SetLinkSpeedBoost(0);
			LinkMovement_Update2();
			Waitframe();
		}
	}//end mainGlobal
	//start destruction
	void destruction(){
		if(!(!Game->GetCurDMap()&&Game->GetCurScreen()==32)){
			if(subscreen){
				toggleSubscreen();
				Waitframe();
			}
			Link->Warp(0,32);
			Waitframes(2);
			int args[8];
			if(LEARNED_SONGS[SONG_SongOfTime]&&Link->Item[31]){
				args[0]=3;
			} else {
				args[0]=4;
			}
			RunFFCScript(FFC_SHOWSTRING, args);
		}
	}
	//end destruction
	//start extra
	void layer4Toggle(){
		if(Link->PressEx4){
			hideLayer4 = !hideLayer4;
			for(int i = 1;i<=32;i++){
				ffc f = Screen->LoadFFC(i);
				if(f->Flags[FFCF_OVERLAY]&&f->Flags[FFCF_TRANS]){
					if(hideLayer4){
						f->Misc[FFCMISC_DRAWTRANS_COMBOSTORE] = f->Data;
						f->Data = COMBO_INVIS;
					} else {
						f->Data = f->Misc[FFCMISC_DRAWTRANS_COMBOSTORE];
					}
				}
			}
		}
	}
	
	void layer4check(){
		if(hideLayer4){
			//Handle Screen->LayerOpacity
			for(int i = 1;i<=32;i++){
				ffc f = Screen->LoadFFC(i);
				if(f->Flags[FFCF_OVERLAY]&&f->Flags[FFCF_TRANS]){
					if(hideLayer4){
						f->Misc[FFCMISC_DRAWTRANS_COMBOSTORE] = f->Data;
						f->Data = COMBO_INVIS;
					}
				}
			}
		}
	}
	
	void drawExtraLayerEffects(){
		if(songOfStormsRain){
			Screen->DrawScreen(5,LAYERSMAP1,LAYERSCREEN_RAIN,0,0,0);
		}
		int downdmap = getDownDMap();
		int updmap = getUpDMap();
		if(downdmap>-1){
			int screen = getDownScreen(false);
			if(screen>-1){
				dmapdata ddmap = Game->LoadDMapData(downdmap);
				drawItemFromScreen(ddmap->Map,screen,2);
			}
		}
		if(updmap>-1){
			int screen = getUpScreen(false);
			if(screen>-1){
				dmapdata udmap = Game->LoadDMapData(updmap);
				drawItemFromScreen(udmap->Map,screen,4);
			}
		}
	}
	
	void drawItemFromScreen(int map, int screen, int layer){
		if(!Game->GetScreenState(map, screen, ST_ITEM)){
			mapdata m = Game->LoadMapData(map,screen);
			if(m->HasItem)
				Screen->FastTile(layer,m->ItemX,m->ItemY,loadItemTile(m->Item),loadItemTile(m->Item),OP_TRANS);
		}
	}
	
	void changedScreens(){
		songOfStormsRain = false;
		if(!floating)Link->Invisible=false;
	}
	
	void changedLevel(){
		torchPuzzleState=0;
		torchPuzzleTimer=0;
	}
	
	void changedDMap(){
		
	}
	
	void varDecrements(){
		if(usingBugs>0)usingBugs--;
		if(beanCounter>0)beanCounter--;
		if(torchPuzzleTimer>0)torchPuzzleTimer--;
		if(dekuStickLitTimer>0)dekuStickLitTimer--;
	}
	
	void varIntegrity(){
		if(floating<0)floating=0;
		if(Deku_flying<0)Deku_flying=0;
		if(Game->MCounter[CR_SBOMBS]>1)Game->MCounter[CR_SBOMBS]=1;//PATCHWORK//
		if(rafting&&Link->Action!=LA_RAFTING){
			canFall=true;
			rafting=false;
		} else if(!rafting&&Link->Action==LA_RAFTING){
			canFall=false;
			rafting=true;
		}
	}
	
	void doLensTint(){
		Graphics->Tint(-17,-48,5);
	}//end
	void raftingCheck(){//start rafting
		if(Link->Action==LA_RAFTING){
			Rafting[RAFT_DIR]=-1;
			if(Link->PressRight&&CanWalk(Link->X,Link->Y,DIR_RIGHT,16,false)){
				Link->X+=16;
				Link->Action=LA_NONE;
			} else if(Link->PressLeft&&CanWalk(Link->X,Link->Y,DIR_LEFT,16,false)){
				Link->X-=16;
				Link->Action=LA_NONE;
			} else if(Link->PressUp&&CanWalk(Link->X,Link->Y,DIR_UP,16,false)){
				Link->Y-=16;
				Link->Action=LA_NONE;
			} else if(Link->PressDown&&CanWalk(Link->X,Link->Y,DIR_DOWN,16,false)){
				Link->Y+=16;
				Link->Action=LA_NONE;
			}
		} else if(Rafting[RAFT_DIR]!=-1){
			NoAction();
			if(Rafting[RAFT_UP]>0){
				for(int i = 0;i<Rafting[RAFT_UP];Rafting[RAFT_UP]--){
					warpUp();
					//Waitframe(); //Unneeded?
				}
				Rafting[RAFT_UP]=-1;
				int args[8] = {Rafting[RAFT_DIR],0,0,2};
				Rafting[RAFT_DIR] = -1;
				Waitframe();
				RunFFCScript(SCRIPTSLOT_SOFTSOIL,args);
			} else {
				//
				Link->Dir=Rafting[RAFT_DIR];
				if(Rafting[RAFT_X]!=-1&&Rafting[RAFT_Y]!=-1&&!(gameframe%10)){
					Link->X = Rafting[RAFT_X];
					Link->Y = Rafting[RAFT_Y];
				}
				if(Rafting[RAFT_DIR]==DIR_DOWN){
					Link->PressDown=true;
					Link->InputDown=true;
				} else if(Rafting[RAFT_DIR]==DIR_RIGHT){
					Link->PressRight=true;
					Link->InputRight=true;
				} else if(Rafting[RAFT_DIR]==DIR_LEFT){
					Link->PressLeft=true;
					Link->InputLeft=true;
				} else if(Rafting[RAFT_DIR]==DIR_UP){
					Link->PressUp=true;
					Link->InputUp=true;
				}
			}
		}
	}//end rafting
	void warpfloors(){//start
		if(warpNumFloors>0){
			if(!warpUp())warpNumFloors=0;
			else warpNumFloors--;
		} else if(warpNumFloors<0){
			if(!warpDown())warpNumFloors=0;
			else warpNumFloors++;
		}
	}//end
	const int MULT_SUNRISE = 2;
	void timePalette(){//start
		if(hour>=6-MULT_SUNRISE && hour < 6)
		{
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			if(!isActiveGradient())
			{
				runGradient(getGlobalVar(TINT_NIGHT,GV_PAL),getGlobalVar(TINT_DAY,GV_PAL),FRAMES_HOUR*MULT_SUNRISE,true);
			}
		}
		else if(hour>=18-MULT_SUNRISE && hour < 18)
		{
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			if(time == 0 && hour == 18-MULT_SUNRISE)
			{
				runGradient(getGlobalVar(TINT_DAY,GV_PAL),getGlobalVar(TINT_SUNSETORANGE,GV_PAL),FRAMES_HOUR*MULT_SUNRISE/2);
			}
			
			if(!(MULT_SUNRISE%2))
			{
				if(time==0 && hour == 18-(MULT_SUNRISE/2))
				{
					runGradient(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),getGlobalVar(TINT_NIGHT,GV_PAL),1 + FRAMES_HOUR*MULT_SUNRISE/2);
				}
			}
			else
			{
				if(time==FRAMES_HOUR/2 && hour == 18-Ceiling(MULT_SUNRISE))
				{
					runGradient(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),getGlobalVar(TINT_NIGHT,GV_PAL),FRAMES_HOUR*MULT_SUNRISE/2);
				}
			}
		}
		else if(hour > 5 && hour < 18-MULT_SUNRISE)
		{
			endGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),true);
			//refreshTint();
		}
		else if(hour > 17 || hour < 6-MULT_SUNRISE)
		{
			endGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),true);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),false);
			//refreshTint();
		}
		if(isOverworldScreen())
		{
			unhideGradient();
		}
		else
		{
			hideGradient();
			setTint(getGlobalVar(TINT_NIGHT,GV_PAL),false);
			setTint(getGlobalVar(TINT_SUNSETORANGE,GV_PAL),false);
			setTint(getGlobalVar(TINT_DAY,GV_PAL),true);
		}
	}//end
	//start TestingMenu
	void testingMenu(){//start
		if(!dbsetup)debugSetup();
		if(!isFrozen){
			if(Input->ReadKey[KEY_TILDE])//Don't call ReadKey, it calls NoAction!
			{
				debug=!debug;
				//Game->TypingMode = !Game->TypingMode;
				Link->CollDetection=!debug;
				canFall=!debug;
			}
			if(debug || dbdraw)
			{
				//drawDebugInt(0,8,trueTime);
				//drawDebugInfo(B_item);
				drawDebugString(256,0,"R:   ",true);
				drawDebugString(256,6,"G:   ",true);
				drawDebugString(256,12,"B:   ",true);
				drawDebugInt(256,0,getTintVar(DATA_R_SUM),true);
				drawDebugInt(256,6,getTintVar(DATA_G_SUM),true);
				drawDebugInt(256,12,getTintVar(DATA_B_SUM),true);
			}
			if(debug)
			{
				drawDebugString(0,0,"DEBUG MODE",false);
				canFall=false;
				//Hour manipulation
				if(Input->ReadKey[KEY_UP])
				{
					hour++;
					trueTime+=3600*FRAME;
					if(hour>23)
					{
						hour-=24;
					}
					if(hour==6)
					{
						day++;
						if(day>3)
						{
							day-=3;
							trueTime-=(3600*24*FRAME);
							trueTime-=(3600*24*FRAME);
							trueTime-=(3600*24*FRAME);
						}
					}
				}
				if(Input->ReadKey[KEY_DOWN])
				{
					hour--;
					trueTime-=3600*FRAME;
					if(hour<0)
					{
						hour+=24;
					}
					if(hour==5)
					{
						day--;
						if(day<1)
						{
							day+=3;
							trueTime+=(3600*24*FRAME);
							trueTime+=(3600*24*FRAME);
							trueTime+=(3600*24*FRAME);
						}
					}
				}
				//Day manipulation
				if(Input->ReadKey[KEY_RIGHT])
				{
					day++;
					trueTime+=(3600*24*FRAME);
					if(day>3)
					{
						day-=3;
						trueTime-=(3600*24*FRAME);
						trueTime-=(3600*24*FRAME);
						trueTime-=(3600*24*FRAME);
					}
				}
				if(Input->ReadKey[KEY_LEFT])
				{
					day--;
					trueTime-=(3600*24*FRAME);
					if(day<1)
					{
						day+=3;
						trueTime+=(3600*24*FRAME);
						trueTime+=(3600*24*FRAME);
						trueTime+=(3600*24*FRAME);
					}
				}
				if(Input->ReadKey[KEY_EQUALS])//Refill Ammo
				{
					Game->Counter[CR_BOMBS]=Game->MCounter[CR_BOMBS];
					Game->Counter[CR_RUPEES]=Game->MCounter[CR_RUPEES];
					Game->Counter[CR_ARROWS]=Game->MCounter[CR_ARROWS];
					Game->Counter[CR_SBOMBS]=Game->MCounter[CR_SBOMBS];
					Game->Counter[CR_BOMBCHUS]=Game->MCounter[CR_BOMBCHUS];
					Game->Counter[CR_DEKUNUTS]=Game->MCounter[CR_DEKUNUTS];
					Game->Counter[CR_MAGICBEANS]=Game->MCounter[CR_MAGICBEANS];
					Game->DCounter[CR_BOMBS]=0;
					Game->DCounter[CR_RUPEES]=0;
					Game->DCounter[CR_ARROWS]=0;
					Game->DCounter[CR_SBOMBS]=0;
					Game->DCounter[CR_BOMBCHUS]=0;
					Game->DCounter[CR_DEKUNUTS]=0;
					Game->DCounter[CR_MAGICBEANS]=0;
				}
				if(Input->ReadKey[KEY_ENTER])//Freeze time
				{
					freezeTime=!freezeTime;
					slowTime=freezeTime;
				}
				if(Input->ReadKey[KEY_0])Link->Warp(0,0x24);//Warp to test area
				if(Input->ReadKey[KEY_R])Link->PitWarp(Game->GetCurDMap(),Game->GetCurDMapScreen());//Reset the screen by pitwarping to it
				if(Input->ReadKey[KEY_BACKSLASH])dbdraw = !dbdraw;
				NoAction();
				Link->PressStart=false;Link->InputStart=false;
			}
		}
	}//end
	
	void debugSetup(){//start
		dbsetup=true;
		Game->Cheat=4;
		for(int i = 0;i<22;i++){
			LEARNED_SONGS[i]=true;
		}
		for(int i=0;i<48;i++){
			if(ItemIDs[i]!=0)Link->Item[ItemIDs[i]]=true;
		}
		//bbags
		Link->Item[81]=true;
		Link->Item[82]=true;
		Link->Item[83]=true;
		Link->Item[106]=true;
		//quivs
		Link->Item[74]=true;
		Link->Item[75]=true;
		Link->Item[76]=true;
		Game->MCounter[CR_LIFE]=320;
		Game->MCounter[CR_MAGIC]=256;
		Game->Counter[CR_LIFE]=320;
		Game->Counter[CR_MAGIC]=256;
		Game->MCounter[CR_BOMBCHUS]=40;
		Game->MCounter[CR_ARROWS]=50;
		Game->MCounter[CR_BOMBS]=40;
		Game->MCounter[CR_SBOMBS]=1;
		//extra
		form=0;
		mask=12;
		currMaskTile=FIRST_MASK_TILE+12;
		HMS_visible=true;
		CS1_seen=true;
	}//end
	
	void drawDebugInfo(int itID){//start
		if(itID!=0){
			int str[256];
			itemdata theItem = Game->LoadItemData(itID);
			theItem->GetName(str);
			drawDebugString(256,0,str,true);
		}
		if(itID>=146&&itID<=151){//BottleDebugger
			int str[256];
			int bstate = getBottleState(itID-145);
			getBottleStateName(bstate,str);
			drawDebugString(256,8,str,true);
			if(bstate==BS_HOTWATER)drawDebugInt(240,16,springTimers[itID-146]);
		}
	}//end
	
	//start dbDrawFuncs
	void drawDebugString(int x, int y, int str,bool right){
		int format = TF_NORMAL;
		if(right)format = TF_RIGHT;
		Screen->DrawString(7,x,y,FONT_Z3SMALL,0x01,0x00,format,str,OP_OPAQUE);
	}
	
	void drawDebugInt(int x, int y, int num, bool right){
		if(right)x-=Cond(num<0,4,0) + Cond(num<10 && num > -10,4,Cond(num<100&&num>-100,8,Cond(num<1000&&num>-1000,12,16)));
		Screen->DrawInteger(7,x,y,FONT_Z3SMALL,0x01,0x00,0,0,num,0,OP_OPAQUE);
	}
	
	void drawDebugInt(int x, int y, int num){
		drawDebugInt(x,y,num,false);
	}//end
	//end TestingMenu
}
//end Global Script
//start OnContinue Script
global script onFileLoad{
	void run(){
		if(owlSaved){
			owlSaved=false;
			Game->ContinueDMap=0;
			Game->ContinueScreen=0;
			Game->Save();
		} else {
			Link->Warp(0,0);
			resetTime();
			Game->ContinueDMap=0;
			Game->ContinueScreen=0;
			Game->Save();
		}
		tintOnContinue();
	}
}//end
//start OnExit Script
global script onExit
{
	void run()
	{
	
	}
}
//end OnExit Script
//end Global
//start time funcs
bool isAfter(int aday, int anhour, bool equal){
	return (day>aday)||(aday==day&&(hourconv(hour)>hourconv(anhour)||(equal&&hourconv(anhour)==hourconv(hour))));
}

bool isBefore(int aday, int anhour, bool equal){
	return (day<aday)||(aday==day&&(hourconv(hour)<hourconv(anhour)||(equal&&hourconv(anhour)==hourconv(hour))));
}

bool isBetween(int startHour, int endHour, bool eqStart, bool eqEnd){
	int trueHour = hourconv(hour);
	int trueStart = hourconv(startHour);
	int trueEnd = hourconv(endHour);
	return (trueHour>trueStart&&trueHour<trueEnd)||(eqStart&&trueHour==trueStart)||(eqEnd&&trueHour==trueEnd);
}

bool isBetween(int startHour, int endHour){
	isBetween(startHour,endHour,true,false);
}

int hourconv(int hr){
	hr-=6;
	if(hr<0)hr+=24;
	return hr;
}

bool isDay(){
	return (hour>=6&&hour<18);
}
//end time
//start GlobalScopeFunctions
void resetTime(){//start OnTimeReset
	time=0;
	trueTime=0;
	hour=6;
	day=1;
	slowTime = false;
	Game->Counter[CR_LIFE] = Game->MCounter[CR_LIFE];
	Game->Counter[CR_MAGIC] = Game->MCounter[CR_MAGIC];
	Game->Counter[CR_BOMBS]=0;
	Game->Counter[CR_RUPEES]=0;
	Game->Counter[CR_ARROWS]=0;
	Game->Counter[CR_SBOMBS]=0;
	Game->Counter[CR_BOMBCHUS]=0;
	Game->Counter[CR_DEKUNUTS]=0;
	Game->Counter[CR_MAGICBEANS]=0;
	swordCounter = 0;
	Link->Item[RAZSWORD_ID]=false;
	Link->Item[INF_MAGIC]=false;
	for(int i=0;i<6;i++){
		BottleState[i]=BS_EMPTY;
	}
	RefreshBottles();
	for(int i = GVAR_START_RESET;i<GVAR_END_RESET;i++){
		setGlobalVar(i,0,0);
	}
}//end

GVAR GVAR_DIFFICULTY = 7;

void updateDifficulty(int dif){
	switch(dif){
		case 0:{
			FRAMES_MINUTE=90*FRAMES_SECOND;
			setGlobalVar(GVAR_DIFFICULTY,GV_MISC,0);
			updateTimes();
			break;}
		case 1:{
			FRAMES_MINUTE=60*FRAMES_SECOND;
			setGlobalVar(GVAR_DIFFICULTY,GV_MISC,1);
			updateTimes();
			break;}
		case 2:{
			FRAMES_MINUTE=45*FRAMES_SECOND;
			setGlobalVar(GVAR_DIFFICULTY,GV_MISC,2);
			updateTimes();
			break;}
	}
}

void updateTimes(){
	FRAMES_HOUR = 60*FRAMES_MINUTE;
	TIME_MINUTE = FRAMES_MINUTE*FRAME;
	TIME_HOUR = FRAMES_HOUR*FRAME;
	TIME_HOTWATER = TIME_HOUR*4;
}
//end GlobalScopeFunctions
//start Ocarina
void ocarina(){//start ocMode
	if(Link->PressA){
		currSong[ocIndex] = NOTE_A;
		Game->PlaySound(NOTESOUND_A);
		ocIndex++;
	} else if(Link->PressDown) {
		currSong[ocIndex] = NOTE_DOWN;
		Game->PlaySound(NOTESOUND_DOWN);
		ocIndex++;
	} else if(Link->PressRight) {
		currSong[ocIndex] = NOTE_RIGHT;
		Game->PlaySound(NOTESOUND_RIGHT);
		ocIndex++;
	} else if(Link->PressLeft) {
		currSong[ocIndex] = NOTE_LEFT;
		Game->PlaySound(NOTESOUND_LEFT);
		ocIndex++;
	} else if(Link->PressUp) {
		currSong[ocIndex] = NOTE_UP;
		Game->PlaySound(NOTESOUND_UP);
		ocIndex++;
	} else if(Link->PressB){
		playedSong = -1;
		songFrames = 0;
		ocarina_mode = false;
		OC_doItemJinx = true;
	}
	
	if(ocIndex!=8 && ocIndex>0 && playSong(currSong)){
		for(;ocIndex<8;ocIndex++){}
		NoAction();
		ocarina_mode = false;
	} else if (ocIndex==8){
		if(playSong(currSong)){
			ocarina_mode = false;
		} else {
			ocarina_mode = false;
			Game->PlaySound(SFX_ERROR);
			playedSong = -1;
		}
	}
	drawNotes();
	NoAction();
}//end ocMode
void drawNotes(){//start
	//Border ripped from renameLink
	const int BORDERTILE = 11196;
	const int FIRSTX = 64;
	const int FIRSTY = 48;
	Screen->FastTile(6,FIRSTX-16,FIRSTY-16,BORDERTILE,2,OP_OPAQUE);
	Screen->FastTile(6,FIRSTX-16,FIRSTY,BORDERTILE+20,2,OP_OPAQUE);
	Screen->FastTile(6,FIRSTX-16,FIRSTY+16,BORDERTILE+40,2,OP_OPAQUE);
	for(int i = FIRSTX; i <= FIRSTX+(16*7); i+=16)
	{
		Screen->FastTile(6,i,FIRSTY-16,BORDERTILE+1,2,OP_OPAQUE);
		Screen->FastTile(6,i,FIRSTY,BORDERTILE+1+20,2,OP_OPAQUE);
		Screen->FastTile(6,i,FIRSTY+16,BORDERTILE+1+40,2,OP_OPAQUE);
	}
	Screen->FastTile(6,FIRSTX+(16*7)+16,FIRSTY-16,BORDERTILE+2,2,OP_OPAQUE);
	Screen->FastTile(6,FIRSTX+(16*7)+16,FIRSTY,BORDERTILE+2+20,2,OP_OPAQUE);
	Screen->FastTile(6,FIRSTX+(16*7)+16,FIRSTY+16,BORDERTILE+2+40,2,OP_OPAQUE);
	//
	for(int note=0;note<8;note++){
		if(!currSong[note]){
			Screen->FastCombo(6,FIRSTX+(16*note),FIRSTY,0,0,128); //Why draw an invisible combo?
		} else if(currSong[note]==1){
			Screen->FastTile(6,FIRSTX+(16*note),FIRSTY,NOTETILE_A,NOTECSET_A,128);
		} else if(currSong[note]==2){
			Screen->FastTile(6,FIRSTX+(16*note),FIRSTY,NOTETILE_DOWN,NOTECSET_DOWN,128);
		} else if(currSong[note]==3){
			Screen->FastTile(6,FIRSTX+(16*note),FIRSTY,NOTETILE_RIGHT,NOTECSET_RIGHT,128);
		} else if(currSong[note]==4){
			Screen->FastTile(6,FIRSTX+(16*note),FIRSTY,NOTETILE_LEFT,NOTECSET_LEFT,128);
		} else if(currSong[note]==5){
			Screen->FastTile(6,FIRSTX+(16*note),FIRSTY,NOTETILE_UP,NOTECSET_UP,128);
		}
	}
}//end
bool playSong(int song){//start SongFrames
	int midiAdd = Clamp(form,0,3);
	if(LEARNED_SONGS[SONG_SongOfTime] && compareSongs(song,SONGNOTES_SongOfTime)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_SongOfTime);
		playedSong=SONG_SongOfTime;
		songFrames = 580;//
		return true;
	} else if(LEARNED_SONGS[SONG_EponasSong] && compareSongs(song,SONGNOTES_EponasSong)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_EponasSong);
		playedSong=SONG_EponasSong;
		songFrames = 435;//
		return true;
	} else if(LEARNED_SONGS[SONG_SongOfStorms] && compareSongs(song,SONGNOTES_SongOfStorms)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_SongOfStorms);
		playedSong=SONG_SongOfStorms;
		songFrames = 290;//
		return true;
	} else if(LEARNED_SONGS[SONG_GoronsLullaby] && compareSongs(song,SONGNOTES_GoronsLullaby)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_GoronsLullaby);
		playedSong=SONG_GoronsLullaby;
		songFrames = 430;//
		return true;
	} else if(LEARNED_SONGS[SONG_OathToOrder] && compareSongs(song,SONGNOTES_OathToOrder)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_OathToOrder);
		playedSong=SONG_OathToOrder;
		songFrames = 440;//
		return true;
	} else if(LEARNED_SONGS[SONG_SongOfSoaring] && compareSongs(song,SONGNOTES_SongOfSoaring)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_SongOfSoaring);
		playedSong=SONG_SongOfSoaring;
		songFrames = 200;//
		return true;
	} else if(LEARNED_SONGS[SONG_SongOfHealing] && compareSongs(song,SONGNOTES_SongOfHealing)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_SongOfHealing);
		playedSong=SONG_SongOfHealing;
		songFrames = 445;//
		return true;
	} else if(LEARNED_SONGS[SONG_ElegyOfEmptiness] && compareSongs(song,SONGNOTES_ElegyOfEmptiness)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_ElegyOfEmptiness);
		playedSong=SONG_ElegyOfEmptiness;
		songFrames = 395;//
		return true;
	} else if(LEARNED_SONGS[SONG_NewWaveBossaNova] && compareSongs(song,SONGNOTES_NewWaveBossaNova)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_NewWaveBossaNova);
		playedSong=SONG_NewWaveBossaNova;
		songFrames = 333;//
		return true;
	} else if(LEARNED_SONGS[SONG_SongOfDoubleTime] && compareSongs(song,SONGNOTES_SongOfDoubleTime)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_SongOfDoubleTime);
		playedSong=SONG_SongOfDoubleTime;
		songFrames = 427;//
		return true;
	} else if(LEARNED_SONGS[SONG_SongOfInvertedTime] && compareSongs(song,SONGNOTES_SongOfInvertedTime)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_SongOfInvertedTime);
		playedSong=SONG_SongOfInvertedTime;
		songFrames = 555;//
		return true;
	} else if(LEARNED_SONGS[SONG_SonataOfAwakening] && compareSongs(song,SONGNOTES_SonataOfAwakening)){
		Audio->PlayMIDI(midiAdd+SONGMIDI_SonataOfAwakening);
		playedSong=SONG_SonataOfAwakening;
		songFrames = 335;//
		return true;
	} else if(LEARNED_SONGS[SONG_ScarecrowsSong] && compareSongs(song,SONGNOTES_ScarecrowsSong)){
		for(int note = 0;note<8;note++){
			if(!song[note]){
				return false;
			}
		}
		playedSong=SONG_ScarecrowsSong;
		songFrames = 20;
		return true;
	}
	return false;
}//end
void activateSong(int song){//start Song Functions
	if(song==SONG_SongOfTime){
		tangoTemp=false;
		int args[8] = {44,1};
		RunFFCScript(FFC_SHOWSTRING,args);
	} else if(song==SONG_EponasSong){
		//INSERT CODE/Do something here when Epona's Song is played!
	} else if(song==SONG_SongOfStorms){
		if(!(DUNGEONS[Game->GetCurDMap()]||ScreenFlag(SF_ROOMTYPE,SFR_INTERIOR)||ScreenFlag(SF_ROOMTYPE,SFR_DUNGEON))){
			Audio->PlayMIDI(MIDI_THESTORM);
			songOfStormsRain=true;
		}
	} else if(song==SONG_GoronsLullaby){
		//INSERT CODE/Do something here when Goron's Lullaby is played!
	} else if(song==SONG_OathToOrder){
		//INSERT CODE/Do something here when Oath to Order is played!
	} else if(song==SONG_SongOfSoaring){
		if(owlStates==0){
		
		} else {
		
		}
	} else if(song==SONG_SongOfHealing){
		//INSERT CODE//Do something here when Song of Healing is played!
	} else if(song==SONG_ElegyOfEmptiness){
		//INSERT CODE//Do something here when Elegy of Emptiness is played!
	} else if(song==SONG_NewWaveBossaNova){
		//INSERT CODE//Do something here when New Wave Bossa Nova is played!
	} else if(song==SONG_SongOfDoubleTime){
		tangoTemp=false;
		int args[8] = {47,2};
		RunFFCScript(FFC_SHOWSTRING,args);
	} else if(song==SONG_SongOfInvertedTime){
		tangoTemp=false;
		int args[8] = {46,3};
		RunFFCScript(FFC_SHOWSTRING,args);
	} else if(song==SONG_SonataOfAwakening){
		//INSERT CODE//Do something here when Sonata of Awakening is played!
	} else if(song==SONG_ScarecrowsSong){
		//INSERT CODE//Do something here when Scarecrow's Song is played!
	}
}//end
bool compareSongs(int song, int song2){//start
	for(int note=0;note<8;note++){
		if(song[note]!=song2[note]){
			return false;
		}
	}
	return true;
}//end
void scarecrow(){//start
	if(Link->PressA){
		currSong[ocIndex] = NOTE_A;
		Game->PlaySound(NOTESOUND_A);
		ocIndex++;
	} else if(Link->PressDown) {
		currSong[ocIndex] = NOTE_DOWN;
		Game->PlaySound(NOTESOUND_DOWN);
		ocIndex++;
	} else if(Link->PressRight) {
		currSong[ocIndex] = NOTE_RIGHT;
		Game->PlaySound(NOTESOUND_RIGHT);
		ocIndex++;
	} else if(Link->PressLeft) {
		currSong[ocIndex] = NOTE_LEFT;
		Game->PlaySound(NOTESOUND_LEFT);
		ocIndex++;
	} else if(Link->PressUp) {
		currSong[ocIndex] = NOTE_UP;
		Game->PlaySound(NOTESOUND_UP);
		ocIndex++;
	} else if(Link->PressB){
		playedSong = -1;
		songFrames = 10;
		scarecrowRecord = false;
	}
	if(ocIndex==8){
		if(!isValidSong(currSong,false)){
			for(int note=0;note<8;note++){
				SONGNOTES_ScarecrowsSong[note]=currSong[note];
			}
		} else {
			Game->PlaySound(SFX_ERROR);
		}
		scarecrowRecord = false;
	}
	drawNotes();
	NoAction();
}//end
bool isValidSong(int song, bool reqLearned){//start
	if(reqLearned){
		if(LEARNED_SONGS[SONG_SongOfTime] && compareSongs(song,SONGNOTES_SongOfTime)){
			return true;
		} else if(LEARNED_SONGS[SONG_EponasSong] && compareSongs(song,SONGNOTES_EponasSong)){
			return true;
		} else if(LEARNED_SONGS[SONG_SongOfStorms] && compareSongs(song,SONGNOTES_SongOfStorms)){
			return true;
		} else if(LEARNED_SONGS[SONG_GoronsLullaby] && compareSongs(song,SONGNOTES_GoronsLullaby)){
			return true;
		} else if(LEARNED_SONGS[SONG_OathToOrder] && compareSongs(song,SONGNOTES_OathToOrder)){
			return true;
		} else if(LEARNED_SONGS[SONG_SongOfSoaring] && compareSongs(song,SONGNOTES_SongOfSoaring)){
			return true;
		} else if(LEARNED_SONGS[SONG_SongOfHealing] && compareSongs(song,SONGNOTES_SongOfHealing)){
			return true;
		} else if(LEARNED_SONGS[SONG_ElegyOfEmptiness] && compareSongs(song,SONGNOTES_ElegyOfEmptiness)){
			return true;
		} else if(LEARNED_SONGS[SONG_NewWaveBossaNova] && compareSongs(song,SONGNOTES_NewWaveBossaNova)){
			return true;
		} else if(LEARNED_SONGS[SONG_SongOfDoubleTime] && compareSongs(song,SONGNOTES_SongOfDoubleTime)){
			return true;
		} else if(LEARNED_SONGS[SONG_SongOfInvertedTime] && compareSongs(song,SONGNOTES_SongOfInvertedTime)){
			return true;
		} else if(LEARNED_SONGS[SONG_SonataOfAwakening] && compareSongs(song,SONGNOTES_SonataOfAwakening)){
			return true;
		}
	} else {
		if(compareSongs(song,SONGNOTES_SongOfTime)){
			return true;
		} else if(compareSongs(song,SONGNOTES_EponasSong)){
			return true;
		} else if(compareSongs(song,SONGNOTES_SongOfStorms)){
			return true;
		} else if(compareSongs(song,SONGNOTES_GoronsLullaby)){
			return true;
		} else if(compareSongs(song,SONGNOTES_OathToOrder)){
			return true;
		} else if(compareSongs(song,SONGNOTES_SongOfSoaring)){
			return true;
		} else if(compareSongs(song,SONGNOTES_SongOfHealing)){
			return true;
		} else if(compareSongs(song,SONGNOTES_ElegyOfEmptiness)){
			return true;
		} else if(compareSongs(song,SONGNOTES_NewWaveBossaNova)){
			return true;
		} else if(compareSongs(song,SONGNOTES_SongOfDoubleTime)){
			return true;
		} else if(compareSongs(song,SONGNOTES_SongOfInvertedTime)){
			return true;
		} else if(compareSongs(song,SONGNOTES_SonataOfAwakening)){
			return true;
		}
	}	
	return false;
}//end
//end Ocarina
//start ITEM misc
item script giveAnother{
	void run(int it1, int it2, int it3, int it4, int it5,int it6,int it7, int it8){
		Link->Item[it1] = true;
		Link->Item[it2] = true;
		Link->Item[it3] = true;
		Link->Item[it4] = true;
		Link->Item[it5] = true;
		Link->Item[it6] = true;
		Link->Item[it7] = true;
		Link->Item[it8] = true;
	}
}

item script addCounterMax{
	void run(int cr, int add, int max, int cr2, int add2, int max2){
		Game->MCounter[cr]+=add;
		if(Game->MCounter[cr]>max)Game->MCounter[cr]=max;
		Game->MCounter[cr2]+=add2;
		if(Game->MCounter[cr2]>max2)Game->MCounter[cr2]=max2;
	}
}
//end ITEM misc
//start EX Items DEPENDENCY Subscreen
void handleEXItems(){
	if(!subscreen){
		if(useItem>0){
			Link->ItemJinx=0;
			if(SetBItem(useItem)){
				Link->PressB = true;
				Link->InputB = true;
				useItem = 0;
				usingItem = useItem;
			} else {
				Link->InputB=false;Link->PressB=false;
			}
		} else if(Link->InputB&&B_item!=0){
			if(isArrow(B_item)&&!canShootArrow()){
				Link->InputB=false;Link->PressB=false;
			} else if(SetBItem(B_item)){
				Link->InputB = true;
				Link->InputEx1=false;
				Link->InputEx2=false;
			} else {
				Link->InputB=false;Link->PressB=false;
			}
		} else if(Link->InputEx1&&EX1_item!=0){
			if(isArrow(EX1_item)&&!canShootArrow()){
				Link->InputB=false;Link->PressB=false;
			} else if(SetBItem(EX1_item)){
				Link->InputB = true;
				if(Link->PressEx1)Link->PressB = true;
				Link->InputEx2=false;
			} else {
				Link->InputB=false;Link->PressB=false;
			}
		} else if(Link->InputEx2&&EX2_item!=0){
			if(isArrow(EX2_item)&&!canShootArrow()){
				Link->InputB=false;Link->PressB=false;
			} else if(SetBItem(EX2_item)){
				Link->InputB = true;
				if(Link->PressEx2)Link->PressB = true;
			} else {
				Link->InputB=false;Link->PressB=false;
			}
		} else if((Link->PressB||Link->InputB)&&!B_item){
			Link->InputB=false;Link->PressB=false;
		}
		
	} else if(subState == SUBSTATE_ITEMS && (!Link->InputEx3&&(Link->PressEx1||Link->PressEx2||Link->PressB||pressA))){
		int itID = ItemIDs[cursorIndex];
		if(canEquip(itID)){
			if(itID==211){
				if(!form&&pressA){
					Link->Item[210] = !Link->Item[210];
					Game->PlaySound(83);
				}
			} else if(!pressA){
				bool arrow = isArrow(itID);
				int snd = 83;
				switch(itID){
					case 14:{snd=84;break;}
					case 57:{snd=85;break;}
					case 137:{snd=86;break;}
				}
				Audio->EndSound(83);
				Audio->EndSound(84);
				Audio->EndSound(85);
				Audio->EndSound(86);
				if(Link->PressEx1){
					Game->PlaySound(snd);
					EX1_item = itID;
					if(EX2_item==itID||(isArrow(EX2_item)&&arrow))EX2_item=0;
					if(B_item==itID||(isArrow(B_item)&&arrow))B_item=0;
				} else if(Link->PressEx2){
					Game->PlaySound(snd);
					EX2_item = itID;
					if(EX1_item==itID||(isArrow(EX1_item)&&arrow))EX1_item=0;
					if(B_item==itID||(isArrow(B_item)&&arrow))B_item=0;
				} else if(Link->PressB){
					Game->PlaySound(snd);
					B_item = itID;
					SetBItem(itID);
					if(EX1_item==itID||(isArrow(EX1_item)&&arrow))EX1_item=0;
					if(EX2_item==itID||(isArrow(EX2_item)&&arrow))EX2_item=0;
				}
			}
		}
	} else {
		if(Link->PressB)B_item=0;
		if(Link->PressEx1)EX1_item=0;
		if(Link->PressEx2)EX2_item=0;
	}
	
}

bool isArrow(int itID){
	return (itID==13||itID==14||itID==57||itID==137);
}

bool canShootArrow(){
	return (!countLWeaponType(LW_ARROW))&&Game->Counter[CR_ARROWS];
}

bool SetBItem(int itemID){
	/*if(force)Link->SetItemSlot(itemID,0,0);
	else Link->SetItemSlot(itemID,0,1);
	return GetEquipmentB()==itemID;
	*/
	int oldId = GetEquipmentB();
	int i = 0;
	while(Link->Item[itemID]&&GetEquipmentB()!=itemID&&i<100){
		Link->SelectBWeapon(DIR_RIGHT); i++;
	}
	if(i>=100){
		i = 0;
		while(Link->Item[oldId]&&GetEquipmentB()!=oldId&&i<100){
			Link->SelectBWeapon(DIR_RIGHT); i++;
		}
	}
	return GetEquipmentB()==itemID;
}

bool canEquip(int itID){
	if(itID==3||itID==139){
		return Link->Item[81];
	} else if(itID==48){
		return Link->Item[106];
	} else {
		return Link->Item[itID];
	}
}
//end EX Items
//start Height
//Uses script placed flags 1-2 (inherent are ignored, only placed matter)
//98 = Warp up
//99 = Warp down
const int CF_UP = 108;
const int CF_DOWN = 109;
//For the DMap equivalent to the array index, what DMap is "above" this? -1 for "this is the top"
int DMAP_UP[] = {1,2,-1,-1};
//For the DMap equivalent to the array index, what DMap is "below" this? -1 for "this is the bottom"
int DMAP_DOWN[] = {-1,0,1,-1};
void heightWarp(){
	if(isCenteredOnPlacedFlag(CF_DOWN,true,false,CT_WATER,false,true,CF_SCRIPT1)){
		if(!floating&&!Deku_flying&&canFall){
			warpDown();
		}
	} else if(isCenteredOnPlacedFlag(CF_UP,true,false,CT_WATER,false,true,CF_SCRIPT1)){
		if(warpUp()){
			if(floating)floating=1;
			Deku_flying=0;
		}
	}
}

bool warpUp(){
	int dmap = getUpDMap();
	if(dmap!=-1){
		int scr = getUpScreen(true);
		Link->PitWarp(dmap,scr);
		return true;
	}
	return false;
}

bool warpDown(){
	int dmap = getDownDMap();
	if(dmap!=-1){
		int scr = getDownScreen(true);
		Link->PitWarp(dmap,scr);
		return true;
	}
	return false;
}

int getDownDMap(){
	if(GetCurDMap() >= SizeOfArray(DMAP_DOWN))return -1;
	return DMAP_DOWN[Game->GetCurDMap()];
}

int getDownScreen(bool mod){
	int dmap = getDownDMap();
	if(dmap==-1)return -1;
	if(mod)
		return MapToDMap(Screen->LayerScreen(3),dmap);
	return Screen->LayerScreen(3);
}

int getUpDMap(){
	if(GetCurDMap() >= SizeOfArray(DMAP_UP))return -1;
	return DMAP_UP[Game->GetCurDMap()];
}

int getUpScreen(bool mod){
	int dmap = getUpDMap();
	if(dmap==-1)return -1;
	if(mod)
		return MapToDMap(Screen->LayerScreen(4),dmap);
	return Screen->LayerScreen(4);
}

bool isCenteredOnPlacedFlag(int flag, bool notType, bool yesType, int type, bool notInherent, bool yesInherent, int inherent){
	int x = Link->X;
	int y = Link->Y;
	int c1 = ComboAt(Link->X+2,Link->Y+9);
	int c2 = ComboAt(Link->X+12,Link->Y+9);
	int c3 = ComboAt(Link->X+12,Link->Y+12);
	int c4 = ComboAt(Link->X+2,Link->Y+12);
	if(notType){
		if(notInherent){
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]!=inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]!=inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]!=inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]!=inherent);
		} else if(yesInherent){
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]==inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]==inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]==inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]==inherent);
		} else {
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type);
		}
	} else if(yesType){
		if(notInherent){
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]!=inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]!=inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]!=inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]!=inherent);
		} else if(yesInherent){
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]!=type&&Screen->ComboI[c1]==inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]!=type&&Screen->ComboI[c2]==inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]!=type&&Screen->ComboI[c3]==inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]!=type&&Screen->ComboI[c4]==inherent);
		} else {
			return (Screen->ComboF[c1]==flag&&Screen->ComboT[c1]==type)&&(Screen->ComboF[c2]==flag&&Screen->ComboT[c2]==type)&&(Screen->ComboF[c3]==flag&&Screen->ComboT[c3]==type)&&(Screen->ComboF[c4]==flag&&Screen->ComboT[c4]==type);
		}
	} else {
		if(notInherent){
			return (Screen->ComboF[c1]==flag&&Screen->ComboI[c1]!=inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboI[c2]!=inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboI[c3]!=inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboI[c4]!=inherent);
		} else if(yesInherent){
			return (Screen->ComboF[c1]==flag&&Screen->ComboI[c1]==inherent)&&(Screen->ComboF[c2]==flag&&Screen->ComboI[c2]==inherent)&&(Screen->ComboF[c3]==flag&&Screen->ComboI[c3]==inherent)&&(Screen->ComboF[c4]==flag&&Screen->ComboI[c4]==inherent);
		} else {
			return Screen->ComboF[c1]==flag&&Screen->ComboF[c2]==flag&&Screen->ComboF[c3]==flag&&Screen->ComboF[c4]==flag;
		}
	}
}

bool isTouchingComboType(int combotype){
	int x = Link->X;
	int y = Link->Y;
	if(Screen->ComboT[ComboAt(Link->X,Link->Y+8)]==combotype)return true;
	if(Screen->ComboT[ComboAt(Link->X+15,Link->Y+8)]==combotype)return true;
	if(Screen->ComboT[ComboAt(Link->X,Link->Y+15)]==combotype)return true;
	if(Screen->ComboT[ComboAt(Link->X+15,Link->Y+15)]==combotype)return true;
	return false;
}
//end Height
//start FallDown DEPENDENCY Height
void checkFall(){
	if(!floating&&!Deku_flying&&canFall&&Link->Action!=LA_RAFTING){
		linkPitfall();
	}
}

void linkPitfall(){
	int dmap = getDownDMap();
	int scr = getDownScreen(true);
	if(!(dmap==-1||scr==-1)){
		int combosAt[] = {ComboAt(Link->X+3,Link->Y+9),ComboAt(Link->X+12,Link->Y+9),ComboAt(Link->X+3,Link->Y+12),ComboAt(Link->X+12,Link->Y+12)};
		for(int i = 0;i<4;i++){
			if(Screen->ComboT[combosAt[i]]==CT_PITFALL){
				int dir = Link->Dir;
				//
				Link->X=ComboX(combosAt[i]);
				Link->Y=ComboY(combosAt[i]);
				//
				if(Link->X<16)Link->X+=2;
				else if(Link->X>16*14)Link->X-=2;
				if(Link->Y<16)Link->Y+=2;
				else if(Link->Y>16*9)Link->Y-=2;
				//
				freezeFrames=5;
				//
				Link->PitWarp(dmap,scr);
				//
				/*int msg[] = "Pitwarping! Dmap, Scr:";
				TraceS(msg);
				Trace(dmap);
				Trace(scr);*/
				//
				Link->Dir=dir;
			}
		}
	}
}
//end FallDown
//start Jump DEPENDENCY FallDown
void checkJump(){
	if(form!=2){
		if(canFall&&!floating&&!Deku_flying){
			int jumpDir = wouldJump();
			if(jumpDir!=-1){
				floatDir = jumpDir;
				setFloating();
				canFall=false;
			}
		}
	} else if(!floating&&form==2){
		rampJump();
	}
	jump();
}

void setFloating(){
	bool sfx = true;
	floating = getFloating();
	if(floating==-1)return;
	if(!floating)sfx = false;
	floatPix=2;
	if(sfx)
		Game->PlaySound(SFX_JUMPING);
}

int getFloating(){
	if(!form || form==4){
		if(mask==12)return 32;
		return 24;
	} else if(form==1){
		return 16;
	} else if(form==3){
		return 32;
	} else if(form==2){
		return 0;
	}
	return -1;
}

void jump(){//start jump
	if(floating!=0){
		if(floating>0){
			int movPix = floatPix;
			if(LinkOnFlagMod(CF_SCRIPT20,dirX(floatDir)*floatPix,(dirY(floatDir)*floatPix),2,false)){
				movPix=0;
			}
			Link->X+=dirX(floatDir)*movPix;
			Link->Y+=dirY(floatDir)*movPix;
			floating--;
		}
		if(floating<=0){
			if(floatDir==DIR_DOWN||floatDir==DIR_UP){
				Link->Y=GridY(Link->Y+12);
			} else if(floatDir==DIR_RIGHT||floatDir==DIR_LEFT){
				Link->X=GridX(Link->X+8);
			}
			int timeOut = 25;//Prevent infinite loop
			int jumpDir = wouldJump();
			while(jumpDir!=-1&&timeOut>0){
				if(jumpDir==DIR_DOWN)Link->Y--;
				if(jumpDir==DIR_RIGHT)Link->X--;
				if(jumpDir==DIR_LEFT)Link->X++;
				if(jumpDir==DIR_UP)Link->Y++;
				jumpDir=wouldJump();
				timeOut--;
			}
			canFall=true;
			Link->Invisible=false;
			floating=0;
		} else {
			//Draw Link's jumping tile over him, with a Y-Offset based on how far through the jump he is, peaking at the middle.
			int maxFloating = getFloating();
			if(curled){
				maxFloating=getRampFloat();
			}
			maxFloating*=floatPix;
			int yOffSet = (floating*floatPix) - (maxFloating/2);
			if(yOffSet>0)yOffSet*=-1;
			yOffSet += (maxFloating/2);	
			yOffSet *= -1;
			yOffSet /= 2;//Reduce the absurdity of the height
			//Trace(yOffSet);
			replaceLinkTile(40,3,6,0,yOffSet,true);
			//
			if(!form){
				NoActionButA();
			} else {
				NoAction();
			}
		}
	}
}//end jump
//start tilemods
const int TILE_LINKUL = 10400;
const int TILE_LINKSHADOW = 10453;

void replaceLinkTile(int mod, int aframes, int aspeed,int xOffSet,int yOffSet,bool drawShadow){
	aframes = Max(aframes,1);aspeed = Max(aspeed,1);
	Link->Invisible=true;
	int linkTile = TILE_LINKUL+mod;
	linkTile+=Link->Dir*aframes;
	linkTile+=Floor((gameframe%(aframes*aspeed))/aspeed);
	linkTile+=getLinkTileModifier();
	if(drawShadow){
		Screen->FastTile(1,Link->X,Link->Y,TILE_LINKSHADOW,6,OP_TRANS);
	}
	Screen->FastTile(1,Link->X+xOffSet,Link->Y+yOffSet,linkTile,6,OP_OPAQUE);
}

int getLinkTileModifier(){
	if(Link->Item[FORM1])return GetLinkTileModifier(FORM1);
	else if(Link->Item[FORM2])return GetLinkTileModifier(FORM2);
	else if(Link->Item[FORM3])return GetLinkTileModifier(FORM3);
	else if(Link->Item[FORM4])return GetLinkTileModifier(FORM4);
	else if(Link->Item[FORM2CURLED])return GetLinkTileModifier(FORM2CURLED);
	else if(Link->Item[FORM_SHIELD])return GetLinkTileModifier(FORM_SHIELD);
	else if(Link->Item[FORM_M_SHIELD])return GetLinkTileModifier(FORM_M_SHIELD);
	else if(Link->Item[FORM2SPIKED])return GetLinkTileModifier(FORM2SPIKED);
	else return 0;
}//end tilemods

int wouldJump(){//start
	int linkCombo = ComboAt(Link->X+8,Link->Y+12);
	int linkPlacedFlag = Screen->ComboF[linkCombo];
	if(Screen->ComboI[linkCombo]==CF_SCRIPT1&&Screen->ComboT[linkCombo]!=CT_WATER){
		if(Link->Dir==DIR_DOWN&&Link->InputDown&&linkPlacedFlag==CF_SCRIPT1&&linkCombo!=ComboAt(Link->X+8,Link->Y+16)){
			return DIR_DOWN;
		} else if(Link->Dir==DIR_RIGHT&&Link->InputRight&&linkPlacedFlag==CF_SCRIPT2&&linkCombo!=ComboAt(Link->X+16,Link->Y+12)){
			return DIR_RIGHT;
		} else if(Link->Dir==DIR_LEFT&&Link->InputLeft&&linkPlacedFlag==CF_SCRIPT3&&linkCombo!=ComboAt(Link->X-1,Link->Y+12)){
			return DIR_LEFT;
		} else if(Link->Dir==DIR_UP&&Link->InputUp&&linkPlacedFlag==CF_SCRIPT4&&linkCombo!=ComboAt(Link->X+8,Link->Y+7)){
			return DIR_UP;
		} else if(Link->Dir==DIR_DOWN&&Link->InputDown&&(Screen->ComboF[linkCombo]==CF_SCRIPT7||Screen->ComboF[linkCombo]==CF_SCRIPT5||Screen->ComboF[linkCombo]==CF_SCRIPT13)&&linkCombo!=ComboAt(Link->X+8,Link->Y+16)){
			return DIR_DOWN;
		} else if(Link->Dir==DIR_RIGHT&&Link->InputRight&&(Screen->ComboF[linkCombo]==CF_SCRIPT5||Screen->ComboF[linkCombo]==CF_SCRIPT6||Screen->ComboF[linkCombo]==CF_SCRIPT14)&&linkCombo!=ComboAt(Link->X+16,Link->Y+12)){
			return DIR_RIGHT;
		} else if(Link->Dir==DIR_LEFT&&Link->InputLeft&&(Screen->ComboF[linkCombo]==CF_SCRIPT8||Screen->ComboF[linkCombo]==CF_SCRIPT7||Screen->ComboF[linkCombo]==CF_SCRIPT14)&&linkCombo!=ComboAt(Link->X-1,Link->Y+12)){
			return DIR_LEFT;
		} else if(Link->Dir==DIR_UP&&Link->InputUp&&(Screen->ComboF[linkCombo]==CF_SCRIPT6||Screen->ComboF[linkCombo]==CF_SCRIPT8||Screen->ComboF[linkCombo]==CF_SCRIPT13)&&linkCombo!=ComboAt(Link->X+8,Link->Y+7)){
			return DIR_UP;
		}
	}
	return -1;
}//end
//start RampJump
void rampJump(){
	if(curled&&timeRolling>=100){
		int downCombo = ComboAt(Link->X+8,Link->Y+15);
		int rightCombo = ComboAt(Link->X+15,Link->Y+12);
		int leftCombo = ComboAt(Link->X,Link->Y+12);
		int upCombo = ComboAt(Link->X+8,Link->Y+8);
		if(Link->Dir==DIR_DOWN&&Screen->ComboT[downCombo]==CT_LEDGE&&Screen->ComboI[downCombo]==CF_SCRIPT2&&Screen->ComboS[downCombo]==1010b){
			floatDir=DIR_DOWN;
			Link->Y=ComboY(downCombo);
			setRampFloat();
			rampWarpUp(downCombo);
		} else if(Link->Dir==DIR_RIGHT&&Screen->ComboT[rightCombo]==CT_LEDGE&&Screen->ComboI[rightCombo]==CF_SCRIPT2&&Screen->ComboS[rightCombo]==1100b){
			floatDir=DIR_RIGHT;
			Link->X=ComboX(rightCombo);
			setRampFloat();
			rampWarpUp(rightCombo);
		} else if(Link->Dir==DIR_LEFT&&Screen->ComboT[leftCombo]==CT_LEDGE&&Screen->ComboI[leftCombo]==CF_SCRIPT2&&Screen->ComboS[leftCombo]==0011b){
			floatDir=DIR_LEFT;
			Link->X=ComboX(leftCombo);
			setRampFloat();
			rampWarpUp(leftCombo);
		} else if(Link->Dir==DIR_UP&&Screen->ComboT[upCombo]==CT_LEDGE&&Screen->ComboI[upCombo]==CF_SCRIPT2&&Screen->ComboS[upCombo]==0101b){
			floatDir=DIR_UP;
			Link->Y=ComboY(upCombo);
			setRampFloat();
			rampWarpUp(upCombo);
		}
	}
}

void setRampFloat(){
	if(spikedRolling){
		floatPix=8;
	} else {
		floatPix=4;
	}
	floating=getRampFloat();
}

int getRampFloat(){
	if(spikedRolling){
		return 16;
	} else {
		return 20;
	}
}

void rampWarpUp(int theCombo){
	if(Screen->ComboF[theCombo]==CF_SCRIPT1){
		warpUp();
	} else if(Screen->ComboF[theCombo]==CF_SCRIPT2){
		if(warpUp()){
			Waitframe();
			warpUp();
		}
	}
}
//end RampJump
//end Jump
//start Subscreen / UNFINISHED /
void toggleSubscreen(){//start
	subscreen=!subscreen;
	if(subscreen){
		Screen_Freeze(2);
		Game->PlaySound(81);
	} else {
		Screen_Freeze(0);
		Game->PlaySound(82);
		hideItemCaption();
	}
}//end
	
const int SUBSTATE_ITEMS = 0;
const int SUBSTATE_KEY = 1;
const int SUBSTATE_MAP = 2;

void runSubscreen(){
	subscreenCursorChanged = false;
	bool dungeon = false;
	if(Game->GetCurDMap()<DMAP_TOTAL){
		dungeon = DUNGEONS[Game->GetCurDMap()];
	}
	//start SwapScreen
	int lastSubState = subState;
	if(Link->PressR){
		subState++;
		if(subState>2){
			subState = 0;
		}
		cursorPos = 0;
	} else if(Link->PressL){
		subState--;
		if(subState<0){
			subState = 2;
		}
		cursorPos = 0;
	}
	if(!cursorPos){
		if(subState == SUBSTATE_ITEMS){
			cursorPos = ITEM_LOCS[6];
			cursorIndex = 6;
		} else if(subState==SUBSTATE_KEY){
			cursorPos = KEY_LOCS[1];
			cursorIndex = 1;
		} else if(subState==SUBSTATE_MAP){
			if(dungeon){
				cursorPos = DUNGMAP_LOCS[0];
				cursorIndex = 0;
			} else {
				cursorPos = MAP_LOCS[0];
				cursorIndex = 0;
			}
		}
	}
	if(subState!=lastSubState){
		subscreenCursorChanged = true;
	}
	//end SwapScreen
	//start MoveCursor
	int lastIndex = cursorIndex;
	if(!subState){
		if(Link->PressDown){
			cursorIndex+=12;
		} else if(Link->PressUp){
			cursorIndex-=12;
		} else if(Link->PressRight){
			cursorIndex++;
		} else if(Link->PressLeft){
			cursorIndex--;
		}
		if(cursorIndex>=ITEM_MAX_INDEX){
			cursorIndex-=ITEM_MAX_INDEX;
		} else if(cursorIndex<0){
			cursorIndex+=ITEM_MAX_INDEX;
		}
		cursorPos = ITEM_LOCS[cursorIndex];
	} else if(subState==1){
		if(Link->PressDown){
			if(!cursorIndex)cursorIndex=18;
			else if(cursorIndex>=1&&cursorIndex<=5)cursorIndex+=7;
			else if(cursorIndex==6)cursorIndex=17;
			else if(cursorIndex==7)cursorIndex=18;
			else if(cursorIndex==8||cursorIndex==9)cursorIndex=14;
			else if(cursorIndex==10)cursorIndex=15;
			else if(cursorIndex==11||cursorIndex==12)cursorIndex=16;
			else if(cursorIndex==13||cursorIndex==14)cursorIndex=1;
			else if(cursorIndex==15)cursorIndex=3;
			else if(cursorIndex==16)cursorIndex=5;
			else if(cursorIndex==17)cursorIndex=6;
			else if(cursorIndex==18)cursorIndex=0;
		} else if(Link->PressUp){
			if(!cursorIndex)cursorIndex=18;
			else if(cursorIndex>=8&&cursorIndex<=12)cursorIndex-=7;
			else if(cursorIndex==6)cursorIndex=17;
			else if(cursorIndex==7)cursorIndex=0;
			else if(cursorIndex==1||cursorIndex==2)cursorIndex=14;
			else if(cursorIndex==3)cursorIndex=15;
			else if(cursorIndex==4||cursorIndex==5)cursorIndex=16;
			else if(cursorIndex==13)cursorIndex=1;
			else if(cursorIndex==14)cursorIndex=8;
			else if(cursorIndex==15)cursorIndex=10;
			else if(cursorIndex==16)cursorIndex=12;
			else if(cursorIndex==17)cursorIndex=6;
			else if(cursorIndex==18)cursorIndex=0;
		} else if(Link->PressRight){
			if(cursorIndex==12){
				cursorIndex=6;
			}else if(cursorIndex==7){
				cursorIndex=13;
			} else {
				cursorIndex++;
			}
			if(cursorIndex>=KEY_MAX_INDEX){
				cursorIndex=0;
			}
		} else if(Link->PressLeft){
			if(cursorIndex==13){
				cursorIndex=7;
			} else {
				cursorIndex--;
			}
			if(cursorIndex<0){
				cursorIndex=KEY_MAX_INDEX-1;
			}
		}
		cursorPos = KEY_LOCS[cursorIndex];
	} else if(subState==2){
		if(dungeon){
		
		} else {
		
		}
	}
	if(cursorIndex!=lastIndex){
		Game->PlaySound(5);
		subscreenCursorChanged = true;
	}
	//end MoveCursor
	int cursorRow = locToRow(cursorPos);
	int cursorCol = locToCol(cursorPos);
	//start DrawThings
	int itemDescStr[512];
	if(!subState){
		drawBase(SCRN_SUBSCREEN_ITEM);
		//start Draw Item Screen
		//start Masks
		if(Link->Item[187]){//Postman's Hat
			drawTileToLoc(loadItemTile(187),loadItemCSet(187),2,1,6);
		}
		if(Link->Item[188]){//All-Night Mask
			drawTileToLoc(loadItemTile(188),loadItemCSet(188),2,2,6);
		}
		if(Link->Item[189]){//Blast Mask
			drawTileToLoc(loadItemTile(189),loadItemCSet(189),2,3,6);
		}
		if(Link->Item[190]){//Stone Mask
			drawTileToLoc(loadItemTile(190),loadItemCSet(190),2,4,6);
		}
		if(Link->Item[191]){//Great Fairy's Mask
			drawTileToLoc(loadItemTile(191),loadItemCSet(191),2,5,6);
		}
		if(Link->Item[144]){//Deku Mask
			drawTileToLoc(loadItemTile(144),loadItemCSet(144),2,6,6);
		}
		if(Link->Item[192]){//Keaton's Mask
			drawTileToLoc(loadItemTile(192),loadItemCSet(192),3,1,6);
		}
		if(Link->Item[193]){//Bremen Mask
			drawTileToLoc(loadItemTile(193),loadItemCSet(193),3,2,6);
		}
		if(Link->Item[194]){//Bunny Hood
			drawTileToLoc(loadItemTile(194),loadItemCSet(194),3,3,6);
		}
		if(Link->Item[195]){//Don Gero's Mask
			drawTileToLoc(loadItemTile(195),loadItemCSet(195),3,4,6);
		}
		if(Link->Item[196]){//Mask of Scents
			drawTileToLoc(loadItemTile(196),loadItemCSet(196),3,5,6);
		}
		if(Link->Item[127]){//Goron Mask
			drawTileToLoc(loadItemTile(127),loadItemCSet(127),3,6,6);
		}
		if(Link->Item[197]){//Romani's Mask
			drawTileToLoc(loadItemTile(197),loadItemCSet(197),4,1,6);
		}
		if(Link->Item[198]){//Circus Leader's Mask
			drawTileToLoc(loadItemTile(198),loadItemCSet(198),4,2,6);
		}
		if(Link->Item[199]){//Kafei's Mask
			drawTileToLoc(loadItemTile(199),loadItemCSet(199),4,3,6);
		}
		if(Link->Item[200]){//Couple's Mask
			drawTileToLoc(loadItemTile(200),loadItemCSet(200),4,4,6);
		}
		if(Link->Item[201]){//Mask of Truth
			drawTileToLoc(loadItemTile(201),loadItemCSet(201),4,5,6);
		}
		if(Link->Item[131]){//Zora Mask
			drawTileToLoc(loadItemTile(131),loadItemCSet(131),4,6,6);
		}
		if(Link->Item[202]){//Kamaro's Mask
			drawTileToLoc(loadItemTile(202),loadItemCSet(202),5,1,6);
		}
		if(Link->Item[203]){//Gibdo Mask
			drawTileToLoc(loadItemTile(203),loadItemCSet(203),5,2,6);
		}
		if(Link->Item[204]){//Garo Mask
			drawTileToLoc(loadItemTile(204),loadItemCSet(204),5,3,6);
		}
		if(Link->Item[205]){//Captain's Hat
			drawTileToLoc(loadItemTile(205),loadItemCSet(205),5,4,6);
		}
		if(Link->Item[206]){//Giant's Mask
			drawTileToLoc(loadItemTile(206),loadItemCSet(206),5,5,6);
		}
		if(Link->Item[207]){//Fierce Deity's Mask
			drawTileToLoc(loadItemTile(207),loadItemCSet(207),5,6,6);
		}
		//end Masks
		//start Items
		if(Link->Item[31]){//Ocarina of Time
			drawTileToLoc(loadItemTile(31),loadItemCSet(31),2,9,6);
		}
		if(Link->Item[13]){//Arrow
			drawTileToLoc(loadItemTile(13),loadItemCSet(13),2,10,6);
		}
		if(Link->Item[14]){//Fire Arrow
			drawTileToLoc(loadItemTile(14),loadItemCSet(14),2,11,6);
		}
		if(Link->Item[57]){//Ice Arrow
			drawTileToLoc(loadItemTile(57),loadItemCSet(57),2,12,6);
		}
		if(Link->Item[137]){//Light Arrow
			drawTileToLoc(loadItemTile(137),loadItemCSet(137),2,13,6);
		}
		if(Link->Item[81]){//Bombs (item is 3 for bombs and 139 for bombchus, check is for bomb bag)
			drawTileToLoc(loadItemTile(3),loadItemCSet(3),3,9,6);
			drawTileToLoc(loadItemTile(139),loadItemCSet(139),3,10,6);
		}
		if(Link->Item[I_DEKUSTICK]){//Deku Stick
			int tile = loadItemTile(138);
			if(dekuStickLitTimer>0)tile+=20;
			drawTileToLoc(tile,loadItemCSet(138),3,11,6);
		}
		if(Link->Item[140]){//Deku Nut
			drawTileToLoc(loadItemTile(140),loadItemCSet(140),3,12,6);
		}
		if(Link->Item[153]){//Magic Bean
			drawTileToLoc(loadItemTile(153),loadItemCSet(153),3,13,6);
		}
		if(Link->Item[106]){//Powder Keg (item is 48,check is for bomb bag)
			drawTileToLoc(loadItemTile(48),loadItemCSet(48),4,9,6);
		}
		if(Link->Item[53]){//Lens of Truth
			drawTileToLoc(loadItemTile(53),loadItemCSet(53),4,11,6);
		}
		if(Link->Item[52]){//Hookshot
			drawTileToLoc(loadItemTile(52),loadItemCSet(52),4,12,6);
		}
		if(Link->Item[211]){//GFSword
			drawTileToLoc(loadItemTile(211),loadItemCSet(211),4,13,6);
		}
		//
		if(Link->Item[146]){
			drawTileToLoc(loadItemTile(146),loadItemCSet(146),5,9,6);
		}
		if(Link->Item[147]){
			drawTileToLoc(loadItemTile(147),loadItemCSet(147),5,10,6);
		}
		if(Link->Item[148]){
			drawTileToLoc(loadItemTile(148),loadItemCSet(148),5,11,6);
		}
		if(Link->Item[149]){
			drawTileToLoc(loadItemTile(149),loadItemCSet(149),5,12,6);
		}
		if(Link->Item[150]){
			drawTileToLoc(loadItemTile(150),loadItemCSet(150),5,13,6);
		}
		if(Link->Item[151]){
			drawTileToLoc(loadItemTile(151),loadItemCSet(151),5,14,6);
		}
		//
		if(hasQuestItem(1)>0){
			int qit = getQuestItem(1,0);
			drawTileToLoc(loadItemTile(qit),loadItemCSet(qit),2,14,6);
			if(cursorIndex==11){
				itemdata theItem = Game->LoadItemData(qit);
				theItem->GetName(itemDescStr);
			}
		}
		if(hasQuestItem(2)>0){
			int qit = getQuestItem(2,0);
			drawTileToLoc(loadItemTile(qit),loadItemCSet(qit),3,14,6);
			if(cursorIndex==23){
				itemdata theItem = Game->LoadItemData(qit);
				theItem->GetName(itemDescStr);
			}
		}
		if(hasQuestItem(3)>0){
			int qit = getQuestItem(3,0);
			drawTileToLoc(loadItemTile(qit),loadItemCSet(qit),4,14,6);
			if(cursorIndex==35){
				itemdata theItem = Game->LoadItemData(qit);
				theItem->GetName(itemDescStr);
			}
		}
		//
		//end Items
		//CURSOR:
		drawTileToLoc(loadItemTile(CURSOR_ITEM),loadItemCSet(CURSOR_ITEM),cursorRow,cursorCol,6);
		//Equipping of items is handled in //EX_ITEMS//
		int itOnCursor = ItemIDs[cursorIndex];
		if(itOnCursor!=0&&canEquip(itOnCursor)){
			if(itOnCursor>=146&&itOnCursor<=151){
				getBottleStateName(getBottleState(itOnCursor-145),itemDescStr);
			} else {
				itemdata theItem = Game->LoadItemData(itOnCursor);
				theItem->GetName(itemDescStr);
			}
		}
		//end Draw Item Screen
	} else if(subState==1){
		drawBase(SCRN_SUBSCREEN_KEY);
		//start Draw Key Screen
		int cursorNotes[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
		if(Link->Item[31]){//start songs
			if(LEARNED_SONGS[SONG_SongOfTime]){
				drawTileToLoc(TILE_NOTE_DEFAULT,0,3,3,6);
				cursorNotes[1]=SONGNOTES_SongOfTime;
				if(cursorIndex==1){
					int cpystr[] = "Song of Time";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_SongOfTime);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_SongOfHealing]){
				drawTileToLoc(TILE_NOTE_DEFAULT,0,3,4,6);
				cursorNotes[2]=SONGNOTES_SongOfHealing;
				if(cursorIndex==2){
					int cpystr[] = "Song of Healing";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_SongOfHealing);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_SongOfStorms]){
				drawTileToLoc(TILE_NOTE_DEFAULT,0,3,5,6);
				cursorNotes[3]=SONGNOTES_SongOfStorms;
				if(cursorIndex==3){
					int cpystr[] = "Song of Storms";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_SongOfStorms);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_EponasSong]){
				drawTileToLoc(TILE_NOTE_DEFAULT,0,3,6,6);
				cursorNotes[4]=SONGNOTES_EponasSong;
				if(cursorIndex==4){
					int cpystr[] = "Epona's Song";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_EponasSong);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_SongOfSoaring]){
				drawTileToLoc(TILE_NOTE_DEFAULT,0,3,7,6);
				cursorNotes[5]=SONGNOTES_SongOfSoaring;
				if(cursorIndex==5){
					int cpystr[] = "Song of Soaring";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_SongOfSoaring);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_SonataOfAwakening]){
				drawTileToLoc(TILE_NOTE_DEFAULT+1,0,4,3,6);
				cursorNotes[8]=SONGNOTES_SonataOfAwakening;
				if(cursorIndex==8){
					int cpystr[] = "Sonata Of Awakening";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_SonataOfAwakening);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_GoronsLullaby]){
				drawTileToLoc(TILE_NOTE_DEFAULT+2,0,4,4,6);
				cursorNotes[9]=SONGNOTES_GoronsLullaby;
				if(cursorIndex==9){
					int cpystr[] = "Goron's Lullaby";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_GoronsLullaby);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_NewWaveBossaNova]){
				drawTileToLoc(TILE_NOTE_DEFAULT+3,0,4,5,6);
				cursorNotes[10]=SONGNOTES_NewWaveBossaNova;
				if(cursorIndex==10){
					int cpystr[] = "New Wave Bossa Nova";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_NewWaveBossaNova);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_ElegyOfEmptiness]){
				drawTileToLoc(TILE_NOTE_DEFAULT+4,0,4,6,6);
				cursorNotes[11]=SONGNOTES_ElegyOfEmptiness;
				if(cursorIndex==11){
					int cpystr[] = "Elegy Of Emptiness";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_ElegyOfEmptiness);
						playedSong=-1;
					}
				}
			}
			if(LEARNED_SONGS[SONG_OathToOrder]){
				drawTileToLoc(TILE_NOTE_DEFAULT+5,0,4,7,6);
				cursorNotes[12]=SONGNOTES_OathToOrder;
				if(cursorIndex==12){
					int cpystr[] = "Oath To Order";
					strcpy(itemDescStr,cpystr);
					if(pressA){
						fakeSong = true;
						playSong(SONGNOTES_OathToOrder);
						playedSong=-1;
					}
				}
			}
		}//end songs
		if(Link->Item[76]){
			drawTileToLoc(loadItemTile(76),loadItemCSet(76),6,7,6);
			if(cursorIndex==16){
				itemdata theItem = Game->LoadItemData(76);
				theItem->GetName(itemDescStr);
			}
		} else if(Link->Item[75]){
			drawTileToLoc(loadItemTile(75),loadItemCSet(75),6,7,6);
			if(cursorIndex==16){
				itemdata theItem = Game->LoadItemData(75);
				theItem->GetName(itemDescStr);
			}
		} else if(Link->Item[13]){//Check is for Arrows
			drawTileToLoc(loadItemTile(74),loadItemCSet(74),6,7,6);
			if(cursorIndex==16){
				itemdata theItem = Game->LoadItemData(74);
				theItem->GetName(itemDescStr);
			}
		}
		if(Link->Item[83]){
			drawTileToLoc(loadItemTile(83),loadItemCSet(83),6,5,6);
			if(cursorIndex==15){
				itemdata theItem = Game->LoadItemData(83);
				theItem->GetName(itemDescStr);
			}
		} else if(Link->Item[82]){
			drawTileToLoc(loadItemTile(82),loadItemCSet(82),6,5,6);
			if(cursorIndex==15){
				itemdata theItem = Game->LoadItemData(82);
				theItem->GetName(itemDescStr);
			}
		} else if(Link->Item[81]){
			drawTileToLoc(loadItemTile(81),loadItemCSet(81),6,5,6);
			if(cursorIndex==15){
				itemdata theItem = Game->LoadItemData(81);
				theItem->GetName(itemDescStr);
			}
		}
		if(Link->Item[7]){
			drawTileToLoc(loadItemTile(7),loadItemCSet(7),6,1,6);
			if(cursorIndex==13){
				itemdata theItem = Game->LoadItemData(7);
				theItem->GetName(itemDescStr);
			}
		} else if(Link->Item[6]){
			drawTileToLoc(loadItemTile(6),loadItemCSet(6),6,1,6);
			if(cursorIndex==13){
				itemdata theItem = Game->LoadItemData(6);
				theItem->GetName(itemDescStr);
			}
		} else {
			drawTileToLoc(loadItemTile(5),loadItemCSet(5),6,1,6);
			if(cursorIndex==13){
				itemdata theItem = Game->LoadItemData(5);
				theItem->GetName(itemDescStr);
			}
		}
		if(hasMirrorShield){
			drawTileToLoc(loadItemTile(37),loadItemCSet(37),6,3,6);
			if(cursorIndex==14){
				itemdata theItem = Game->LoadItemData(37);
				theItem->GetName(itemDescStr);
			}
		} else {
			drawTileToLoc(loadItemTile(8),loadItemCSet(8),6,3,6);
			if(cursorIndex==14){
				itemdata theItem = Game->LoadItemData(8);
				theItem->GetName(itemDescStr);
			}
		}
		if(Link->Item[I_REMAINS1]){
			
			if(!cursorIndex){
				itemdata theItem = Game->LoadItemData(I_REMAINS1);
				theItem->GetName(itemDescStr);
			}
		}
		if(Link->Item[I_REMAINS2]){
			
			if(cursorIndex==6){
				itemdata theItem = Game->LoadItemData(I_REMAINS2);
				theItem->GetName(itemDescStr);
			}
		}if(Link->Item[I_REMAINS3]){
			
			if(cursorIndex==7){
				itemdata theItem = Game->LoadItemData(I_REMAINS3);
				theItem->GetName(itemDescStr);
			}
		}if(Link->Item[I_REMAINS4]){
			
			if(cursorIndex==18){
				itemdata theItem = Game->LoadItemData(I_REMAINS4);
				theItem->GetName(itemDescStr);
			}
		}
		drawTileToLoc(64640 + (Game->Generic[GEN_HEARTPIECES]),0,6,9,6);
		if(cursorIndex==17){
			if(!Game->Generic[GEN_HEARTPIECES]){
				int cpystr[] = "Heart Pieces";
				strcpy(itemDescStr,cpystr);
			} else if(Game->Generic[GEN_HEARTPIECES]==1){
				int cpystr[] = "Piece of Heart";
				strcpy(itemDescStr,cpystr);
			} else if(Game->Generic[GEN_HEARTPIECES]==2){
				int cpystr[] = "2 Pieces of Heart";
				strcpy(itemDescStr,cpystr);
			} else if(Game->Generic[GEN_HEARTPIECES]==3){
				int cpystr[] = "3 Pieces of Heart";
				strcpy(itemDescStr,cpystr);
			}
		}
		//Draw song notes
		if(cursorNotes[cursorIndex]!=0){
			int notes = cursorNotes[cursorIndex];
			for(int i = 0;i<8;i++){
				int note_tile = noteToTile(notes[i]);
				int note_cset = noteToCSet(notes[i]);
				drawTileToLoc(note_tile,note_cset,1,1+i,6);
			}
		}
		//CURSOR:
		bool large = false;
		for(int i = 0;i<4;i++){
			if(cursorPos==QUAD_LOCS[i]){
				large = true;
			}
		}
		if(large){
			drawTileToLoc(loadItemTile(LARGE_CURSOR_ITEM),loadItemCSet(LARGE_CURSOR_ITEM),cursorRow,cursorCol,6);
			drawTileToLoc(loadItemTile(LARGE_CURSOR_ITEM)+20,loadItemCSet(LARGE_CURSOR_ITEM),cursorRow,cursorCol+1,6);
			drawTileToLoc(loadItemTile(LARGE_CURSOR_ITEM)+40,loadItemCSet(LARGE_CURSOR_ITEM),cursorRow+1,cursorCol+1,6);
			drawTileToLoc(loadItemTile(LARGE_CURSOR_ITEM)+60,loadItemCSet(LARGE_CURSOR_ITEM),cursorRow+1,cursorCol,6);
		} else {
			drawTileToLoc(loadItemTile(CURSOR_ITEM),loadItemCSet(CURSOR_ITEM),cursorRow,cursorCol,6);
		}
		//end Draw Key Screen
	} else if(subState==2){
		if(dungeon){
			drawBase(SCRN_SUBSCREEN_MAP_DUNGEON);
		//start Draw Dungeon Map
		
		//end Draw Dungeon Map
		} else {
			drawBase(SCRN_SUBSCREEN_MAP_OVERWORLD);
		//start Draw Overworld Map
		
		//end Draw Overworld Map
		}
	}
	showItemCaption(itemDescStr);
	//end DrawThings
}

void passiveSubscreen(){//start PassiveSubscreen
	//Inventory
	int A_tile = TILE_INVIS;
	int R_tile = TILE_INVIS;
	int A_cset = 0;
	int R_cset = 0;
	int L_tile = TILE_INVIS;
	int L_cset = 0;
	int RUPEE_tile = 60;
	int RUPEE_cset = 5;
	if(Link->Item[42]){
		RUPEE_cset = 1;
	} else if(Link->Item[41]){
		RUPEE_cset = 0;
	}
	if(!form||form==4){
		A_tile = loadItemTile(Link->ItemA);
		A_cset = loadItemCSet(Link->ItemA);
		if(form==4||!Link->Item[210]){
			if(hasMirrorShield){
				R_tile = loadItemTile(37);
				R_cset = loadItemCSet(37);
			} else {
				R_tile = loadItemTile(8);
				R_cset = loadItemCSet(8);
			}
		}
	} else if(form==1){
		A_tile = loadItemTile(Link->ItemA);
		A_cset = loadItemCSet(Link->ItemA);
		if(Game->MCounter[CR_MAGIC]>0){
			R_tile = loadItemTile(ITEM_BUBBLE);
			R_cset = loadItemCSet(ITEM_BUBBLE);
		}
	} else if(form==2){
		if(curled){
			A_tile = loadItemTile(ITEM_POUND);
			A_cset = loadItemCSet(ITEM_POUND);
		} else {
			A_tile = loadItemTile(Link->ItemA);
			A_cset = loadItemCSet(Link->ItemA);
		}
		R_tile = 12591;
		R_cset = 0;
	} else if(form==3){
		A_tile = loadItemTile(Link->ItemA);
		A_cset = loadItemCSet(Link->ItemA);
		R_tile = loadItemTile(23);
		R_cset = loadItemCSet(23);
	}
	if(!form)switch(mask){
		case 7:{
			if(!getGlobalVar(GVAR_BLASTMASKCOOLDOWN,0)){
				L_tile=loadItemTile(189);
				L_cset=loadItemCSet(189);
			}
		break;}
	}
	int EX1_tile = loadItemTile(EX1_item);
	int EX2_tile = loadItemTile(EX2_item);
	int B_tile = loadItemTile(B_item);
	int B_cset = loadItemCSet(B_item);
	int EX1_cset = loadItemCSet(EX1_item);
	int EX2_cset = loadItemCSet(EX2_item);
	if(EX1_item==I_DEKUSTICK&&dekuStickLitTimer>0)EX1_tile+=20;
	if(EX2_item==I_DEKUSTICK&&dekuStickLitTimer>0)EX2_tile+=20;
	if(B_item==I_DEKUSTICK&&dekuStickLitTimer>0)B_tile+=20;
	if(isArrow(B_item)&&B_item!=13)B_tile++;
	if(isArrow(EX1_item)&&EX1_item!=13)EX1_tile++;
	if(isArrow(EX2_item)&&EX2_item!=13)EX2_tile++;
	if(holdingBomb){
		EX1_tile=TILE_INVIS;
		EX2_tile=TILE_INVIS;
		B_tile=TILE_INVIS;
		A_tile=loadItemTile(3);
		A_cset=loadItemCSet(3);
		R_tile=TILE_DROP;
		R_cset=CSET_DROP;
	}
	if(Deku_flying>0){
		EX1_tile=TILE_INVIS;
		EX2_tile=TILE_INVIS;
		B_tile=TILE_INVIS;
		A_tile=loadItemTile(ITEM_DEKUNUT);
		A_cset=loadItemCSet(ITEM_DEKUNUT);
		R_tile=TILE_DROP;
		R_cset=CSET_DROP;
	}
	Screen->FastTile(7,BX,BY,B_tile,B_cset,OP_OPAQUE);
	Screen->FastTile(7,EX1X,EX1Y,EX1_tile,EX1_cset,OP_OPAQUE);
	Screen->FastTile(7,EX2X,EX2Y,EX2_tile,EX2_cset,OP_OPAQUE);
	Screen->FastTile(7,AX,AY,A_tile,A_cset,OP_OPAQUE);
	Screen->FastTile(7,RX,RY,R_tile,R_cset,OP_OPAQUE);
	Screen->FastTile(7,LX,LY,L_tile,L_cset,OP_OPAQUE);
	//Mask
	Screen->FastTile(7,MASKX,MASKY,currMaskTile,6,OP_OPAQUE);
	if(mask==24)Screen->FastTile(7,185,-22,currMaskTile+1,6,OP_OPAQUE);
	//Rupee Marker
	Screen->FastTile(7,26,-24,RUPEE_tile,RUPEE_cset,OP_OPAQUE);
	//Tael
	if(Link->Item[I_TAEL_1]){
		Screen->FastTile(7,TAEL_X,TAEL_Y,loadItemTile(I_TAEL_1),0,OP_OPAQUE);
		Screen->FastTile(7,TAEL_X+16,TAEL_Y,loadItemTile(I_TAEL_2),0,OP_OPAQUE);
	}
	//Time
	if(day<4){
		if(slowTime){
			Screen->FastTile(7,DAYSTART_X-8,DAYSTART_Y,12613,0,OP_OPAQUE);
		}
		Screen->FastTile(7,DAYSTART_X,DAYSTART_Y,12610,0,OP_OPAQUE);
		Screen->FastTile(7,DAYSTART_X+16,DAYSTART_Y,12611,0,OP_OPAQUE);
		Screen->FastTile(7,DAYNUM_X,DAYNUM_Y,NumberTiles[day],0,OP_OPAQUE);
		Screen->FastTile(7,TIMESTART_X,TIMESTART_Y,NumberTiles[Floor(hour/10)],0,OP_OPAQUE);
		Screen->FastTile(7,TIMESTART_X+7,TIMESTART_Y,NumberTiles[hour%10],0,OP_OPAQUE);
		Screen->FastTile(7,TIMESTART_X+12,TIMESTART_Y,SEMICOLON,0,OP_OPAQUE);
		int minute = Floor(time/FRAMES_MINUTE);
		Screen->FastTile(7,TIMESTART_X+17,TIMESTART_Y,NumberTiles[Floor(minute/10)],0,OP_OPAQUE);
		Screen->FastTile(7,TIMESTART_X+24,TIMESTART_Y,NumberTiles[minute%10],0,OP_OPAQUE);
	} else {
		Screen->FastTile(7,DAYSTART_X-4,DAYSTART_Y,12608,0,OP_OPAQUE);
		Screen->FastTile(7,DAYSTART_X+12,DAYSTART_Y,12609,0,OP_OPAQUE);
	}
}//end PassiveSubscreen

//start subscreenFunctions
int noteToTile(int note){
	if(note==NOTE_A)return NOTETILE_A;
	if(note==NOTE_DOWN)return NOTETILE_DOWN;
	if(note==NOTE_RIGHT)return NOTETILE_RIGHT;
	if(note==NOTE_LEFT)return NOTETILE_LEFT;
	if(note==NOTE_UP)return NOTETILE_UP;
	return TILE_INVIS;
}

int noteToCSet(int note){
	if(note==NOTE_A)return NOTECSET_A;
	if(note==NOTE_DOWN)return NOTECSET_DOWN;
	if(note==NOTE_RIGHT)return NOTECSET_RIGHT;
	if(note==NOTE_LEFT)return NOTECSET_LEFT;
	if(note==NOTE_UP)return NOTECSET_UP;
	return 0;
}

int loadItemTile(int itID){
	if(itID == 0)return TILE_INVIS;
	itemdata i = Game->LoadItemData(itID);
	int frameNum = 0;
	if(i->ASpeed>0&&i->AFrames>0)
		frameNum = Floor((gameframe%(i->ASpeed*i->AFrames))/i->ASpeed);
	return i->Tile+frameNum;
}

int loadItemCSet(int itID){
	if(itID == 0)return 0;
	itemdata i = Game->LoadItemData(itID);
	return i->CSet;
}

void drawTileToLoc(int tile, int cset, int row, int col, int layer){
	Screen->FastTile(layer,col*16,row*16,tile,cset,OP_OPAQUE);
}

int locToRow(int loc){
	return Floor(loc/16);
}

int locToCol(int loc){
	return (loc-(Floor(loc/16)*16));
}

void drawBase(int baseScreen){
	Screen->DrawScreen(6,MAP_SUBSCREEN,baseScreen,0,0,0);
}//end subscreenFunctions
//end Subscreen
//start Masks
int mask = 1;
const int FIRST_MASK_TILE = 65220;
int currMaskTile = 65221;
void handleMasks(){
	switch(mask){
		case 7:{
			if(!getGlobalVar(GVAR_BLASTMASKCOOLDOWN,GV_MISC)){
				if(Link->PressL){
					lweapon blast = CreateLWeaponAt(LW_BOMBBLAST,Link->X+dirX(Link->Dir)*16,Link->Y+dirY(Link->Dir)*16);
					blast->Damage=2;
					setGlobalVar(GVAR_BLASTMASKCOOLDOWN,GV_MISC,360);
					if(Link->Item[8]||Link->Item[37]){Link->InvFrames=40;freezeFrames=30;NoAction();}
				}
			} else {
				incGlobalVar(GVAR_BLASTMASKCOOLDOWN,GV_MISC,-1);
			}
			break;}
		case 12:{
			if(Link->Action==LA_SWIMMING)
				LinkMovement_SetLinkSpeedBoost(SPEEDBOOST_BUNNY_WATER);
			else LinkMovement_SetLinkSpeedBoost(SPEEDBOOST_BUNNY_LAND);
			break;}
	}
}

item script Mask{//start
	//0 is no mask, 1-4 are transformation masks.
	void run(int maskID){
		if(mask>0&&mask<=4||maskID>0&&maskID<=4){
			if(maskID>0&&maskID<=4){
				if(form==maskID){
					form = 0;
					mask = 0;
					currMaskTile = FIRST_MASK_TILE;
					NOTESOUND_A = 200;
					NOTESOUND_DOWN = 201;
					NOTESOUND_RIGHT = 202;
					NOTESOUND_LEFT = 203;
					NOTESOUND_UP = 204;
				} else {
					mask = maskID;
					form = maskID;
					currMaskTile = FIRST_MASK_TILE + maskID;
					NOTESOUND_A = 200 + (5*maskID);
					NOTESOUND_DOWN = 201 + (5*maskID);
					NOTESOUND_RIGHT = 202 + (5*maskID);
					NOTESOUND_LEFT = 203 + (5*maskID);
					NOTESOUND_UP = 204 + (5*maskID);
				}
			}
		} else {
			if(mask==maskID){
				mask = 0;
				currMaskTile = FIRST_MASK_TILE;
			} else {
				mask = maskID;
				currMaskTile = FIRST_MASK_TILE + maskID;
			}
		}
		/*switch(mask){
			
		}*/
	}
}//end

//start Transformation Masks
//start formVars
int form = 1;
//Link Tile Modifier items
const int FORM1 = 123;
const int FORM2 = 124;
const int FORM3 = 125;
const int FORM4 = 126;
const int FORM2CURLED = 128;
const int FORM_SHIELD = 129;
const int FORM_M_SHIELD = 130;
const int FORM2SPIKED = 132;
//end formVars
void handleTransformations(lweapon zoraBoom1, lweapon zoraBoom2){//start
	//start Form setup
	Link->Item[FORM1] = (form==1);
	Link->Item[FORM2] = (form==2&&!curled);
	Link->Item[FORM2CURLED] = (form==2&&curled&&!spikedRolling);
	Link->Item[FORM2SPIKED] = (form==2&&spikedRolling);
	Link->Item[FORM3] = (form==3);
	Link->Item[FORM4] = (form==4);
	//end Form setup
	if(Link->InputB){//start ItemJinxing
		if(!itemAllowed(form,B_item)){
			Link->ItemJinx = 3;
		}
	} else if(Link->InputEx1){
		if(!itemAllowed(form,EX1_item)){
			Link->ItemJinx = 3;
		}
	} else if(Link->InputEx2){
		if(!itemAllowed(form,EX2_item)){
			Link->ItemJinx = 3;
		}
	}//end
	if(!isFrozen){//start Form notPaused
		//start handlers
		zoraBoomMovement(zoraBoom1,zoraBoom2);
		//end handlers
		if(!form){//start human
			if(Link->PressR&&Link->Action!=LA_SWIMMING&&!Link->Item[210]){
				Game->PlaySound(SFX_SHIELD);
			}
			if(Link->InputR&&Link->Action!=LA_SWIMMING&&!Link->InputA&&!Link->InputB&&!Link->InputEx1&&!Link->InputEx2&&!Link->Item[210]){
				Link->Item[8]=true;
				Link->Item[37]=hasMirrorShield;
				Link->Item[FORM_SHIELD] = !hasMirrorShield;
				Link->Item[FORM_M_SHIELD] = hasMirrorShield;
			} else {
				Link->Item[8]=false;
				Link->Item[37]=false;
				Link->Item[FORM_SHIELD] = false;
				Link->Item[FORM_M_SHIELD] = false;
			}
			//end human
		} else if(form==1){//start deku
			if(!Deku_flying){
				if(Link->PressR){
					useItem = ITEM_BUBBLE;
					Link->PressR=false;
					Link->InputR=false;
				}
			} else {
				dekuFly();
			}
			int linkcombot = Screen->ComboT[ComboAt(Link->X+8,Link->Y+12)];
			if(!Deku_flying&&(linkcombot==CT_WATER||linkcombot==CT_SHALLOWWATER)){
				Deku_floating--;
				if(isTouchingComboBy(COMBO_LILYPAD,8)){
					Deku_floating=60;
				} else if(Deku_floating>0&&Link->Action!=LA_DROWNING&&!(Deku_floating%20)){//Play every 20 frames
					Game->PlaySound(SFX_DEKUHOP);
				}
			} else {
				Deku_floating = 60;
				Link->Item[51] = true;
			}
			if(!Deku_floating){
				Link->Item[51]=false;
				Link->Action=LA_DROWNING;
			}
			//end deku
		} else if(form==2){//start Goron
			if(Link->PressR){
				if(curled)Game->PlaySound(SFX_GORONUNCURL);
				else Game->PlaySound(SFX_GORONCURL);
				curled=!curled;
				Link->ItemJinx=3;
			}
			if(curled){
				Link->SwordJinx = 10;
				if(Link->PressA){
					useItem = ITEM_POUND;
					Link->PressA=false;
					Link->InputA=false;
				}
				Link->Item[36]=false;
				Link->Item[54]=true;
				if((Link->InputDown||Link->InputRight||Link->InputLeft||Link->InputUp)&&(Link->Action==LA_NONE||Link->Action==LA_WALKING||Link->Action==LA_GOTHURTLAND)){
					if(timeRolling<84){
						LinkMovement_SetLinkSpeedBoost(-1.5);
						if(!timeRolling){
							Game->PlaySound(SFX_GORONROLL_BEGIN);
						}
						spikedRolling=false;
					} else if(timeRolling<100){
						if(!((timeRolling-84)%14)){
							Game->PlaySound(SFX_GORONROLL_LOOP);
						}
						LinkMovement_SetLinkSpeedBoost(-0.5);
						spikedRolling=false;
					} else if(timeRolling<200||Game->Counter[CR_MAGIC]<MAGICCOST_SPIKEROLL){
						if(!((timeRolling-84)%16)){
							Game->PlaySound(SFX_GORONROLL_LOOP);
						}
						LinkMovement_SetLinkSpeedBoost(1);
						spikedRolling=false;
					} else {
						if(!spikedRolling){
							spikeStartTime=timeRolling;
							Game->PlaySound(SFX_GORONROLL_SPEEDUP);
						} else {
							int time = timeRolling-(spikeStartTime+60);
							if(time>=0&&!(time%23)){
								Game->PlaySound(SFX_GORONROLL_SPEEDLOOP);
							}
						}
						LinkMovement_SetLinkSpeedBoost(2.5);
						if(!(gameframe%EVERYXFRAMES_SPIKEROLL))
							Game->DCounter[CR_MAGIC]-=MAGICCOST_SPIKEROLL;
						spikedRolling=true;
					}
					timeRolling++;
				} else {
					Audio->EndSound(SFX_GORONROLL_BEGIN);
					Audio->EndSound(SFX_GORONROLL_LOOP);
					Audio->EndSound(SFX_GORONROLL_SPEEDLOOP);
					Audio->EndSound(SFX_GORONROLL_SPEEDUP);
					timeRolling = 0;
					spikedRolling=false;
				}
			} else {
				Audio->EndSound(SFX_GORONROLL_BEGIN);
				Audio->EndSound(SFX_GORONROLL_LOOP);
				Audio->EndSound(SFX_GORONROLL_SPEEDLOOP);
				Audio->EndSound(SFX_GORONROLL_SPEEDUP);
				Audio->EndSound(SFX_GORONPOUND);
				Link->Item[36]=true;
				Link->Item[54]=false;
				timeRolling = 0;
				spikedRolling=false;
			}
			if(spikedRolling){
				goronSpikeRoll();
			}//end Goron
		} else if(form==3){//start zora
			if(Link->PressR){
				fireZoraBoomerang();
				Link->PressR=false;
				Link->InputR=false;
			}
			//end
		} else if(form==4){//start Deity
			if(Link->PressR&&Link->Action!=LA_SWIMMING){
				Game->PlaySound(SFX_SHIELD);
			}
			if(Link->InputR&&Link->Action!=LA_SWIMMING&&!Link->InputA){
				Link->Item[8]=true;
				Link->Item[37]=hasMirrorShield;
				NoActionButMoveAndEx4AndA();
			} else {
				Link->Item[8]=false;
				Link->Item[37]=false;
			}
		}//end
	}//end Form notonsubscreen	
	if(form){//start Not-form-x
		Link->Item[FORM_SHIELD] = false;
		Link->Item[FORM_M_SHIELD] = false;
		Link->Item[210] = false;
		if(form!=4){
			Link->Item[8]=false;
			Link->Item[37]=false;
		}
	}
	if(form!=1){
		Link->Item[133] = false;
		Link->Item[134] = false;
		Link->Item[135] = false;
		Link->Item[ITEM_BUBBLE] = false;
	}
	if(form!=2){
		curled=false;
		spikedRolling=false;
		Link->Item[36]=false;
		Link->Item[54]=false;
	}
	if(form!=3){
		Link->Item[136] = false;
	}
	if(form!=4){
		Link->Item[208]=false;
		Link->Item[209]=false;
	}
	//end Not-form-x
	if(!form){//start HUMAN
		Link->Item[51] = true;
		Link->Item[214]=false;
		//end HUMAN
	} else if(form==1){//start DEKU
		Link->Item[51] = true;
		Link->Item[214]=false;
		Link->Item[133] = true;
		Link->Item[134] = true;
		Link->Item[135] = true;
		Link->Item[ITEM_BUBBLE] = true;
		Link->Item[8]=false;
		Link->Item[37]=false;
		//end DEKU
	} else if(form==2){//start GORON
		Link->Item[51]=false;
		Link->Item[214]=false;
		Link->Item[8]=false;
		Link->Item[37]=false;
		//end GORON
	} else if(form==3){//start ZORA
		Link->Item[214]=true;
		Link->Item[8]=false;
		Link->Item[37]=false;
		Link->Item[136] = true;
		if(Link->Action==LA_SWIMMING)LinkMovement_SetLinkSpeedBoost(SPEEDBOOST_ZORA_WATER);
		handleZoraScreenChange();
		//end ZORA
	} else if(form==4){//start DEITY
		Link->Item[208]=true;
		Link->Item[209]=true;
		//end DEITY
	}
}//end
//start formFunctions
//For default form, check if item is not on blacklist, else check if item is on whitelist
bool itemAllowed(int form, int itemID){
	if(!form){
		int F0_items[] = {48};//This is blacklist, others below are whitelist
		for(int i = 0;i<SizeOfArray(F0_items);i++){
			if(F0_items[i]==itemID)return false;
		}
		return true;
	} else if(form==1){
		int F1_items[] = {31,144,127,131,25,207,53};
		for(int i = 0;i<SizeOfArray(F1_items);i++){
			if(F1_items[i]==itemID)return true;
		}
		return false;
	} else if(form==2){
		if(curled)return false;
		int F2_items[] = {31,144,127,131,207,53,48};
		//if(itemID==48)return true;//PATCHWORK//
		for(int i = 0;i<SizeOfArray(F2_items);i++){
			if(F2_items[i]==itemID)return true;
		}
		return false;
	} else if(form==3){
		int F3_items[] = {31,48,144,127,ITEM_POUND,131,207,53};	
		for(int i = 0;i<SizeOfArray(F3_items);i++){
			if(F3_items[i]==itemID)return true;
		}
		return false;
	} else if(form==4){
		int F4_items[] = {144,127,131,207,53};
		for(int i = 0;i<SizeOfArray(F4_items);i++){
			if(F4_items[i]==itemID)return true;
		}
		return false;
	}
}

bool isTouchingComboBy(int comboID,int pixBy){
	int x = Link->X;
	int y = Link->Y;
	if(Screen->ComboD[ComboAt(Link->X+pixBy,Link->Y+pixBy)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Link->X+15-pixBy,Link->Y+pixBy)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Link->X+pixBy,Link->Y+15-pixBy)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Link->X+15-pixBy,Link->Y+15-pixBy)]==comboID)return true;
	return false;
}
//end formFunctions
//start customFormFunctions
//start FFC DekuFlower
const int maxDiveTime = 110;
ffc script dekuFlower{
	void run(int filledCombo, int flightlength, int floorsUp, float speedMod){
		int combo = this->Data;
		if(!speedMod)speedMod=-.5;
		bool dived = false;
		int diveTime = 20;
		while(true){
			if(form!=1){
				Deku_flying=0;
				diveTime = maxDiveTime;
				dived=false;
			}
			if(Link->Invisible&&!dived&&!Deku_flying){Waitframe();continue;}
			if(dived){
				this->Data = filledCombo;
				Link->Invisible = true;	
			} else {
				this->Data = combo;
				Link->Invisible = false;
			}
			if(form==1&&Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8){
				if(dived){
					diveTime = maxDiveTime;
					if(!Link->InputA){
						dived=false;
						DekuFlightSpeedMod = speedMod;
						Deku_flying = flightlength;
						Game->PlaySound(68);
						Link->Invisible = false;
						warpNumFloors=floorsUp;
					} else NoDirs();
				} else if(!Deku_flying){
					if(Link->InputA&&diveTime>0){
						if(diveTime==maxDiveTime)Game->PlaySound(67);
						diveTime--;
						if(!diveTime){
							dived=true;
						}
						NoDirs();
					} else if(!Link->InputA){
						diveTime = maxDiveTime;
						Audio->EndSound(67);
					}
				}
			} else diveTime = maxDiveTime;
			Waitframe();
		}
	}
}
//end FFC DekuFlower
void dekuFly(){//start DekuFly
	Deku_flying--;
	if(Link->PressR)Deku_flying=0;
	if(!Deku_flying){
		Game->PlaySound(78);
		canFall=true;
	} else if((!(gameframe%6)&&Deku_flying>180)||(!(gameframe%12)&&Deku_flying>91)||(!(gameframe%24)||gameframe%24==6))
		Game->PlaySound(69);
	if(Link->PressA)useItem=ITEM_DEKUNUT;
	NoActionButMoveAndEx4();
	LinkMovement_SetLinkSpeedBoost(DekuFlightSpeedMod);
}//end
void goronSpikeRoll(){//start GoronRoll
	for(int i = 0;i<countNPCInRange(CenterLinkX(),CenterLinkY(),24);i++){
		npc anNPC = getNthNPCInRange(CenterLinkX(),CenterLinkY(),24,i);
		if(anNPC->isValid()){
			if(anNPC->CollDetection&&!anNPC->InvFrames&&anNPC->Defense[NPCD_SCRIPT2]!=NPCDT_IGNORE){
				lweapon hit = CreateLWeaponAt(LW_SCRIPT2,anNPC->X+(anNPC->HitXOffset)+(anNPC->HitWidth/2),anNPC->Y+(anNPC->HitYOffset)+(anNPC->HitHeight/2));
				hit->Damage=2;
				hit->HitWidth=1;
				hit->HitHeight=1;
				hit->UseSprite(SPRITE_NONE);
				hit->Step=0;
			} else if(anNPC->InvFrames){
				anNPC->Stun=5;
			}
		}
	}
}//end GoronSpikeRoll
void fireZoraBoomerang(){//start ZoraRang
	if(!countLWeaponType(LW_BRANG)){
		lweapon zoraBoom1 = Screen->CreateLWeapon(LW_BRANG);
		zoraBoom1->X=CenterLinkX();
		zoraBoom1->Y=CenterLinkY();
		lweapon zoraBoom2 = Screen->CreateLWeapon(LW_BRANG);
		zoraBoom2->X=CenterLinkX();
		zoraBoom2->Y=CenterLinkY();
		//
		zoraBoom1->Angular=true;
		zoraBoom2->Angular=true;
		if(Link->Dir==DIR_DOWN){
			zoraBoom1->Angle=DIR16_RADS_RIGHTDOWN;
			zoraBoom2->Angle=DIR16_RADS_LEFTDOWN;
		} else if(Link->Dir==DIR_LEFT){
			zoraBoom1->Angle=DIR16_RADS_LEFTDOWN;
			zoraBoom2->Angle=DIR16_RADS_UPLEFT;
		} else if(Link->Dir==DIR_UP){
			zoraBoom1->Angle=DIR16_RADS_UPLEFT;
			zoraBoom2->Angle=DIR16_RADS_RIGHTUP;
		} else {
			zoraBoom1->Angle=DIR16_RADS_RIGHTUP;;
			zoraBoom2->Angle=DIR16_RADS_RIGHTDOWN;
		}
		zoraBoom1->Step=5;
		zoraBoom2->Step=5;
		zoraBoom1->Damage=1;
		zoraBoom2->Damage=1;
		zoraBoom1->Misc[0]=0.035;
		zoraBoom2->Misc[0]=0.035;
		zoraBoom1->CollDetection=false;
		zoraBoom2->CollDetection=false;
		Game->Misc[0]=zoraBoom1;
		Game->Misc[1]=zoraBoom2;
	}
}

void zoraBoomMovement(lweapon zoraBoom1, lweapon zoraBoom2){
	if(zoraBoom1->isValid()||zoraBoom2->isValid()){
		if(!(gameframe%20))Game->PlaySound(4);
	}
	if(zoraBoom1->isValid()){
		if(!zoraBoom2->isValid()){
			zoraBoom1->Misc[2]=5;
		}
		handleBRang(zoraBoom1,1);
	}
	if(zoraBoom2->isValid()){
		if(!zoraBoom1->isValid()){
			zoraBoom2->Misc[2]=5;
		}
		handleBRang(zoraBoom2,-1);
	}
	if(zoraBoom1->Misc[0]>0.1&&Collision(zoraBoom1,zoraBoom2)){
		zoraBoom1->Misc[2]=10;
		zoraBoom2->Misc[2]=10;
	}
}

void handleBRang(lweapon brang, int mult){
	int DegAngle = RadtoDeg(brang->Angle);
	if(DegAngle%90>=89||DegAngle%90<=1){
		if(!brang->Misc[1]){
			brang->Misc[0]*=3;
			brang->Misc[1]=1;
		}
	}
	if(brang->Misc[2]>0){
		brang->Misc[2]--;
		if(!brang->Misc[2]){
			brang->DeadState=WDS_BOUNCE;
		}
	}
	brang->Angle+=(brang->Misc[0]*mult);
	//Collision:
	for(int i = 1;i<=Screen->NumNPCs();i++){
		npc n = Screen->LoadNPC(i);
		if(n->isValid()&&Collision(n,brang)&&!n->InvFrames&&!n->Stun){
			int damage = brang->Damage*2;
			int def = n->Defense[NPCD_BRANG];
			switch(def){
				case NPCDT_HALFDAMAGE:{damage/=2;break;}
				case NPCDT_QUARTERDAMAGE:{damage/=4;break;}
				case NPCDT_STUN:{damage=0;break;}
				case NPCDT_STUNORBLOCK:{damage=0;break;}
				case NPCDT_STUNORIGNORE:{damage=0;break;}
				case NPCDT_STUN:{damage=0;break;}
				case NPCDT_BLOCK:{damage=0;break;}
				case NPCDT_BLOCK2:{damage=0;break;}
				case NPCDT_BLOCK4:{damage=0;break;}
				case NPCDT_BLOCK6:{damage=0;break;}
				case NPCDT_BLOCK8:{damage=0;break;}
				case NPCDT_IGNORE:{damage=0;break;}
				case NPCDT_ONEHITKILL:{damage=n->HP;break;}
			}
			n->HP-=damage;
			n->InvFrames=10;
			n->Stun=10;
		}
	}
}
//end ZoraRang

void handleZoraScreenChange()//start ZoraSurfaceDive
{
	handleZoraSurfacing();
	handleZoraDiving();
}

void handleZoraSurfacing()
{
	if(!Link->PressL)return;
	if(getUpDMap()==-1)return;
	mapdata m = Game->LoadMapData(GetCurMap()+1,GetCurScreen());// UNFINISHED
	int combos[] = {ComboAt(Link->X,Link->Y),ComboAt(Link->X,Link->Y+15),ComboAt(Link->X+15,Link->Y),ComboAt(Link->X+15,Link->Y+15)};
	for(int i = 0; i < 4; i++)
	{
		if(m->ComboT[combos[i]] != CT_DIVEWARP)
		{
			return;
		}
	}
	warpUp();
}

void handleZoraDiving()
{
	if(Link->Action != LA_DIVING)return;
	if(getDownDMap()==-1)return;
	int combos[] = {ComboAt(Link->X,Link->Y),ComboAt(Link->X,Link->Y+15),ComboAt(Link->X+15,Link->Y),ComboAt(Link->X+15,Link->Y+15)};
	for(int i = 0; i < 4; i++)
	{
		if(Screen->ComboT[combos[i]] != CT_DIVEWARP)
		{
			return;
		}
	}
	warpDown();
}//end
//end customFormFunctions
//end Transformation Masks
//end Masks
//start throwableBombs
bool holdingBomb = false;
const int LWMISC_MOVINGTIME = 0;
const int LWMISC_FUSE = 1;
const int LWMISC_EXPLOSIONDAMAGE = 2;
const int LWMISC_IDENTITY = 3;
const int LW_THRBOMBS = 31;

void bombCheck(){
	if(isThrowingBomb()){
		lweapon bomb = loadLWeaponType(LW_THRBOMBS,0);
		if(holdingBomb){
			bomb->X=Link->X;
			bomb->Y=Link->Y-8;
			//if(!subscreen)stopScreenTransition(4,4,4,12);
			if(Link->PressA||Link->PressB||Link->PressEx1||Link->PressEx2){
				throwBomb();
				Link->SwordJinx=3;
				Link->ItemJinx=3;
			} else if(Link->PressR){
				placeBomb();
				Link->PressR=false;
				Link->InputR=false;
			}
			Link->PressStart=false;
			Link->InputStart=false;
			NoActionButMoveAndEx4AndA();
		} else {
			lweapCollDetect(bomb);
		}
		if(!bomb->Misc[LWMISC_MOVINGTIME]){
			bomb->Step=0;
		} else if(bomb->Misc[LWMISC_MOVINGTIME]>0){
			bomb->Misc[LWMISC_MOVINGTIME]--;
		}
		if(!bomb->Misc[LWMISC_FUSE]){
			explosion(bomb->X,bomb->Y,bomb->Misc[LWMISC_EXPLOSIONDAMAGE],bomb->Dir);
			bomb->DeadState=WDS_DEAD;
		} else {
			bomb->Misc[LWMISC_FUSE]--;
		}
	} else {
		holdingBomb=false;
	}
}

bool isThrowingBomb(){
	for(int i = 1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if(weap->ID==LW_THRBOMBS){
				return true;
			}
		}
	}
	return false;
}

lweapon loadLWeaponType(int type,int num){
	int weapCount = 0;
	for(int i = 1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if(weap->ID==type){
				if(weapCount==num){
					return weap;
				} else {
					weapCount++;
				}
			}
		}
	}
}

int countLWeaponType(int type){
	int weapCount = 0;
	for(int i = 1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if(weap->ID==type){
				weapCount++;
			}
		}
	}
	return weapCount;
}

lweapon spawnThrowingBomb(int x, int y, int fuse, int damage){
	lweapon bomb = CreateLWeaponAt(LW_THRBOMBS,x,y);
	bomb->UseSprite(7);
	bomb->Behind = false;
	bomb->CollDetection = false;
	bomb->Misc[LWMISC_FUSE] = fuse;
	bomb->Misc[LWMISC_EXPLOSIONDAMAGE] = damage;
	bomb->Misc[LWMISC_IDENTITY] = 1;
	return bomb;
}

void throwBomb(){
	if(isThrowingBomb()){
		lweapon bomb = loadLWeaponType(LW_THRBOMBS,0);
		holdingBomb=false;
		bomb->Y=Link->Y;
		bomb->Dir=Link->Dir;
		bomb->Step=150;
		bomb->Misc[LWMISC_MOVINGTIME] = 60;
	}
}

void placeBomb(){
	if(isThrowingBomb()){
		holdingBomb=false;
		lweapon bomb = loadLWeaponType(LW_THRBOMBS,0);
		if(Link->Dir==DIR_DOWN){
			bomb->X=Link->X;
			bomb->Y=Link->Y+16;
		} else if(Link->Dir==DIR_RIGHT){
			bomb->X=Link->X+16;
			bomb->Y=Link->Y;
		} else if(Link->Dir==DIR_LEFT){
			bomb->X=Link->X-16;
			bomb->Y=Link->Y;
		} else if(Link->Dir==DIR_UP){
			bomb->X=Link->X;
			bomb->Y=Link->Y-16;
		}
	}
}

item script throwableBombs{
	void run(int fuse, int damage){
		if(Game->Counter[CR_BOMBS]>0&&!isThrowingBomb()&&Link->Y>=12){
			spawnThrowingBomb(Link->X,Link->Y-8,fuse,damage);
			holdingBomb = true;
			Game->Counter[CR_BOMBS]--;
		}
	}
}

void stopScreenTransition(int pxAway){
	stopScreenTransition(pxAway,pxAway,pxAway,pxAway);
}

void explosion(int x, int y, int damage, int dir){
	lweapon blast = CreateLWeaponAt(LW_BOMBBLAST,x,y);
	blast->Damage=damage;
	blast->Dir=dir;
	blast->UseSprite(9);
}

void lweapCollDetect(lweapon weap){
	if(!CanWalk(weap->X,weap->Y,weap->Dir,weap->Step/100,true)){
		weap->Step=0;
	} else {
		stopScreenTransitionLWeap(8,weap);
	}
}

void stopScreenTransitionLWeap(int pixelsAway,lweapon weap){
	if(weap->X<0+pixelsAway)weap->Step=0;
	if(weap->X>240-pixelsAway)weap->Step=0;
	if(weap->Y<0+pixelsAway)weap->Step=0;
	if(weap->Y>160-pixelsAway)weap->Step=0;
}
//end throwableBombs
//start OcarinaScripts
//CTRL+F for "//CHANGE//" to find things that must be changed for the script to function. CTRL+F "//CUSTOMSONG//" to find the places that must be changed to add custom songs.
//start ITEM Ocarina
item script Ocarina{
	//
	//Set this to the item you wish to activate song mode. This item should be a Custom Item Class.
	//
	void run(){
		if(!songFrames&&!scarecrowMode){
			for(int note = 0;note<8;note++){
				currSong[note]=0;
			}
			ocIndex = 0;
			playedSong=-1;
			ocarina_mode = true;
		} else if(!songFrames&&scarecrowMode){
			for(int note = 0;note<8;note++){
				currSong[note]=0;
			}
			ocIndex = 0;
			playedSong=-1;
			scarecrowRecord = true;
		}
	}
}
//end Ocarina
//start FFC SongTriggersSecrets
ffc script SongTriggersSecrets{
	//
	//Var 0: Number of song to require for secret trigger
	//Var 1: Set to 0 for temporary secrets, set to 1 for permanent secrets.
	//Var 2: Set to 0 for play anywhere on screen, set to 1 for play while standing on FFC
	//
	void run(int song, bool perm, bool reqOnFFC){
		bool waiting = true;
		while(waiting){
			if(playedSong==song){
				if(!reqOnFFC||(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8)){
					Screen->TriggerSecrets();
					if(perm){
						Screen->State[ST_SECRET] = true;
					}
					waiting=false;
				}
			}
			Waitframe();
		}
	}
}
//end SongTriggersSecrets
//start FFC LearnASong
ffc script LearnASong{
	//
	//Var 0: Number of song to learn when stepping on this tile
	//Var 1: X-coordinate to display song learn message at. Leave blank for default (128).
	//Var 2: Y-coordinate to display song learn message at. Leave blank for default (32).
	//Var 3: Font color. Leave blank for default (black).
	//Var 4: Background color. Leave blank for default (transparent). Use -1 for black.
	//Var 5: Draw. If set to 0, song message will only be displayed when the song is learned. If set to 1, it will be displayed any time the screen is visited after it has been learned. If set to -1, it will not be displayed.
	//Note that the combo for this FFC will be automatically set to Combo 0 once the song is learned!
	//
	void run(int song,int displayX,int displayY,int fontColor, int bgColor, int drawstate){
		bool waiting = true;
		bool draw = false;
		if(!displayX){
			displayX=128;
		}
		if(!displayY){
			displayY=32;
		}
		if(!bgColor){
			bgColor=-1;
		} else if(bgColor==-1){
			bgColor=0;
		}
		while(waiting){
			if(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8){
				LEARNED_SONGS[song]=true;
				if(!drawstate){
					draw=true;
				}
			}
			if(LEARNED_SONGS[song]){
				waiting=false;
				this->Data=0;
				if(drawstate==1){
					draw=true;
				}
			}
			Waitframe();
		}
	}
}
//end LearnASong
//start FFC MakeScarecrowsSong
ffc script MakeScarecrowsSong{
	//
	//If Link is standing on this FFC and uses the Ocarina, he will not be able to play normal songs, but will instead play an 8-note song of his making which will be the scarecrow's song!
	//NOTE: Link must still first LEARN the ScarecrowsSong using the LearnASong script, just as any other song. You can place that here as well, or place it elsewhere to simulate "activating" the song as is done in OOT!
	//The player may come back to this spot any time to change the ScarecrowsSong.
	//
	void run(){
		while(true){
			if(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8){
				scarecrowMode = true;
			} else {
				scarecrowMode = false;
				scarecrowRecord = false;
			}
			Waitframe();
		}
	}
}
//end MakeScarecrowsSong
//end OcarinaScripts
//start NPC
const int SFX_BANKMENU = 18;

int NPCNames[1000] = {"Tatl","Happy Mask Salesman","Banker","Bremor","Brac","ERROR","Tatl"};

const int ID_TATL = 5;

ffc script NPC{
	//
	//ComboUnder should be a solid version of the combo beneath the FFC
	//
	void run(int NPCid, bool fake, int startday, int starthour, int endday, int endhour, int comboUnder, bool special){//start NPC setup
		int NPCcombo = this->Data;
		this->Data = COMBO_INVIS;
		int loc = ComboAt(this->X,this->Y);
		bool visible = false;
		int comboDefault;
		if(NPCid==3&&GetCurDMap()!=0){//Hardcode for Bremor to make it not conflict with the cutscene on that screen
			comboDefault = 38404;
			Waitframe();
		} else {
			comboDefault = Screen->ComboD[loc];
		}
        while(!special){//start
			while(visible){
				if(!fake && AgainstFFCBase(this->X,this->Y) && Link->PressA){
					Link->InputA = false;
					Link->PressA = false;
					interact(NPCid);
				}
				if(isAfter(endday,endhour,true)){
					visible=false;
					this->Data = COMBO_INVIS;
					if(!fake)Screen->ComboD[loc]=comboDefault;
				}
				Waitframe();
			}
			while(!visible){
				if(isAfter(startday,starthour,true)&&isBefore(endday,endhour,false)){
					visible=true;
					this->Data = NPCcombo;
					if(!fake)Screen->ComboD[loc]=comboUnder;
				}
				Waitframe();
			}
        }//end
		while(special){//start
			switch(NPCid){
				case 1:{
					while(true){
						while(HMS_visible==false){
							Waitframe();
						}
						visible=true;
						this->Data = NPCcombo;
						Screen->ComboD[loc]=comboUnder;
						while(visible){
							if(AgainstFFCBase(this->X,this->Y) && Link->PressA){
								Link->InputA = false;
								Link->PressA = false;
								interact(NPCid);
							}
							Waitframe();
						}
					}
				}
				case 2:
				case 5:
				case 6:{
					this->Data=NPCcombo;
					while(true){
						if(AgainstFFCBase(this->X,this->Y) && Link->PressA){
							Link->InputA = false;
							Link->PressA = false;
							interact(NPCid);
						}
						Waitframe();
					}
				}
			}
			Waitframe();
		}//end
	}
	
	bool AgainstFFCBase(int x, int y){
		return Link->Z == 0 && ((Link->Dir == DIR_UP && Link->Y == y+8 && Abs(Link->X-x) < 8)||(Link->Dir == DIR_DOWN && Link->Y == y-16 && Abs(Link->X-x) < 8)||(Link->Dir == DIR_LEFT && Link->X == x+16 && Abs(Link->Y-y) < 8)||(Link->Dir == DIR_RIGHT && Link->X == x-16 && Abs(Link->Y-y) < 8));
    }//end NPC setup
	void interact(int NPCid){//start interact
		interact(NPCid,0);
	}
	
	void interact(int NPCid,int NPCsound){
		Game->PlaySound(NPCsound);
		switch(NPCid){
			case 1:{//Happy Mask Salesman
				if(!CS1_seen){
					ShowNPCMessageAndWait(6,NPCid);
					CS1_seen=true;
				} else {
					ShowNPCMessageAndWait(27,NPCid);
				}
			break;}
			
			case 2:{//Banker
				if(fullCounter(CR_BANKBAL)){
					tangoTempI=0;
					ShowNPCStringAndWait("What's this? You need somethin'?@pressa()@26<<@choice(1)Deposit@choice(2)Withdraw>>@domenu(1)@set(@ttempi @chosen)@close()",NPCid);
					if(tangoTempI==1){
						if(bankDeposit()){
							bankGiveRewards();
						}
					} else if(tangoTempI==2){
						bankWithdraw();
					}
				} else {
					tangoTemp=false;
					ShowNPCStringAndWait("Hey there, little guy!@26Won't you deposit some ((Rupees))?@delay(120)@26Nowadays, even if people have money, they don't deposit anything. Nothing!   Nothing!!!@delay(120)@26So, for a limited time, I'll give you a special gift based on how much you deposit.@delay(120)@26For example, if you deposit ((200 rupees)), you'll get an item that holds a lot of ((rupees)).@delay(120)@26So, what'll it be?@26<<@choice(1)Deposit@choice(2)Don't Deposit>>@domenu()@append(45)",NPCid);
					if(tangoTemp){
						ShowNPCStringAndWait("Alright!@pressa()@26So...",NPCid);
						if(bankDeposit()){
							ShowNPCStringAndWait("So, little guy, what's your name?@pressa()@26Hmm...@26{{@savename()}} is it?@pressa()@26Got it... I won't forget your deposits. Let me stamp you with my special ink.@pressa()@26Hey, relax! It doesn't leave any marks, and it's not gonna hurt.@pressa()@26There! Now I'll know you when I see you!",NPCid);
							bankGiveRewards();
						}
					} else {
						ShowNPCStringAndWait("Don't say that! C'mon... Trust me!@pressa()@26...Well, if you change your mind, come back and make a deposit!",NPCid);
					}
				}
			break;}
			
			case 3:{//Bremor, Carpenter (Red Pants)
				if(isBefore(2,6,false)){
					ShowNPCStringAndWait("Tsk! Is Brac working t'night? I wonder if that'll get finished.",NPCid);
				} else if (isBefore(3,6,false)){
					ShowNPCStringAndWait("Tsk, tsk, Brac...@26I wonder if this'll make it?",NPCid);
				} else {
					ShowNPCStringAndWait("Tsk! I knew it... It's startin' to feel like this job'll be impossible.",NPCid);
				}
			break;}
			
			case 4:{//Brac, Carpenter (Green Pants)
				if(isBefore(2,6,false)){
					ShowNPCStringAndWait("Hey, apprentice! Don't just stand around lookin' at the sky all day!",NPCid);
				} else if (isBefore(3,6,false)){
					ShowNPCStringAndWait("Bremor! Don't be standin' 'round lookin' at yer feet all day!",NPCid);
				} else {
					ShowNPCStringAndWait("I'm sorry, Bremor, but I'm going, too!",NPCid);
				}
			break;}
			
			case 5:{//Name-Changing Tablet
				tangoTemp=false;
				ShowStringAndWait("{{@savename()}}, would you like to change your name?@26<<@choice(1)Yes@choice(2)No>>@domenu()@append(45)");
				if(!tangoTemp)return;
				Screen_Freeze(1);
				Waitframes(6);
				RunFFCScript(FFC_CHANGENAME,{0});
			break;}
			
			case 6:{//Difficulty-Changing Tablet
				if(!Link->Item[I_OCARINA]){
					ShowNPCStringAndWait("Huh, this tablet seems like it's magical, but it isn't working now.",6);
				} else {
					remchr(shopString,0);
					switch(getGlobalVar(GVAR_DIFFICULTY,GV_MISC)){
						case 0:{
							strcpy(shopString,"Easy");
						break;}
						
						case 1:{
							strcpy(shopString,"Normal");
						break;}
						
						case 2:{
							strcpy(shopString,"Hard");
						break;}
					}
					tangoTempI = 1;
					ShowStringAndWait("Select a difficulty. You are presently on @string(@shopstr). Changing this will cause time to reset. @26<<@choice(1)EASY@choice(2)NORMAL@26@choice(3)HARD>>@domenu()@set(@ttempi @chosen)@close()",true);
					tangoTempI--;
					if(tangoTempI!=getGlobalVar(GVAR_DIFFICULTY,GV_MISC)){
						updateDifficulty(tangoTempI);
						saveTheGame();
						Link->Warp(0,0x10);
						resetTime();
					}
				}
			break;}
			
			case -1:{
				
			break;}
			
			default:{
				TraceS("[NPC][void interact()] NPC id is not assigned! Something is wrong!");TraceNL();
				tangoTempI = NPCid;
				ShowStringAndWait("ERROR: NPC_DIALOGUE NOT FOUND FOR NPC ID @number(@ttempi)");
			}
		}
	}//end interact
	
	//start bankFuncs
	bool bankDeposit(){
		bool notnew = fullCounter(CR_BANKBAL);
		int deposited = 0;
		if(fullCounter(CR_BANKBAL)){
			ShowNPCStringAndWait("Excuse me, but let me take a look at you...@delay(120)@26Ah, yes... {{@savename()}}.@26If I remember, you're the little guy who deposited ((@number(@bankbal) rupees)).",2);
		}
		if(!bankMaxDeposit()){
			if(fullCounter(CR_RUPEES)<=0){
				ShowNPCStringAndWait("Hmm... You play mean jokes, little guy! You haven't even got a single ((Rupee))!@delay(120)@26Come back and deposit some after you save up a bunch!",2);
				notnew=false;
			} else {
				ShowNPCStringAndWait("I can only hold 5000 rupees per account.",2);
			}
		} else {
			deposited = chooseTripleDigitNum(bankMaxDeposit(),SFX_BANKMENU);
			Game->DCounter[CR_RUPEES]-=deposited;
			Game->DCounter[CR_BANKBAL]+=deposited;
		}
		if(notnew){
			ShowNPCStringAndWait("All right, little guy, now I've got a total of ((@number(@bankbal) Rupees)) from you!",2);
			ShowNPCStringAndWait("Come back and deposit some after you save up a bunch!",2);
		}
		return deposited;
	}
	
	bool bankWithdraw(){
		ShowNPCStringAndWait("Excuse me, but let me take a look at you...@delay(120)@26Ah, yes... {{@savename()}}.@26If I remember, you're the little guy who deposited ((@number(@bankbal) rupees)).",2);
		if(!bankMaxWithdraw()){
			ShowNPCStringAndWait("You can't hold any more rupees, little guy!",2);
			return 0;
		} else {
			ShowNPCStringAndWait("So...",2);
		}
		int withdrawn = chooseTripleDigitNum(bankMaxWithdraw(),SFX_BANKMENU);
		Game->DCounter[CR_RUPEES]+=withdrawn;
		Game->DCounter[CR_BANKBAL]-=withdrawn;
		if(fullCounter(CR_BANKBAL))ShowNPCStringAndWait("Come back and deposit some after you save up a bunch!",2);
		else ShowNPCStringAndWait("Look, little guy, all the ((Rupees)) you deposited are gone, so you can't use that {{stamp}} anymore.",2);
		return withdrawn;
	}//end bankFuncs
}
//end NPC
//start FFC Cutscene 
//Key: 1 = One-Time, R = Repeating (resets each cycle)
bool HMS_visible = false;
bool CS1_seen = false;
ffc script cutscene{
	void run(int cutsceneID, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7){
		this->Data = COMBO_INVIS;
		bool waiting = true;
		if(cutsceneID==1){//start Happy Mask Salesman appears behind you! (1)
				if(CS1_seen){
					HMS_visible = true;
					Quit();
				}
				while(!CS1_seen){
					while(waiting){
						if(Link->X>this->X-32&&Link->X<this->X+32&&Link->Y>this->Y-8){
							waiting=false;
						}
						Waitframe();
					}
					if(CS1_seen){
						Quit();
					}
					HMS_visible = true;
					NoAction();
					Waitframe();
					Game->PlaySound(220);
					ShowMessageAndWait(5);
					Link->Y=this->Y-16;
					waiting=true;
				}
				//end 1
		}else if(cutsceneID==2){//start Opening the Festival Door (R)
				while(waiting){
					if(day==3&&!hour&&!time){
						//Play SFX for festival door opening //UNFINISHED//
					}
					if(isAfter(3,24,true)){
						Waitframe();
						Screen->ComboD[ComboAt(this->X+15,this->Y+15)]+=2;
						Screen->ComboD[ComboAt(this->X,this->Y+15)]+=2;
						Screen->ComboD[ComboAt(this->X+15,this->Y)]+=2;
						Screen->ComboD[ComboAt(this->X,this->Y)]+=2;
						waiting=false;
					}
					Waitframe();
				}
				//end 2
		}else if(cutsceneID==3){//start SCT Tower building & chest (R)
				int combos[] = {ComboAt(this->X,this->Y),ComboAt(this->X+16,this->Y),ComboAt(this->X+32,this->Y),ComboAt(this->X,this->Y+16),ComboAt(this->X+16,this->Y+16),ComboAt(this->X+32,this->Y+16)};
				bool waiting2 = true;
				while(waiting){
					Waitframe();
					if(!arg1){
						if(day>=2){
							for(int i=0;i<6;i++){
								Screen->ComboD[combos[i]]=38402;
							}
							if(Link->X>=this->X-8&&Link->X<this->X+48&&Link->Y>=this->Y-8&&Link->Y<this->Y+32){
								Link->X=this->X+16;
								Link->Y=this->Y+32;
							}
							while(true){
								for(int i=0;i<6&&!hideLayer4;i++){
									Screen->FastCombo(4,ComboX(combos[i]),ComboY(combos[i]),38400,2,OP_TRANS);
								}
								if(waiting2&&day==3){
									waiting2=false;
									int args[8] = {0,1,1};
									ffc f = Screen->LoadFFC(RunFFCScript(FFC_CHEST,args));
									f->X=this->X+16;
									f->Y=this->Y;
									f->Flags[FFCF_OVERLAY]=true;
									f->Flags[FFCF_TRANS]=true;
								}
								Waitframe();
							}
						}
					} else if(arg1==1){
						if(day>=2&&waiting2){
							for(int i=0;i<6;i++){
								//if((i==2 && day == 3 && hour < 18) || (i==3 && day == 2))continue;
								Screen->ComboD[combos[i]]=38404;
								Screen->ComboC[combos[i]]=2;
							}
							waiting2=false;
						}
						if(day==3){
							int args[8] = {39,1};
							ffc f = Screen->LoadFFC(RunFFCScript(FFC_CHEST,args));
							f->X=this->X+16;
							f->Y=this->Y;
							waiting=false;
						}
					} else if(arg1==2){
						if(day==3){
							int args[8] = {0,1,1};
							ffc f = Screen->LoadFFC(RunFFCScript(FFC_CHEST,args));
							f->X=this->X+16;
							f->Y=this->Y;
							f->Flags[FFCF_OVERLAY]=true;
							f->Flags[FFCF_TRANS]=true;
							waiting=false;
						}
					}
				}
				//end
		}
	}
}
//end
//start ArrowChange
item script arrowTypes{
	void run(int type){
		arrowType = type;
	}
}
//end ArrowChange
//start DekuNuts
item script DekuNuts{
	void run(int stunSeconds){
		if(Game->Counter[CR_DEKUNUTS]>0){
			Game->PlaySound(SFX_DEKUNUT_SNAP);
			bool freeze = false;
			for(int i = 0;i<countNPCInRange(CenterLinkX(),CenterLinkY(),40);i++){
				npc n = getNthNPCInRange(CenterLinkX(),CenterLinkY(),40,i);
				if((!n->Defense[NPCD_SCRIPT10]||n->Defense[NPCD_SCRIPT10]==3||n->Defense[NPCD_SCRIPT10]==4||n->Defense[NPCD_SCRIPT10]==5)&&!n->Stun){
					n->Stun=stunSeconds*60;
					freeze = true;
				}
			}
			if(freeze)Game->PlaySound(SFX_DEKUNUT_FREEZE);
			Game->Counter[CR_DEKUNUTS]--;
		}
	}
}
//end DekuNuts
//start RazorSword
void razorSwordCheck(){
	if(swordCounter>=RAZSWORD_USES){
		Link->Item[RAZSWORD_ID]=false;
		swordCounter=0;
	}
}

item script razorSword{
	void run(){
		swordCounter++;
	}
}
//end RazorSword
//start SoftSoil
//const int LW_WATER = 0;//from EmptyBottles
//const int LW_HOTWATER = 0;//from EmptyBottles
const int COMBO_SOIL = 13920;
const int COMBO_BEANSPROUT = 13921;
const int COMBO_BEANPLANT = 13922;
const int FFC_STATE = 15;
const int SCRIPTSLOT_SOFTSOIL = 10;
//int usingBugs = 0;//from EmptyBottles
int beanCounter = 0;
ffc script SoftSoil{
	void run(int raftDir, int screensUp, bool gskull, int startState){
		this->X = GridX(this->X);
		this->Y = GridY(this->Y);
		int waitTime = 0;
		if(startState==2){
			this->X=GridX(Link->X+8);
			this->Y=GridY(Link->Y+8);
		}
		this->Misc[FFC_STATE]=startState;
		while(true){
			if(!this->Misc[FFC_STATE]){
				this->Data = COMBO_SOIL;
				if(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8){
					if(usingBugs>0&&!gskull){
						usingBugs=0;
						Waitframes(120);
						int numitems = Rand(3,6);
						for(int i=0;i<numitems;i++){
							int itemPick = Rand(1,100);
							int id = 0;
							if(itemPick<=33)id=0;
							else if(itemPick<=60)id=1;
							else if(itemPick<=70)id=38;
							else if(itemPick<=75)id=87;
							else if(itemPick<=85)id=73;
							else if(itemPick<=95)id=80;
							else id = 156;
							int x = Clamp(this->X+Rand(-32,32),0,240);
							int y = Clamp(this->Y+Rand(-32,32),0,160);
							item itm1 = CreateItemAt(id,x,y);
							itm1->Pickup=IP_TIMEOUT;
						}
					} else if(usingBugs>0){
						//UNFINISHED// Spawn Gold Skulltula
						usingBugs=0;
					}
					if(beanCounter>0){
						this->Misc[FFC_STATE]=1;
						Game->Counter[CR_MAGICBEANS]--;
						beanCounter=0;
					}
				}
			} 
			if(this->Misc[FFC_STATE]==1){
				this->Data = COMBO_BEANSPROUT;
				if(playedSong==SONG_SongOfStorms)this->Misc[FFC_STATE]=2;
				if(this->Misc[FFC_STATE]==1){
					for(int i=1; i<=Screen->NumLWeapons(); i++){
						lweapon l = Screen->LoadLWeapon(i);
						if((l->ID==LW_WATER||l->ID==LW_HOTWATER)&&Collision(this, l)){
							this->Misc[FFC_STATE] = 2;
						}
					}
				}
			} 
			if(this->Misc[FFC_STATE]==2){
				this->Data = COMBO_BEANPLANT;
				if(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y-8&&Link->Y<this->Y+8){
					Link->X = this->X;
					Link->Y = this->Y;
					//if(startState==2)Waitframe();
					Rafting[RAFT_DIR] = raftDir;
					Rafting[RAFT_UP] = screensUp;
					if(startState==2){
						Rafting[RAFT_X] = this->X - 5*dirX(raftDir);
						Rafting[RAFT_Y] = this->Y - 5*dirY(raftDir);
					} else {
						Rafting[RAFT_X] = -1;
						Rafting[RAFT_Y] = -1;
					}
					this->Misc[FFC_STATE] = 3;
					canFall=false;
					waitTime=5;
				}
			}
			if(this->Misc[FFC_STATE]==3){
				if(Link->Action==LA_RAFTING){
					if(startState==2){
						this->Data = COMBO_INVIS;
					} else {
						this->Data = COMBO_SOIL;
					}
				}
				if(waitTime>0){
					waitTime--;
				} else if(!Link->Action==LA_RAFTING&&startState!=2){
					this->Misc[FFC_STATE]=2;
					Rafting[RAFT_DIR] = -1;
					Rafting[RAFT_UP] = -1;
				}
			}
			Waitframe();
		}
	}
}

item script MagicBean{
	void run(){
		if(Game->Counter[CR_MAGICBEANS]>0)
			beanCounter=10;
	}
}

//end SoftSoil
//start AmmoRefiller
ffc script AmmoRefiller{
	void run(int itemID, int framesToWait, bool spawnMultiple){
		this->Data = COMBO_INVIS;
		for(int i=0;true;i++){
			if(!(i%framesToWait)){
				item it = CreateItemAt(itemID,this->X,this->Y);
				if(!spawnMultiple){
					while(it->isValid())Waitframe();
				}
			}
			if(i==framesToWait*10)i=0;
			Waitframe();
		}
	}
}
//end AmmoRefiller
//start TorchPuzzle
//Torch puzzles!
//defNum should be a 16-bit number with the first X bits filled, where X is 16 - the total number of torches.
//thisNum should be a 16-bit number where exactly 1 bit is true, with each torch in the puzzle having a seperate bit.
//timer is the total timer for the puzzle completion.
//puzzleNum is a unique number for each puzzle
//defNum and timer and puzzleNum should be the same for all torches, thisNum should be different for every torch.
ffc script TorchPuzzle{
	void run(int thisNum, int defNum, int unlitCombo, int litCombo, int timer, int puzzleNum, bool noSecretSFX){
		if(!torchPuzzleStates[puzzleNum]){
			bool lit = false;
			torchPuzzleState = torchPuzzleState | defNum;
			if((torchPuzzleState & thisNum) == thisNum){
				this->Data = litCombo;
				lit = true;
			} else {
				this->Data = unlitCombo;
			}
			while(!torchPuzzleStates[puzzleNum]){
				if(!lit){
					if(torchLight(this)){
						if(!torchPuzzleTimer)torchPuzzleTimer=timer;
						lit = true;
						this->Data = litCombo;
						torchPuzzleState = torchPuzzleState | thisNum;
					}
				} else {
					stickLight(this);
					if(!torchPuzzleTimer){
						lit = false;
						this->Data = unlitCombo;
						torchPuzzleState = defNum;
					}
					if(torchPuzzleState==1111111111111111b&&!torchPuzzleStates[puzzleNum]){
						torchPuzzleStates[puzzleNum]=true;
						Game->PlaySound(SFX_SECRET);
					}
				}
				Waitframe();
			}
		}
		this->Data = litCombo;
		while(true){
			stickLight(this);
			Waitframe();
		}
	}
}

ffc script LitTorch{
	void run(){
		while(true){
			stickLight(this);
			Waitframe();
		}
	}
}

bool torchLight(ffc torch){
	for(int i = 1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()&&weap->ID==LW_DEKUSTICK){
			if(!dekuStickLitTimer)continue;
			return Collision(torch, weap);
		} else if(weap->isValid()&&weap->ID==LW_ARROW&&arrowType==ARRTYPE_FIRE){
			return Collision(torch, weap);
		}
	}
}

void stickLight(ffc torch){
	if(dekuStickLitTimer!=DEKU_MAX_TIMER){
		for(int i = 1;i<=Screen->NumLWeapons();i++){
			lweapon weap = Screen->LoadLWeapon(i);
			if(weap->isValid()&&weap->ID==LW_DEKUSTICK){
				if(Collision(torch, weap)){
					dekuStickLitTimer=DEKU_MAX_TIMER;
				}
			} else if(weap->isValid()&&weap->ID==LW_ARROW&&!arrowType){
				if(Collision(torch, weap)){
					arrowType=ARRTYPE_FIRE;
					weap->UseSprite(SPRITE_FIREARROW);
					if(weap->Dir==DIR_RIGHT){
						weap->Tile+=1;
						weap->Flip=0;
					} else if(weap->Dir==DIR_LEFT){
						weap->Tile+=1;
						weap->Flip=1;
					}
				}
			}
		}
	}
}

ffc script TorchSecrets{
	void run(int numPuzzle){
		this->Data=COMBO_INVIS;
		while(!torchPuzzleStates[numPuzzle])Waitframe();
		Screen->TriggerSecrets();
	}
}

const int LW_DEKUSTICK = 34;
const int TILE_DEKUSTICK_UNLIT = 64180;
const int TILE_DEKUSTICK_LIT = 64200;
item script dekuStick{
	void run(){
		if(!Link->PressB)Quit();
		for(int i = 1;i<=Screen->NumLWeapons();i++){
			lweapon weap = Screen->LoadLWeapon(i);
			if(weap->isValid()&&weap->ID==LW_DEKUSTICK){
				Quit();
			}
		}
		lweapon stick = CreateLWeaponAt(LW_DEKUSTICK,Link->X+InFrontX(Link->Dir,0),Link->Y+InFrontY(Link->Dir,0));
		stick->Dir = Link->Dir;
		if(dekuStickLitTimer>0){
			stick->Tile = TILE_DEKUSTICK_LIT + stick->Dir;
			stick->OriginalTile = stick->Tile;
		} else {
			stick->Tile = TILE_DEKUSTICK_UNLIT + stick->Dir;
			stick->OriginalTile = stick->Tile;
		}
		stick->Step = 0;
		stick->CollDetection = false;
		stick->DeadState = 15;
		freezeFrames+=15;
		Link->Action = LA_ATTACKING;
	}
}
//end TorchPuzzle
//start MeltableIce
void handleMeltableIce(){
	for(int i=1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if((weap->ID==LW_ARROW&&arrowType==ARRTYPE_FIRE)||weap->ID==LW_HOTWATER){
				int combos[4] = {ComboAt(weap->X,weap->Y),ComboAt(weap->X+15,weap->Y),ComboAt(weap->X,weap->Y+15),ComboAt(weap->X+15,weap->Y+15)};
				for(int i=0;i<4;i++){
					if(Screen->ComboI[combos[i]]==CF_SCRIPT_ICE){
						Screen->ComboD[combos[i]]--;
					}
				}
			}
		}
	}
}
//end MeltableIce
//start FreezableWater
void handleFreezableWater(){
	for(int i=1;i<=Screen->NumLWeapons();i++){
		lweapon weap = Screen->LoadLWeapon(i);
		if(weap->isValid()){
			if(weap->ID==LW_ARROW&&arrowType==ARRTYPE_ICE){
				int combos[4] = {ComboAt(weap->X,weap->Y),ComboAt(weap->X+15,weap->Y),ComboAt(weap->X,weap->Y+15),ComboAt(weap->X+15,weap->Y+15)};
				for(int i=0;i<4;i++){
					if(Screen->ComboI[combos[i]]==CF_SCRIPT1&&Screen->ComboT[combos[i]]==CT_WATER){
						Screen->ComboD[combos[i]]++;
					}
				}
			}
		}
	}
}
//end FreezableWater
//start LedgeTooHighFromWater
const int CF_NOWATERLEDGE = 110;//script11 //Can only get out by using deku or freezing water
const int CF_NOWATERLEDGE2 = 111;//script12 //Can only get out by freezing water
bool wasOnWaterLedge = false;
void highLedgeFromWater(){
	if(!wasOnWaterLedge){
		if(Link->Action==LA_SWIMMING){
			if(LinkOnFlagMod(CF_NOWATERLEDGE2,0,LinkMovement[LM_STICKY]*3,0,true)||(form!=1&&LinkOnFlagMod(CF_NOWATERLEDGE,0,LinkMovement[LM_STICKY]*3,0,true))){
				if(LinkMovement[LM_STICKX]==0){
					if(LinkMovement[LM_STICKY]==1){
						Link->Dir=DIR_DOWN;
					} else if (LinkMovement[LM_STICKY]==-1){
						Link->Dir=DIR_UP;
					}
				}
				Link->InputDown=false;
				Link->InputUp=false;
				LinkMovement_SetLinkSpeedBoost(0);
			}
			if(LinkOnFlagMod(CF_NOWATERLEDGE2,LinkMovement[LM_STICKX]*3,0,0,true)||(form!=1&&LinkOnFlagMod(CF_NOWATERLEDGE,LinkMovement[LM_STICKX]*3,0,0,true))){
				if(LinkMovement[LM_STICKY]==0){
					if(LinkMovement[LM_STICKX]==1){
						Link->Dir=DIR_RIGHT;
					} else if (LinkMovement[LM_STICKX]==-1){
						Link->Dir=DIR_LEFT;
					}
				}
				Link->InputLeft=false;
				Link->InputRight=false;
				LinkMovement_SetLinkSpeedBoost(0);
			}
		} else {
			wasOnWaterLedge=LinkOnFlag(CF_NOWATERLEDGE)||LinkOnFlag(CF_NOWATERLEDGE2);
		}
	} else {
		wasOnWaterLedge=LinkOnFlag(CF_NOWATERLEDGE)||LinkOnFlag(CF_NOWATERLEDGE2);
	}
}

//end LedgeTooHighFromWater
//start sidequests
int hasQuestItem(int itemslot){
	if(itemslot==1){
		if(Link->Item[182])return 5;
		else if(Link->Item[181])return 4;
		else if(Link->Item[180])return 3;
		else if(Link->Item[179])return 2;
		else if(Link->Item[178])return 1;
		else return 0;
	} else if(itemslot==2){
		if(Link->Item[186])return 1;
		else return 0;
	} else if(itemslot==3){
		if(Link->Item[184])return 3;
		else if(Link->Item[185])return 2;
		else if(Link->Item[183])return 1;
		else return 0;
	}
}

int getQuestItem(int itemslot, int num){
	if(!num)num = hasQuestItem(itemslot);
	if(!num)return 0;
	if(itemslot==1){
		int qits[] = {178,179,180,181,182};
		return qits[num-1];
	} else if(itemslot==2){
		return 186;
	} else if(itemslot==3){
		int qits[] = {183,185,184};
		return qits[num-1];
	}
}
//end sidequests
//start FFC Climb
ffc script climb{
	void run(int dir, int blockheight){
		int lspdboost = Ceiling(1.5+LinkMovement_GetLinkSpeedBoost());
		int width = this->EffectWidth;
		int height = this->EffectHeight;
		int bottomheight = height;
		if(Link->BigHitbox)bottomheight-=8;
		while(true){
			if(!isFrozen&&(blockheight>2||form==1||(blockheight==2&&(!form||form==2)))){
				if(dir==DIR_UP||dir==4){
					if(Link->Y>=this->Y-(16+lspdboost)){//start inputdown
						if(Link->Y<=this->Y-16){
							if(Link->X>=this->X-15){
								if(Link->X<=this->X+(width-1)){
									if(Link->InputDown){
										if(Link->Y!=this->Y-16)Link->Y=this->Y-16;
										Link->Dir=DIR_DOWN;
										if(Link->X>=this->X+(width-4)){
											if(CanWalk(Link->X,Link->Y,DIR_RIGHT,Abs(Link->X-(this->X+width)),false))Link->X=this->X+width;
										} else if(Link->X<=this->X-12)if(CanWalk(Link->X,Link->Y,DIR_LEFT,Abs(Link->X-this->X-16),false))Link->X=this->X-16;
									}
									Link->InputDown=false;
									Link->PressDown=false;
								}
							}
						}//end
					}
				}
				if(dir==DIR_DOWN||dir==4){
					if(Link->Y<=this->Y+(bottomheight+lspdboost)){//start inputup
						if(Link->Y>=this->Y+bottomheight){
							if(Link->X>=this->X-15){
								if(Link->X<=this->X+(width-1)){
									if(Link->InputUp){
										if(Link->Y!=this->Y+bottomheight)Link->Y=this->Y+bottomheight;
										Link->Dir=DIR_UP;
										if(Link->X>=this->X+(width-4)){
											if(CanWalk(Link->X,Link->Y,DIR_RIGHT,Abs(Link->X-(this->X+width)),false))Link->X=this->X+width;
										} else if(Link->X<=this->X-12)if(CanWalk(Link->X,Link->Y,DIR_LEFT,Abs(Link->X-this->X-16),false))Link->X=this->X-16;
									}
									Link->InputUp=false;
									Link->PressUp=false;
								}
							}
						}//end
					}
				}
				if(dir==DIR_LEFT||dir==4){
					if(Link->X>=this->X-(16+lspdboost)){//start inputright
						if(Link->X<=this->X-16){
							if(Link->Y<=this->Y+(bottomheight-1)){
								if(Link->Y>=this->Y-15){
									if(Link->InputRight){
										if(Link->X!=this->X-16)Link->X=this->X-16;
										Link->Dir=DIR_RIGHT;
										if(Link->Y>=this->Y+(bottomheight-4)){
											if(CanWalk(Link->X,Link->Y,DIR_DOWN,Abs(Link->Y-(this->Y+bottomheight)),false))Link->Y=this->Y+bottomheight;
										} else if(Link->Y<=this->Y-12)if(CanWalk(Link->X,Link->Y,DIR_UP,Abs(Link->Y-(this->Y-16)),false))Link->Y=this->Y-16;
									}
									Link->InputRight=false;
									Link->PressRight=false;
								}
							}
						}//end
					}
				}
				if(dir==DIR_RIGHT||dir==4){
					if(Link->X<=this->X+(width+lspdboost)){//start inputleft
						if(Link->X>=this->X+width){
							if(Link->Y>=this->Y-15){
								if(Link->Y<=this->Y+(bottomheight-1)){
									if(Link->InputLeft){
										if(Link->X!=this->X+width)Link->X=this->X+width;
										Link->Dir=DIR_LEFT;
										if(Link->Y>=this->Y+(bottomheight-4)){
											if(CanWalk(Link->X,Link->Y,DIR_DOWN,Abs(Link->Y-(this->Y+bottomheight)),false))Link->Y=this->Y+bottomheight;
										} else if(Link->Y<=this->Y-12)if(CanWalk(Link->X,Link->Y,DIR_UP,Abs(Link->Y-(this->Y-16)),false))Link->Y=this->Y-16;
									}
									Link->InputLeft=false;
									Link->PressLeft=false;
								}
							}
						}//end
					}
				}
			}
			Waitframe();
		}
	}
}
//end
//start FFC conditionalItem
ffc script conditionalItem{
	void run(int id){
		
	}
}
//end FFC conditionalItem
//start FFC warp
ffc script warpCustomReturn{
	//Dirs: 0=Tile, 1=Up, 2=Down, 3=Left, 4=Right
	void run(int dmap, int screen, int X, int Y, int side){
		side-=1;
		switch(side){
			case DIR_UP:{
				while(true){
					if(!isFrozen&&Link->Y<=1&&(Link->PressUp||Link->InputUp)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			case DIR_DOWN:{
				while(true){
					if(!isFrozen&&Link->Y>=159&&(Link->PressDown||Link->InputDown)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			case DIR_LEFT:{
				while(true){
					if(!isFrozen&&Link->X<=1&&(Link->PressLeft||Link->InputLeft)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			case DIR_RIGHT:{
				while(true){
					if(!isFrozen&&Link->X>=239&&(Link->PressRight||Link->InputRight)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
			default:{
				while(true){
					if(!isFrozen&&(Abs(Link->X-this->X)<=14&&Abs(Link->Y-this->Y)<=14)){
						Link->X=X;
						Link->Y=Y;
						Link->PitWarp(dmap,screen);
					}
					Waitframe();
				}
			break;}
		}
	}
}
//end FFC warp
//start owlStatue
const int COMBO_OWLOFF = 38380;
const int COMBO_OWLON = 38384;
int owlStates = 0000000000b;
ffc script owlStatue{//start
	void run(int index,bool isFake){
		int trueValue = Pow(2,index);
		if((owlStates & trueValue)==trueValue){
			this->Data=COMBO_OWLON;
		} else {
			this->Data=COMBO_OWLOFF;
		}
		while(!isFake){
			if(!form){
				for(int i=0;i<countLWeaponType(LW_SWORD);i++){
					lweapon weap = loadLWeaponType(LW_SWORD,i);
					if(weap->isValid()&&Collision(weap,this)){
						Waitframes(2);
						this->Data=COMBO_OWLON;
						owlStates|=trueValue;
						while(weap->isValid())Waitframe();
						Waitframe();
						quickSave(Game->GetCurDMapScreen(),Game->GetCurDMap());
					}
				}
			}
			Waitframe();
		}
	}
}//end
void warpToOwl(int index){//start
	switch(index){
		case 0:
			Link->Warp(1,0x6B);
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		case 6:
			break;
		case 7:
			break;
		case 8:
			break;
		case 9:
			break;
	}//UNFINISHED// add more owls
}//end
void quickSave(int scrn, int dmap){//start
	tangoTemp=false;
	ShowMessageAndWait(43);
	if(tangoTemp){
		owlSaved=true;
		Game->ContinueDMap=dmap;
		Game->ContinueScreen=scrn;
		saveTheGame();
		Game->End();
	}
}//end
//end owlStatue
//start Shop
const int STR_SHOPS = 37;
int shopString[1024];
int shopPrice = 0;
ffc script Shop{
	void run(int itemID, int price, int shopSpecial, bool reqBottle){
		if(shopSpecial!=0){
			//handle each shop id seperately, altering "itemID".
		}
		if(!itemID)Quit();
		item thisVisual = CreateItemAt(itemID, this->X, this->Y);
		thisVisual->Pickup=IP_DUMMY;
		this->Data=COMBO_INVIS;
		int loc = ComboAt(this->X,this->Y);
        while(true){
            while(!AgainstComboBase(loc) || !SelectPressInput(0)){ 
				if(!thisVisual->isValid()){
					thisVisual = CreateItemAt(itemID, this->X, this->Y);
					thisVisual->Pickup=IP_DUMMY;
				}
				Waitframe();
			}
            SetInput(0,false);
			//Set shop vars
			tangoTemp=false;
			remchr(shopString,0);
			itemdata i = Game->LoadItemData(itemID);
			i->GetName(shopString);
			shopPrice=price;
			//
			bool hasEmptyBottle = CanFillBottle();
			if((fullCounter(CR_RUPEES))>=price&&(!reqBottle||hasEmptyBottle)){
				ShowMessageAndWait(STR_SHOPS);
				if(tangoTemp){
					item itm = CreateItemAt(itemID, Link->X, Link->Y);
					itm->Pickup = IP_HOLDUP;
					Game->DCounter[CR_RUPEES] -= price;
					WaitNoAction(10);
				}
			} else if(reqBottle&&!hasEmptyBottle){
				ShowMessageAndWait(30);//No bottle
			} else {
				ShowMessageAndWait(29);//No money
			}
        }
	}
    bool AgainstComboBase(int loc){
		return Link->Z == 0 && (Link->Dir == DIR_UP && (Link->Y >= ComboY(loc)+8&&Link->Y <ComboY(loc)+16) && Abs(Link->X-ComboX(loc)) < 8);
    }
}
//end Shop
//start chests
const int SFX_CHEST_APPEAR = SFX_SECRET;
ffc script chest{
	void run(int itemID, int index, bool fake, bool killAllEnemies){
		if(this->Data==COMBO_INVIS||!this->Data)this->Data=38385;
		int closed = this->Data;
		int open = this->Data+1;
		if(getChestState(index))this->Data=open;
		if(killAllEnemies&&EnemiesAlive())this->Data=COMBO_INVIS;
		bool solid = (!(this->X%16)&&!(this->Y%16))&&!this->Flags[FFCF_TRANS];
		if(solid&&(!killAllEnemies||getChestState(index)))Screen->ComboD[ComboAt(this->X,this->Y)]=COMBO_SOLID;
		while(!fake){
			if(getChestState(index)){
				this->Data=open;
				while(true){
					if(!solid)ffcSolid(this);
					Waitframe();
				}
			} else {
				while(killAllEnemies&&EnemiesAlive())Waitframe();
				if(killAllEnemies){
					killAllEnemies=false;
					Game->PlaySound(SFX_CHEST_APPEAR);
					this->Data=closed;
					if(solid)Screen->ComboD[ComboAt(this->X,this->Y)]=COMBO_SOLID;
				}
				if(!solid)ffcSolid(this);
				if(Link->PressA&&AgainstComboBase(this->X,this->Y)){
					Link->PressA=false;Link->InputA=false;
					if(Link->Item[itemID]){
						itemID=1;
					}
					this->Data=open;
					item itm = CreateItemAt(itemID,Link->X,Link->Y);
					itm->Pickup=IP_HOLDUP;
					setChestState(index,true);
				}
			}
			Waitframe();
		}
	}
	bool AgainstComboBase(int x, int y){
		return Link->Z == 0 && ((Link->Dir == DIR_UP && Link->Y == y+8 && Abs(Link->X-x) < 8)||(Link->Dir == DIR_DOWN && Link->Y == y-16 && Abs(Link->X-x) < 8)||(Link->Dir == DIR_LEFT && Link->X == x+16 && Abs(Link->Y-y) < 8)||(Link->Dir == DIR_RIGHT && Link->X == x-16 && Abs(Link->Y-y) < 8));
    }
}
//end chests
//start ladder/vine
ffc script LadderClimb{
	void run(int climbtime, int dir, int floorsUp){
		int ctime = 0;
		while(true){
			if(ctime>=climbtime){
				Link->X+=dirX(dir)*16;
				Link->Y+=dirY(dir)*16;
				warpNumFloors=floorsUp;
			}
			switch(dir){
				case DIR_UP:{
					if(Link->Y==this->Y){
						if(Link->InputUp)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
				case DIR_DOWN:{
					if(Link->Y==this->Y){
						if(Link->InputDown)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
				case DIR_LEFT:{
					if(Link->X==this->X){
						if(Link->InputLeft)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
				case DIR_RIGHT:{
					if(Link->X==this->X){
						if(Link->InputRight)ctime++;
						else ctime=0;
					} else ctime=0;
					break;}
			}
		}
	}
}
//end ladder/vine
//start bank
const int CR_BANKBAL = 10;
GVAR GVAR_BANK_REW1 = 1;
GVAR GVAR_BANK_REW2 = 2;
GVAR GVAR_BANK_REW3 = 3;
int bankMaxWithdraw(){
	int fee = 0;
	if(isBetween(0,6))fee=4;
	return Max(0,Min(Game->MCounter[CR_RUPEES]-(fullCounter(CR_RUPEES)),fullCounter(CR_BANKBAL) - fee));
}

int bankMaxDeposit(){
	return Min(fullCounter(CR_RUPEES),5000-fullCounter(CR_BANKBAL));
}

void bankGiveRewards(){
	if(fullCounter(CR_BANKBAL)>=200&&!getGlobalVar(GVAR_BANK_REW1,GV_MISC)){
		if(Link->Item[41]){
			item i = CreateItemAt(42,Link->X,Link->Y);
			i->Pickup = IP_HOLDUP;
		} else {
			item i = CreateItemAt(41,Link->X,Link->Y);
			i->Pickup = IP_HOLDUP;
		}
		ShowStringAndWait("Here, you've deposited enough rupees to earn a reward!");
		setGlobalVar(GVAR_BANK_REW1,GV_MISC,1);
	}
	if(fullCounter(CR_BANKBAL)>=1000&&!getGlobalVar(GVAR_BANK_REW2,GV_MISC)){
		item i = CreateItemAt(1,Link->X,Link->Y);
		i->Pickup = IP_HOLDUP;
		ShowStringAndWait("Here, you've deposited enough rupees to earn another reward!");
		setGlobalVar(GVAR_BANK_REW2,GV_MISC,1);
	}
	if(fullCounter(CR_BANKBAL)>=5000&&!getGlobalVar(GVAR_BANK_REW3,GV_MISC)){
		item i = CreateItemAt(I_HCPIECE,Link->X,Link->Y);
		i->Pickup = IP_HOLDUP;
		ShowStringAndWait("Here, you've deposited enough rupees to earn the final reward!");
		setGlobalVar(GVAR_BANK_REW3,GV_MISC,1);
	}
}

int chooseTripleDigitNum(int max){
	return chooseTripleDigitNum(max,0);
}

int chooseTripleDigitNum(int max, int sfx){
    const int NUMZERO = 11180;
    const int BORDERTILE = 11201;
    const int CURSORTILE = 11200;
    const int FIRSTX = 104;
    const int FIRSTY = 64;
    bool running = true;
    int nums[3];
    int num = 0;
    int cursor = 2;
    Screen_Freeze(1);
    while(running){
        Screen->FastTile(6,FIRSTX,FIRSTY,BORDERTILE,2,OP_OPAQUE);
        Screen->FastTile(6,FIRSTX+16,FIRSTY,BORDERTILE+1,2,OP_OPAQUE);
        Screen->FastTile(6,FIRSTX+32,FIRSTY,BORDERTILE+2,2,OP_OPAQUE);
        if(gameframe%40<20)Screen->FastTile(6,FIRSTX+(cursor*16),FIRSTY,CURSORTILE,2,OP_OPAQUE);
        Screen->FastTile(6,FIRSTX,FIRSTY,NUMZERO+nums[0],2,OP_OPAQUE);
        Screen->FastTile(6,FIRSTX+16,FIRSTY,NUMZERO+nums[1],2,OP_OPAQUE);
        Screen->FastTile(6,FIRSTX+32,FIRSTY,NUMZERO+nums[2],2,OP_OPAQUE);
        if(Link->PressUp){
            nums[cursor]++;
            if(nums[cursor]>9)nums[cursor]-=10;
			Audio->PlaySound(sfx);
        } else if(Link->PressDown){
            nums[cursor]--;
            if(nums[cursor]<0)nums[cursor]+=10;
			Audio->PlaySound(sfx);
        }
        if(Link->PressRight){
            cursor++;
            if(cursor>2)cursor-=3;
			Audio->PlaySound(sfx);
        } else if(Link->PressLeft){
            cursor--;
            if(cursor<0)cursor+=3;
			Audio->PlaySound(sfx);
        }
        if(Link->PressA){
            num = (nums[0]*100)+(nums[1]*10)+(nums[2]);
            if(num>max){
                num=max;
				nums[0]=Floor(num/100);
				nums[1]=Floor(num/10)%10;
				nums[2]=num%10;
				Audio->PlaySound(sfx);
            } else {
                running=false;
            }
        }
        TotalNoAction();
        Waitframe();
    }
    Screen_Freeze(0);
    return num;
}
//end bank
//start NameChange
ffc script renameLink
{
	void run()
	{
		const int CHAR0 = 11260;
		const int BORDERTILE = 11196;
		const int CURSORTILE = 11200;
		const int FIRSTX = 64;
		const int FIRSTY = 64;
		const int CHAR_OFFSET = -32;// The CHAR0 tile points to the "Spacebar" character, which is character 32; thus a character must be offset by -32 to get the correct tile.
		const int Y_OFFSET = -1;
		const int X_OFFSET = 0;
		Screen_Freeze(1);
		startTypingMode(8,true);
		int buf[9];
		int cursor = 0;
		while(true)
		{
			cursor = __getTvar(TVAR_INDEX);
			Screen->FastTile(6,FIRSTX-16,FIRSTY-16,BORDERTILE,2,OP_OPAQUE);
			Screen->FastTile(6,FIRSTX-16,FIRSTY,BORDERTILE+20,2,OP_OPAQUE);
			Screen->FastTile(6,FIRSTX-16,FIRSTY+16,BORDERTILE+40,2,OP_OPAQUE);
			for(int i = FIRSTX; i <= FIRSTX+(16*7); i+=16)
			{
				Screen->FastTile(6,i,FIRSTY-16,BORDERTILE+1,2,OP_OPAQUE);
				Screen->FastTile(6,i,FIRSTY,BORDERTILE+1+20,2,OP_OPAQUE);
				Screen->FastTile(6,i,FIRSTY+16,BORDERTILE+1+40,2,OP_OPAQUE);
			}
			Screen->FastTile(6,FIRSTX+(16*7)+16,FIRSTY-16,BORDERTILE+2,2,OP_OPAQUE);
			Screen->FastTile(6,FIRSTX+(16*7)+16,FIRSTY,BORDERTILE+2+20,2,OP_OPAQUE);
			Screen->FastTile(6,FIRSTX+(16*7)+16,FIRSTY+16,BORDERTILE+2+40,2,OP_OPAQUE);
			if(((gameframe%40)<20) && __getTvar(TVAR_INDEX)<8)Screen->FastTile(6,FIRSTX+(cursor*16),FIRSTY+Y_OFFSET,CURSORTILE,2,OP_OPAQUE);
			remchr(buf,0);
			getType(buf);
			for(int i = 0; i < 8; i++)
			{
				if(buf[i]==0)continue;
				Screen->FastTile(6,FIRSTX+(i*16)+X_OFFSET,FIRSTY+Y_OFFSET,CHAR0+buf[i]+CHAR_OFFSET,2,OP_OPAQUE);
			}
			//32-126 inclusive
			if(typingJustEnded())
			{    
				if(getTypeLength()>1)
				{
					Game->SetSaveName(buf);
					clearTypedInput();
					Screen_Freeze(0);
					Quit();
				}
				else
					startTypingMode(8,true);
			}
			Waitframe();
		}
	}
}
//end NameChange

//start ShowString
ffc script ShowString{
	void run(int str, int doAfter, bool string){
		if(string)ShowStringAndWait(str);
		else ShowMessageAndWait(str);
		if(!doAfter)Quit();
		switch(doAfter){
			case 1:
				if(tangoTemp){
					saveTheGame();
					Link->Warp(0,0x10);
					resetTime();
				}
				break;
			case 2:
				if(tangoTemp){
					if(hour>=6&&hour<18){
						hour=18;
						time=0;
					} else if(day<3){
						hour=6;
						time=0;
						day++;
					} else if(hour>12){
						hour=0;
						time=0;
					}
				}
				break;
			case 3:
				if(tangoTemp)
					slowTime = !slowTime;
				break;
		}
	}
}
//end ShowString
//start Global Vars Array
int gvars[214747];
GVAR GVAR_BLASTMASKCOOLDOWN = 0;
const int GV_MISC = 0;
GVAR GV_CHEST = GV_PAL + NUM_PAL;
GVAR GVAR_START_RESET = GV_CHEST;
GVAR GVAR_END_RESET = GV_CHEST+1000;
int getGlobalVar(int index, int add){
    return gvars[index+add];
}

void setGlobalVar(int index, int add, int state){
	gvars[index+add]=state;
}

void incGlobalVar(int index, int add, int inc){
	gvars[index+add]+=inc;
}

bool getChestState(int index){
    return getGlobalVar(index,GV_CHEST)!=0;
}

void setChestState(int index, bool state){
	if(state)setGlobalVar(index,GV_CHEST,1);
	else setGlobalVar(index,GV_CHEST,0);
}
//end Global Vars Array
//start Misc Functions
void saveTheGame(){//start
	Screen->DrawScreen(7,LAYERSMAP1,LAYERSCREEN_SAVING,0,0,0);
	Waitframe();
	Game->Save();
}//end
bool linkWalkingOntoFlag(int flag, int setting,bool fullTile){//start
	int lspeed = Ceiling(1.5+LinkMovement_GetLinkSpeedBoost());
	return LinkOnFlagMod(flag,LinkMovement[LM_STICKX]*lspeed,LinkMovement[LM_STICKY]*lspeed,setting,fullTile);
}//end
bool LinkOnFlagMod(int flag, int x, int y, int setting, bool fullTile){//start
	int yCorrection = 0;
	if(!fullTile)yCorrection=8;
	int combos[4] = {ComboAt(Link->X+x,Link->Y+y+yCorrection),ComboAt(Link->X+x+15,Link->Y+y+yCorrection),ComboAt(Link->X+x+15,Link->Y+y+15),ComboAt(Link->X+x,Link->Y+y+15)};
	for(int i=0;i<4;i++){
		if(setting)
			if(Screen->ComboI[combos[i]]==flag)return true;
		if(setting!=1)
			if(Screen->ComboF[combos[i]]==flag)return true;
	}
	return false;
}//end
bool LinkOnFlag(int flag){//start
	int combos[4] = {ComboAt(Link->X,Link->Y),ComboAt(Link->X+15,Link->Y),ComboAt(Link->X+15,Link->Y+15),ComboAt(Link->X,Link->Y+15)};
	for(int i=0;i<4;i++){
		if(Screen->ComboF[combos[i]]==flag)return true;
	}
	return false;
}//end
int dirX(int dir){//start
	if(dir==DIR_RIGHT)return 1;
	else if(dir==DIR_LEFT)return -1;
	else return 0;
}//end
int dirY(int dir){//start
	if(dir==DIR_DOWN)return 1;
	else if(dir==DIR_UP)return -1;
	else return 0;
}//end
void stopScreenTransition(int pxD,int pxR,int pxL, int pxU){//start
	if(Link->Y>160-pxD)Link->InputDown=false;
	if(Link->X>240-pxR)Link->InputRight=false;
	if(Link->X<0+pxL)Link->InputLeft=false;
	if(Link->Y<0+pxU)Link->InputUp=false;
}//end
void NoActionButMoveAndEx4(){//start
	Link->InputA=false;Link->PressA=false;
	Link->InputB=false;Link->PressB=false;
	Link->InputR=false;Link->PressR=false;
	Link->InputL=false;Link->PressL=false;
	Link->InputEx1=false;Link->PressEx1=false;
	Link->InputEx2=false;Link->PressEx2=false;
	Link->InputEx3=false;Link->PressEx3=false;
}//end
void TotalNoAction(){//start
	NoAction();
	Link->PressStart=false;
	Link->InputStart=false;
}//end
void NoActionButA(){//start
	Link->InputDown=false;Link->PressDown=false;
	Link->InputRight=false;Link->PressRight=false;
	Link->InputLeft=false;Link->PressLeft=false;
	Link->InputUp=false;Link->PressUp=false;
	Link->InputB=false;Link->PressB=false;
	Link->InputR=false;Link->PressR=false;
	Link->InputL=false;Link->PressL=false;
	Link->InputEx1=false;Link->PressEx1=false;
	Link->InputEx2=false;Link->PressEx2=false;
	Link->InputEx3=false;Link->PressEx3=false;
}//end
void NoActionButMoveAndEx4AndA(){//start
	Link->InputB=false;Link->PressB=false;
	Link->InputR=false;Link->PressR=false;
	Link->InputL=false;Link->PressL=false;
	Link->InputEx1=false;Link->PressEx1=false;
	Link->InputEx2=false;Link->PressEx2=false;
	Link->InputEx3=false;Link->PressEx3=false;
}//end
bool isTouchingCombo(int comboID){//start
	int x = Link->X;
	int y = Link->Y;
	if(Screen->ComboD[ComboAt(Link->X,Link->Y+8)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Link->X+15,Link->Y+8)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Link->X,Link->Y+15)]==comboID)return true;
	if(Screen->ComboD[ComboAt(Link->X+15,Link->Y+15)]==comboID)return true;
	return false;
}//end
void NoDirs(){//start
	Link->InputDown=false;Link->PressDown=false;
	Link->InputRight=false;Link->PressRight=false;
	Link->InputLeft=false;Link->PressLeft=false;
	Link->InputUp=false;Link->PressUp=false;
}//end
int countNPCInRange(int x, int y, int radius){//start
	int npcCount = 0;
	for(int i = 1;i<=Screen->NumNPCs();i++){
		npc anNPC = Screen->LoadNPC(i);
		if(anNPC->X>x-(radius+anNPC->HitWidth-1)&&anNPC->X<x+radius&&anNPC->Y>y-(radius+anNPC->HitHeight-1)&&anNPC->Y<y+radius){
			npcCount++;
		}
	}
	return npcCount;
}//end
npc getNthNPCInRange(int x, int y, int radius, int num){//start
	int npcCount = 0;
	for(int i = 1;i<=Screen->NumNPCs();i++){
		npc anNPC = Screen->LoadNPC(i);
		if(anNPC->X>x-(radius+anNPC->HitWidth-1)&&anNPC->X<x+radius&&anNPC->Y>y-(radius+anNPC->HitHeight-1)&&anNPC->Y<y+radius){
			if(npcCount==num){
				return anNPC;
			} else {
				npcCount++;
			}
		}
	}
}//end
void Screen_Freeze(int freeze){//start
	ffc f1 = Screen->LoadFFC(31);
	ffc f2 = Screen->LoadFFC(32);
	if(freeze==2){
		f1->Data = COMBO_FRZ1;
		f2->Data = COMBO_FRZ2;
		isFrozen=true;
	} else if(freeze==1){
		f1->Data = COMBO_FRZ1;
		f2->Data = 0;
		isFrozen=true;
	} else {
		f1->Data = 0;
		f2->Data = 0;
		isFrozen=false;
	}
}//end
int getNPCfromUID(npc n){//start
	for(int i = 1;i<=Screen->NumNPCs();i++){
		npc anNPC = Screen->LoadNPC(i);
		if(anNPC->UID==n->UID)return i;
	}
	return -1;
}//end
void ffcSolid(ffc anFFC){//start
	int lspdboost = Ceiling(1.5+LinkMovement_GetLinkSpeedBoost());
	int width = anFFC->EffectWidth;
	int height = anFFC->EffectHeight;
	int bottomheight=height;
	if(!Link->BigHitbox	)bottomheight-=8;
	if(bottomheight<=0)return;
	if(Link->Y>=anFFC->Y-(16+lspdboost)){//start inputdown
		if(Link->Y<=anFFC->Y-16){
			if(Link->X>=anFFC->X-15){
				if(Link->X<=anFFC->X+(width-1)){
					if(Link->InputDown){
						if(Link->Y!=anFFC->Y-16)Link->Y=anFFC->Y-16;
						Link->Dir=DIR_DOWN;
						if(Link->X>=anFFC->X+(width-4)){
							if(CanWalk(Link->X,Link->Y,DIR_RIGHT,Abs(Link->X-(anFFC->X+width)),false))Link->X=anFFC->X+width;
						} else if(Link->X<=anFFC->X-12)if(CanWalk(Link->X,Link->Y,DIR_LEFT,Abs(Link->X-anFFC->X-16),false))Link->X=anFFC->X-16;
					}
					Link->InputDown=false;
					Link->PressDown=false;
					return;
				}
			}
		}//end
	}
	if(Link->Y<=anFFC->Y+(bottomheight+lspdboost)){//start inputup
		if(Link->Y>=anFFC->Y+bottomheight){
			if(Link->X>=anFFC->X-15){
				if(Link->X<=anFFC->X+(width-1)){
					if(Link->InputUp){
						if(Link->Y!=anFFC->Y+bottomheight)Link->Y=anFFC->Y+bottomheight;
						Link->Dir=DIR_UP;
						if(Link->X>=anFFC->X+(width-4)){
							if(CanWalk(Link->X,Link->Y,DIR_RIGHT,Abs(Link->X-(anFFC->X+width)),false))Link->X=anFFC->X+width;
						} else if(Link->X<=anFFC->X-12)if(CanWalk(Link->X,Link->Y,DIR_LEFT,Abs(Link->X-anFFC->X-16),false))Link->X=anFFC->X-16;
					}
					Link->InputUp=false;
					Link->PressUp=false;
					return;
				}
			}
		}//end
	}
	if(Link->X>=anFFC->X-(16+lspdboost)){//start inputright
		if(Link->X<=anFFC->X-16){
			if(Link->Y<=anFFC->Y+(bottomheight-1)){
				if(Link->Y>=anFFC->Y-15){
					if(Link->InputRight){
						if(Link->X!=anFFC->X-16)Link->X=anFFC->X-16;
						Link->Dir=DIR_RIGHT;
						if(Link->Y>=anFFC->Y+(bottomheight-4)){
							if(CanWalk(Link->X,Link->Y,DIR_DOWN,Abs(Link->Y-(anFFC->Y+bottomheight)),false))Link->Y=anFFC->Y+bottomheight;
						} else if(Link->Y<=anFFC->Y-12)if(CanWalk(Link->X,Link->Y,DIR_UP,Abs(Link->Y-(anFFC->Y-16)),false))Link->Y=anFFC->Y-16;
					}
					Link->InputRight=false;
					Link->PressRight=false;
					return;
				}
			}
		}//end
	}
	if(Link->X<=anFFC->X+(width+lspdboost)){//start inputleft
		if(Link->X>=anFFC->X+width){
			if(Link->Y>=anFFC->Y-15){
				if(Link->Y<=anFFC->Y+(bottomheight-1)){
					if(Link->InputLeft){
						if(Link->X!=anFFC->X+width)Link->X=anFFC->X+width;
						Link->Dir=DIR_LEFT;
						if(Link->Y>=anFFC->Y+(bottomheight-4)){
							if(CanWalk(Link->X,Link->Y,DIR_DOWN,Abs(Link->Y-(anFFC->Y+bottomheight)),false))Link->Y=anFFC->Y+bottomheight;
						} else if(Link->Y<=anFFC->Y-12)if(CanWalk(Link->X,Link->Y,DIR_UP,Abs(Link->Y-(anFFC->Y-16)),false))Link->Y=anFFC->Y-16;
					}
					Link->InputLeft=false;
					Link->PressLeft=false;
					return;
				}
			}
		}//end
	}
}//end
int LimitFPSStateSave = 00b;//start
void saveFPSstate(){
	/*if(!(LimitFPSStateSave & 10b)){
		if(Game->CappedFPS)LimitFPSStateSave |= 11b;
		else LimitFPSStateSave |= 10b;
	}*/
}

void loadFPSstate(){
	/*if((LimitFPSStateSave & 10b) == 10b){
		if((LimitFPSStateSave & 01b) == 01b)Game->CappedFPS = true;
		else Game->CappedFPS = false;
		LimitFPSStateSave = 0;
	}*/
}//end
int fullCounter(int counter){//start
	return Game->Counter[counter]+Game->DCounter[counter];
}//end
bool isOverworldScreen(){//start
	dmapdata dm = Game->LoadDMapData(Game->GetCurDMap());
	if(IsDungeonFlag())return false;
	if(IsInteriorFlag())return false;
	if(dm->Type%2)return true;
	return false;
}//end
//end Misc Functions

//Not Mine, but modified:
//start EmptyBottles
//X--------------------X
//|  Bottle Constants  | start
//X--------------------X
const int BOTTLE_SETTING_NO_WATER = 0; //Set to 1 if water shouldn't be bottleable

const int TIL_BOTTLE = 63980; //First of the tiles used for the bottle items. Should come in four identical rows.
                              //Tile order in each row should go as such:
							  //Empty, Empty, Red Potion, Green Potion, Blue Potion, Water, Fairy, Bee

const int POTION_HEARTS = 20; //Hearts the red potion heals
const int POTION_MP = 1024; //MP the green potion restores
const int MILK_HEARTS = 5;

const int LW_WATER = 32; //LWeapon type used for bottled water. Script 1 by default
const int LW_HOTWATER = 33;
const int SPR_BOTTLEWATER = 94; //Sprite used for bottled water
const int SPR_BOTTLEWATERHOT = 95; //^
const int SFX_BOTTLEWATER = 55; //Sound when water is dumped out

const int FAIRY_HEARTS = 3; //Hearts healed by a fairy
const int CMB_FAIRY = 13935; //Fairy combo
const int CS_FAIRY = 8; //Fairy cset
const int SFX_FAIRY = 53; //Sound that plays when a fairy appears

const int IC_BOTTLE = 70; //Item class used for bottles

const int I_BOTTLE1 = 146; //Item ID for the first bottle (Level 1)
const int I_BOTTLE2 = 147; //Item ID for the second bottle (Level 2)
const int I_BOTTLE3 = 148; //Item ID for the third bottle (Level 3)
const int I_BOTTLE4 = 149; //Item ID for the fourth bottle (Level 4)
const int I_BOTTLE5 = 150; //Item ID for the fifth bottle (Level 5)
const int I_BOTTLE6 = 151; //Item ID for the sixth bottle (Level 6)

const int FREQ_HEARTREFILL = 8; //Frequency in frames at which potions/fairies restore hearts
const int SFX_HEARTREFILL = 22; //Sound when potion/fairy restores a heart
const int FREQ_MAGICSOUND = 8; //Frequency in frames where the magic refill sound plays
const int SFX_MAGICREFILL = 23; //Magic refill sound
						  
const int TIL_BOTTLESWING = 64111; //Tile of a right facing open bottle used when trying to catch something
const int CS_BOTTLESWING = 11; //CSet of the swinging bottle
const int SFX_BOTTLESWING = 30; //Sound used for the bottle being swung

const int I_WATERBOTTLE = 175; //Item for bottle water pickup
const int I_FAIRYBOTTLE = 177; //Item for bottle fairy pickup
const int I_HOTWATERBOTTLE = 176; //Item for bottle hot water pickup

const int STR_CANTAFFORD = 29; //Message for when you can't afford an item
const int STR_NOBOTTLE = 42; //Message for when you don't have a bottle to store a potion in
const int STR_WATERCOOLED = 36; //Message for when hot spring water cools off

const int C_WHITE = 0x01; //The color white
const int C_BLACK = 0x0F; //The color black

int TIME_HOTWATER = TIME_HOUR*4;

//X--------------------------X
//|  Empty Bottle Functions  |
//X--------------------------X

//X--------------------------------------------------------X
//|  These constants don't need to be changed.             |
//|  They just define various states of the empty bottle.  |
//|  BS_ constants are also used for  the potion filling   |
//|  pickup item script. Look here to see what to set D2   |
//|  to for that.                                          |
//X--------------------------------------------------------X

const int BS_EMPTY = 0;
const int BS_POTIONRED = 1;
const int BS_POTIONGREEN = 2;
const int BS_POTIONBLUE = 3;
const int BS_WATER = 4;
const int BS_FAIRY = 5;
const int BS_MILK = 6;
const int BS_HALFMILK = 7;
const int BS_BUG = 8;
const int BS_CHATEAU = 9;
const int BS_POE = 10;
const int BS_BPOE = 11;
const int BS_HOTWATER = 12;
const int BS_MUSHROOM = 13;
const int BS_GOLDDUST = 14;
const int BS_FISH = 15;
const int BS_DEKUPRINCESS = 16;
const int BS_SEAHORSE = 17;
//const int BS_ZORAEGG = 18;

const int BSI_BOTTLEUSED = 6;
const int BSI_BOTTLETIMER = 7;
const int BSI_OLDHP = 8;
const int BSI_OLDMP = 9;
const int BSI_FAIRYTIMER = 10;
const int BSI_FAIRYREVIVE = 11;
//end
//vars
int usingBugs = 0;
int BottleStateForTango = -1;
//
//---------------------------------------------------------X
//start functions

int BottleState[12];//0-5: States of bottles, 6: Bottle used, 
                    //7: Potion timer, 8: OldHP, 9: OldMP

int springTimers[6];
//This function should be called at the beginning of your global and 
//refreshes the graphics for the bottles.
void RefreshBottles(){
	for(int i=0; i<6; i++){
		CopyTile(TIL_BOTTLE+1+BottleState[i], TIL_BOTTLE+20*i);
	}
}

int UsingEmptyBottle(){
	if(Link->Action!=LA_WALKING&&Link->Action!=LA_NONE)return -1;
	if(Link->PressA){
		int id = GetEquipmentA();
		if(id>0){
			itemdata A = Game->LoadItemData(id);
			if(A->Family==IC_BOTTLE)
				return A->Level-1;
		}
	}
	else if(Link->PressB){
		int id = GetEquipmentB();
		if(id>0){
			itemdata B = Game->LoadItemData(id);
			if(B->Family==IC_BOTTLE){
				return B->Level-1;
			}
		}
	}
	return -1;
}

bool CanFillBottle(){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=0; i<6; i++){
		if(Link->Item[bottles[i]]&&BottleState[i]==BS_EMPTY)
			return true;
	}
	return false;
}

int FillBottle(int state){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=0; i<6; i++){
		if(Link->Item[bottles[i]]&&BottleState[i]==BS_EMPTY){
			BottleState[i] = state;
			RefreshBottles();
			return i;
		}
	}
}

int HasFairy(){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=0; i<6; i++){
		if(Link->Item[bottles[i]]&&BottleState[i]==BS_FAIRY)
			return i;
	}
	return -1;
}

//This function goes in the while loop of your global script before waitdraw
void EmptyBottleGlobal(){//start defaultBottleCode
	for(int i=0;i<6;i++){
		if(springTimers[i]>-45000){
			if(BottleState[i]==BS_HOTWATER){
				if(trueTime>=springTimers[i]){
					BottleState[i]=BS_WATER;
					RefreshBottles();
					int args[8] = {STR_WATERCOOLED};
					RunFFCScript(FFC_SHOWSTRING,args);
				}
			} else {
				springTimers[i]=-45001;
			}
		}
	}
	int bottle = BottleState[BSI_BOTTLEUSED];
	if(BottleState[BSI_BOTTLETIMER]>0){
		bool hpHeal = (BottleState[bottle]==BS_POTIONRED||BottleState[bottle]==BS_MILK||BottleState[bottle]==BS_HALFMILK||BottleState[bottle]==BS_POE||BottleState[bottle]==BS_BPOE);
		if(hpHeal){
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_HEARTREFILL)){
				Link->HP += 16;
				Game->PlaySound(SFX_HEARTREFILL);
				if(Link->HP>=Link->MaxHP){
					BottleState[BSI_BOTTLETIMER] = 0;
				}
			}
		}
		else if(BottleState[bottle]==BS_POTIONGREEN){
			Link->MP += 2;
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_MAGICSOUND))
				Game->PlaySound(SFX_MAGICREFILL);
			if(Link->MP>=Link->MaxMP){
				BottleState[BSI_BOTTLETIMER] = 0;
			}
		}
		else if(BottleState[bottle]==BS_POTIONBLUE||BottleState[bottle]==BS_CHATEAU){
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_HEARTREFILL)&&Link->HP<BottleState[BSI_OLDHP]+POTION_HEARTS*16&&Link->HP<Link->MaxHP){
				Link->HP += 16;
				Game->PlaySound(SFX_HEARTREFILL);
			}
			if(Link->MP<BottleState[BSI_OLDMP]+POTION_MP&&Link->MP<Link->MaxMP){
				if(!(BottleState[BSI_BOTTLETIMER]%FREQ_MAGICSOUND))
					Game->PlaySound(SFX_MAGICREFILL);
				Link->MP += 2;
			}
			if(Link->HP>=Link->MaxHP&&Link->MP>=Link->MaxMP){
				BottleState[BSI_BOTTLETIMER] = 0;
			}
		}
		else if(BottleState[bottle]==BS_FAIRY){
			if(BottleState[BSI_BOTTLETIMER]<2&&BottleState[BSI_FAIRYTIMER]<120)
				BottleState[BSI_BOTTLETIMER] = 2;
			BottleState[BSI_FAIRYTIMER]++;
			int X = Link->X+VectorX(16*(BottleState[BSI_FAIRYTIMER]/120), BottleState[BSI_FAIRYTIMER]*8);
			int Y = Link->Y+VectorY(8*(BottleState[BSI_FAIRYTIMER]/120), BottleState[BSI_FAIRYTIMER]*8)-BottleState[BSI_FAIRYTIMER]/8;
			if(BottleState[BSI_FAIRYREVIVE]==1){
				if(BottleState[BSI_FAIRYTIMER]<10||BottleState[BSI_FAIRYTIMER]>110)
					Screen->Rectangle(6, 0, 0, 256, 176, C_BLACK, 1, 0, 0, 0, true, 64);
				else
					Screen->Rectangle(6, 0, 0, 256, 176, C_BLACK, 1, 0, 0, 0, true, 128);
				Screen->FastTile(6, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, Link->Tile, 6, 128);
			}
			if(BottleState[BSI_FAIRYTIMER]<80||!(BottleState[BSI_FAIRYTIMER]%2))
				Screen->FastCombo(6, X, Y, CMB_FAIRY, CS_FAIRY, 128);
			if(!(BottleState[BSI_BOTTLETIMER]%FREQ_HEARTREFILL)&&Link->HP<Link->MaxHP){
				Link->HP += 16;
				Game->PlaySound(SFX_HEARTREFILL);
			}
			if(Link->HP>=Link->MaxHP&&BottleState[BSI_FAIRYTIMER]>=120){
				BottleState[BSI_BOTTLETIMER] = 0;
			}
		}
		BottleState[BSI_BOTTLETIMER]--;
		NoAction();
		if(BottleState[BSI_BOTTLETIMER]<=0){
			if(BottleState[bottle]==BS_MILK){
				BottleState[bottle]=BS_HALFMILK;
			} else {
				BottleState[bottle] = BS_EMPTY;
			}
			BottleState[BSI_BOTTLEUSED] = -1;
			RefreshBottles();
			Screen_Freeze(0);
			isBottleFrozen=false;
		}
	}
	else{
		bottle = UsingEmptyBottle();
		if(bottle>-1){
			bool refresh = BottleState[bottle]!=BS_EMPTY;
			if(BottleState[bottle]==BS_EMPTY){
				int scriptname[] = "Bottle_Empty";
				int scriptid = Game->GetFFCScript(scriptname);
				int Args[8] = {bottle};
				RunFFCScript(scriptid, Args);
			} 
			else if(BottleState[bottle]==BS_POTIONRED){
				if(Link->HP==Link->MaxHP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*POTION_HEARTS;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			}
			else if(BottleState[bottle]==BS_POTIONGREEN){
				if(Link->MP==Link->MaxMP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = POTION_MP/2;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			}
			else if(BottleState[bottle]==BS_POTIONBLUE){
				if(Link->HP==Link->MaxHP&&Link->MP==Link->MaxMP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = Max(FREQ_HEARTREFILL*POTION_HEARTS, POTION_MP/2);
					BottleState[BSI_OLDHP] = Link->HP;
					BottleState[BSI_OLDMP] = Link->MP;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			}
			else if(BottleState[bottle]==BS_WATER){
				Link->Action = LA_ATTACKING;
				lweapon l = CreateLWeaponAt(LW_WATER, Link->X+InFrontX(Link->Dir, 0), Link->Y+InFrontY(Link->Dir, 0));
				l->UseSprite(SPR_BOTTLEWATER);
				l->DeadState = (l->ASpeed*l->NumFrames)-2;
				l->CollDetection = false;
				Game->PlaySound(SFX_BOTTLEWATER);
				BottleState[bottle] = BS_EMPTY;
				RefreshBottles();
			}
			else if(BottleState[bottle]==BS_FAIRY){
				if(Link->HP==Link->MaxHP){
					Game->PlaySound(SFX_ERROR);
				}
				else{
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*FAIRY_HEARTS;
					BottleState[BSI_FAIRYTIMER] = 0;
					BottleState[BSI_FAIRYREVIVE] = 0;
					Game->PlaySound(SFX_FAIRY);
					Screen_Freeze(2);
					isBottleFrozen=true;
				}//end
			} else if(BottleState[bottle]==BS_MILK||BottleState[bottle]==BS_HALFMILK){
				if(Link->HP==Link->MaxHP){
					Game->PlaySound(SFX_ERROR);
				} else {
					BottleState[BSI_BOTTLEUSED] = bottle;
					BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*MILK_HEARTS;
					Screen_Freeze(2);
					isBottleFrozen=true;
				}
			} else if(BottleState[bottle]==BS_CHATEAU){
				BottleState[BSI_BOTTLEUSED] = bottle;
				BottleState[BSI_BOTTLETIMER] = Max(FREQ_HEARTREFILL*POTION_HEARTS, POTION_MP/2);
				Screen_Freeze(2);
				isBottleFrozen=true;
				Link->Item[INF_MAGIC]=true;
			} else if(BottleState[bottle]==BS_POE||BottleState[bottle]==BS_BPOE){
				if(Link->HP==Link->MaxHP){
					Game->PlaySound(SFX_ERROR);
				} else {
					int rand = Rand(0,10);
					if(!rand){
						Link->HP=1;
					} else {
						BottleState[BSI_BOTTLEUSED] = bottle;
						BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*(rand*2);
						Screen_Freeze(2);
						isBottleFrozen=true;
					}
				}
			} else if(BottleState[bottle]==BS_BUG){
				usingBugs = 30;
				BottleState[bottle]=BS_EMPTY;
			} else if(BottleState[bottle]==BS_HOTWATER){
				springTimers[bottle]=0;
				Link->Action = LA_ATTACKING;
				lweapon l = CreateLWeaponAt(LW_HOTWATER, Link->X+InFrontX(Link->Dir, 0), Link->Y+InFrontY(Link->Dir, 0));
				l->UseSprite(SPR_BOTTLEWATERHOT);
				l->DeadState = (l->ASpeed*l->NumFrames)-2;
				l->CollDetection = false;
				Game->PlaySound(SFX_BOTTLEWATER);
				BottleState[bottle] = BS_EMPTY;
			} else if(BottleState[bottle]==BS_MUSHROOM){
				//Nothing
			} else if(BottleState[bottle]==BS_GOLDDUST){
				//Nothing
			} else if(BottleState[bottle]==BS_FISH){
				//Nothing
			} else if(BottleState[bottle]==BS_DEKUPRINCESS){
				//Nothing
			} else if(BottleState[bottle]==BS_SEAHORSE){
				//Nothing
			}
			if(refresh)
				RefreshBottles();
		}
		int fairy = HasFairy();//start fairyRevive
		if(Link->HP<=0&&fairy>-1){
			Link->HP = 1;
			BottleState[BSI_BOTTLEUSED] = fairy;
			BottleState[BSI_BOTTLETIMER] = FREQ_HEARTREFILL*FAIRY_HEARTS;
			BottleState[BSI_FAIRYTIMER] = 0;
			BottleState[BSI_FAIRYREVIVE] = 1;
			Game->PlaySound(SFX_FAIRY);
			Screen_Freeze(2);
			isBottleFrozen=true;
		}//end
	}
}


//X-------------------------------X
//|  Empty Bottle Action Scripts  |
//X-------------------------------X

ffc script Bottle_Empty{
	void run(int bottleid){
		int Angle = 0;
		if(Link->Dir==DIR_UP)
			Angle = -90;
		else if(Link->Dir==DIR_DOWN)
			Angle = 90;
		else if(Link->Dir==DIR_LEFT)
			Angle = 180;
		Game->PlaySound(SFX_BOTTLESWING);
		Link->Action = LA_ATTACKING;
		int Collected = 0;
		for(int i=-45; i<45; i+=10){
			int X = Link->X+VectorX(12, Angle+i);
			int Y = Link->Y+VectorY(12, Angle+i);
			Screen->DrawTile(2, X, Y, TIL_BOTTLESWING, 1, 1, CS_BOTTLESWING, -1, -1, X, Y, Angle+i+90, 0, true, 128);
			if(!Collected||Collected==BS_WATER||Collected==BS_HOTWATER){
				if(OnWater(X+8, Y+8)&&!Collected&&!BOTTLE_SETTING_NO_WATER){
					if(ScreenFlag(SF_MISC,SFM_SCRIPT2)>0){
						Collected = BS_HOTWATER;
					} else {
						Collected = BS_WATER;
					}
				}
				for(int j=1; j<=Screen->NumItems(); j++){
					item itm = Screen->LoadItem(j);
					if(itm->ID==I_FAIRY||itm->ID==I_FAIRYSTILL){
						if(RectCollision(itm->X+itm->HitXOffset, itm->Y+itm->HitYOffset, itm->X+itm->HitXOffset+itm->HitWidth, itm->Y+itm->HitYOffset+itm->HitHeight, X+4, Y+4, X+11, Y+11)){
							Collected = BS_FAIRY;
							Remove(itm);
							break;
						}
					}
				}
			}
			WaitNoAction();
		}
		if(Collected==BS_WATER){
			BottleState[bottleid] = BS_WATER;
			RefreshBottles();
			item itm = CreateItemAt(I_WATERBOTTLE, Link->X, Link->Y);
			itm->Pickup = IP_HOLDUP;
		}
		else if(Collected==BS_HOTWATER){
			BottleState[bottleid] = BS_HOTWATER;
			springTimers[bottleid] = trueTime + TIME_HOTWATER;
			RefreshBottles();
			item itm = CreateItemAt(I_HOTWATERBOTTLE, Link->X, Link->Y);
			itm->Pickup = IP_HOLDUP;
		}
		else if(Collected==BS_FAIRY){
			BottleState[bottleid] = BS_FAIRY;
			RefreshBottles();
			item itm = CreateItemAt(I_FAIRYBOTTLE, Link->X, Link->Y);
			itm->Pickup = IP_HOLDUP;
		}
		WaitNoAction(10);
	}
	bool OnWater(int x, int y){
		int ct = Screen->ComboT[ComboAt(x, y)];
		if(ct==CT_WATER||ct==CT_SHALLOWWATER)
			return true;
		return false;
	}
}

//end
//X----------------------------X
//|  Other Associated Scripts  |
//X----------------------------X

item script ShopBottleFill{
	void run(int state){
		FillBottle(state);
	}
}

item script BottleFill{
	void run(int str, int state){
		if(!CanFillBottle())str = STR_NOBOTTLE;
		BottleStateForTango = state;
		remchr(shopString,0);
		getBottleStateName(state,shopString);
		int args[8] = {str};
		RunFFCScript(FFC_SHOWSTRING,args);
	}
}

ffc script ItemShop{//start
	void run(int id, int strdescription, int price, int potion){
		itemdata ic = Game->LoadItemData(id);
		while(true){
			if(Link->X>this->X-8&&Link->X<this->X+8&&Link->Y>this->Y&&Link->Y<this->Y+10&&Link->Dir==DIR_UP){
				if(Link->PressR){
					if(fullCounter(CR_RUPEES)>=price){
						if(potion>0&&!CanFillBottle()){
							ShowMessageAndWait(STR_NOBOTTLE);
							NoAction();
						}
						else{
							item itm = CreateItemAt(id, Link->X, Link->Y);
							itm->Pickup = IP_HOLDUP;
							Game->DCounter[CR_RUPEES] -= price;
							for(int i=0; i<10; i++){
								WaitNoAction();
							}
						}
					}
					else{
						ShowMessageAndWait(STR_CANTAFFORD);
						NoAction();
					}
				}
			}
			DrawPrice(this, price);
			Waitframe();
		}
	}
	void DrawPrice(ffc this, int price){
		int xoff = -2;
		if(price>999)
			xoff = -8;
		else if(price>99)
			xoff = -6;
		else if(price>9)
			xoff = -4;
		Screen->DrawInteger(5, this->X+8+xoff+1, this->Y+18+1, FONT_Z3SMALL, C_BLACK, -1, -1, -1, price, 0, 128);
		Screen->DrawInteger(5, this->X+8+xoff, this->Y+18, FONT_Z3SMALL, C_WHITE, -1, -1, -1, price, 0, 128);
	}
}//end
//custom emptybottles functions
bool ClearBottle(int state){
	int bottles[6] = {I_BOTTLE1, I_BOTTLE2, I_BOTTLE3, I_BOTTLE4, I_BOTTLE5, I_BOTTLE6};
	for(int i=5; i>=0; i--){
		if(Link->Item[bottles[i]]&&BottleState[i]==state){
			BottleState[i] = 0;
			RefreshBottles();
			return true;
		}
	}
	return false;
}
//end EmptyBottles
//start Signpost
ffc script Signpost{
    void run(int m,int input,bool largeHitbox,bool anySide){
        int loc = ComboAt(this->X,this->Y);
        while(true){
            while(!AgainstComboBase(loc,largeHitbox,anySide) || !SelectPressInput(input)) Waitframe();
            SetInput(input,false);
            SignShowMessageAndWait(m);
            Waitframe();
        }
    }
    bool AgainstComboBase(int loc, bool largeHitbox, bool anySide){
		if(largeHitbox && !anySide){
			return Link->Z == 0 && (Link->Dir == DIR_UP && Link->Y == ComboY(loc)+16 && Abs(Link->X-ComboX(loc)) < 8);
		} else if (!largeHitbox&&!anySide){
			return Link->Z == 0 && (Link->Dir == DIR_UP && Link->Y == ComboY(loc)+8 && Abs(Link->X-ComboX(loc)) < 8);
		} else if (largeHitbox && anySide){
			return Link->Z == 0 && ((Link->Dir == DIR_UP && Link->Y == ComboY(loc)+16 && Abs(Link->X-ComboX(loc)) < 8)||(Link->Dir == DIR_DOWN && Link->Y == ComboY(loc)-16 && Abs(Link->X-ComboX(loc)) < 8)||(Link->Dir == DIR_LEFT && Link->X == ComboX(loc)+16 && Abs(Link->Y-ComboY(loc)) < 8)||(Link->Dir == DIR_RIGHT && Link->X == ComboX(loc)-16 && Abs(Link->Y-ComboY(loc)) < 8));
		} else if (!largeHitbox && anySide){
			return Link->Z == 0 && ((Link->Dir == DIR_UP && Link->Y == ComboY(loc)+8 && Abs(Link->X-ComboX(loc)) < 8)||(Link->Dir == DIR_DOWN && Link->Y == ComboY(loc)-16 && Abs(Link->X-ComboX(loc)) < 8)||(Link->Dir == DIR_LEFT && Link->X == ComboX(loc)+16 && Abs(Link->Y-ComboY(loc)) < 8)||(Link->Dir == DIR_RIGHT && Link->X == ComboX(loc)-16 && Abs(Link->Y-ComboY(loc)) < 8));
		} else {return false;}
    }
}

//!!These functions should only be included in your script file once!!
bool SelectPressInput(int input){
    if(input == 0) return Link->PressA;
    else if(input == 1) return Link->PressB;
    else if(input == 2) return Link->PressL;
    else if(input == 3) return Link->PressR;
}
void SetInput(int input, bool state){
    if(input == 0) Link->InputA = state;
    else if(input == 1) Link->InputB = state;
    else if(input == 2) Link->InputL = state;
    else if(input == 3) Link->InputR = state;
}
//end Signpost
//start Bombchus
//Constants used by bombchu script.
const int LW_BOMBCHU = 40; //The weapon ID of the bombchu, must be unique and between 31 and 40.
const int CF_BOMBCHU1 = 98; //Combo solidity on combos locations with this flag will be treated opposite by the bombchu.
const int CF_BOMBCHU2 = 102;
const int CT_BOMBCHU = 143;
const int SFX_BOMBCHU = 17;
item script Bombchu{
	//d0 is the ffc script slot that has the
	//d1 is the step speed. 100 is one pixel.
	//d2 is the sprite. Sprite to use for the bombchu. Sprites are organized UP DOWN LEFT RIGHT.
	//Power is the damage done by the bombchu's explosion
	//The Counter reference in the pickup tab is what counter it will use.
	void run(int ffcScriptNum, int step, int sprite){
		if(!Link->PressA && !Link->PressB) Quit();
		if(CountFFCsRunning(ffcScriptNum) == 0 && Game->Counter[this->Counter] > 0){
			Game->Counter[this->Counter]--;
			Game->PlaySound(SFX_PLACE);
			int args[8] = {step, sprite, this->Power};
			RunFFCScript(ffcScriptNum, args);
		}
	}
}

ffc script Bombchu_FFC{
	void run(int step, int sprite, int damage){
		this->Data=COMBO_INVIS;
		//Create the bombchu infront of link.
		lweapon bombchu = NextToLink(LW_BOMBCHU, 0);
		bombchu->CollDetection = false;
		bombchu->Dir = Link->Dir;
		bombchu->Step = step;
		bombchu->HitZHeight = 2;
		bombchu->UseSprite(sprite);
		int frames = bombchu->NumFrames;
		if(!frames)frames=1;
		bombchu->OriginalTile += bombchu->Dir*frames;
		bombchu->Tile = bombchu->OriginalTile;
		//Loop until it becomes invalid.
		while(bombchu->isValid()){
			if(!(gameframe%6))Game->PlaySound(SFX_BOMBCHU);
			//Update the sprite based off direction.
			//Declare variables to be used to detect collisions.
			bool contact;
			int dir = bombchu->Dir;
			//If the bombchu is about to go off screen expode.
			if(dir == DIR_UP) contact = (bombchu->Y - Ceiling(step/100) <= 2);
			else if(dir == DIR_DOWN) contact = (bombchu->Y + Ceiling(step/100) >= 150);
			else if(dir == DIR_LEFT) contact = (bombchu->X - Ceiling(step/100) <= 4);
			else if(dir == DIR_RIGHT) contact = (bombchu->X + Ceiling(step/100) >= 236);
			//If the bombchu collided with a npc expode.
			for(int i = Screen->NumNPCs(); i > 0 && !contact; i--){
				npc n = Screen->LoadNPC(i);
				if(!n->CollDetection) continue;
				if(n->ID == NPC_ITEMFAIRY) continue;
				if(n->Type == NPCT_PEAHAT && n->Step != 0 && n->Z == 0) continue;
				if(n->Defense[NPCD_SCRIPT] == NPCDT_IGNORE) continue;
				if(Collision(n, bombchu)) contact = true;
			}
			//If the bombchu is about to hit something solid according to bombchu solidity explode.
			if(!contact){
				int x = bombchu->X + AtFrontX(bombchu->Dir);
				int y = bombchu->Y + AtFrontY(bombchu->Dir);
				int combo = ComboAt(x,y);
				if(!contact){
					if(Screen->ComboT[combo]==CT_BOMBCHU&&Screen->ComboI[combo]==CF_BOMBCHU1&&Screen->ComboF[combo]==CF_BOMBCHU2) contact = !Screen->isSolid(x, y);
					else contact = Screen->isSolid(x, y);
				}
				if(IsWater(combo) || IsPit(combo) || Screen->ComboT[combo] == CT_PITFALL) contact = true;
			}
			//If contact was set to true explode.
			if(contact){
				lweapon blast = CreateLWeaponAt(LW_BOMBBLAST, bombchu->X, bombchu->Y);
				blast->Damage = damage;
				bombchu->DeadState = 0;
			}
			Waitframe();
		}
	}
}
//end Bombchus
//start LayerOverhead
////////////////////////////////////////////////////////////////
// Overhead
// by grayswandir
////////////////////////////////////////////////////////////////
// Makes certain overhead layers transparent/invisible while link is
// underneath them.
////////////////////////////////////////////////////////////////
// Setup:
// Put Overhead_Update() in your active loop.
// Mess with the Configuration section if you want.
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Configuration

// Set to 1 to make the tiles disappear completely, instead of being drawn
// transparently.
int OVERHEAD_INVISIBLE = 1;

// These are the layers that are used. Set to 1 to enable, and 0 to disable.
const int OVERHEAD_USE_L3 = 0;
const int OVERHEAD_USE_L4 = 1;
const int OVERHEAD_USE_L5 = 0;
const int OVERHEAD_USE_L6 = 0;

// Change this to 16 if you have very fast scrolling turned on.
const int OVERHEAD_SCROLL_SPEED = 4;

////////////////////////////////////////////////////////////////
// Code
int Overhead_Data[1416];
const int OVERHEAD_STATE = 0;
const int OVERHEAD_LAST_SCREEN = 1;
const int OVERHEAD_SCROLL_DIR = 2;
const int OVERHEAD_TIMER = 3;
const int OVERHEAD_SCREENS = 4;
const int OVERHEAD_COMBOS = 8;
const int OVERHEAD_CSETS = 712;

const int OVERHEAD_STATE_UNINIT = 0;
const int OVERHEAD_STATE_SCROLLING = 1;
const int OVERHEAD_STATE_WORKING = 2;

void Overhead_Update() {
	if(hideLayer4){
		OVERHEAD_INVISIBLE = 1;
	} else {
		OVERHEAD_INVISIBLE = 0;
	}
  int map; int screen; int location; int layer; bool under; int offset;

  // If this is the first time this function has been called, do some setup.
  if (OVERHEAD_STATE_UNINIT == Overhead_Data[OVERHEAD_STATE]) {
    Overhead_Data[OVERHEAD_STATE] = OVERHEAD_STATE_SCROLLING;
    Overhead_Data[OVERHEAD_LAST_SCREEN] = -1;
    for (layer = 3; layer <= 6; ++layer) {
      Overhead_Data[OVERHEAD_SCREENS + layer - 3] = -1;
    }
  }

  // If we've left our current screen, reset the layers we killed.
  screen = (Game->GetCurMap() << 8) + Game->GetCurScreen();
  if (screen != Overhead_Data[OVERHEAD_LAST_SCREEN]) {
    for (layer = 3; layer <= 6; ++layer) {
      // Skip if this layer wasn't recorded.
      if (-1 == Overhead_Data[OVERHEAD_SCREENS + layer - 3]) {continue;}

      // Replace the lost data.
      map = Overhead_Data[OVERHEAD_SCREENS + layer - 3] >> 8;
      screen = Overhead_Data[OVERHEAD_SCREENS + layer - 3] % 256;
      offset = 176 * (layer - 3);
      for (location = 0; location < 176; ++location) {
        Game->SetComboData(map, screen, location, Overhead_Data[OVERHEAD_COMBOS + offset + location]);
      }
    }

    // Remember what screen we're on, so we can tell if we've moved.
    Overhead_Data[OVERHEAD_LAST_SCREEN] = (Game->GetCurMap() << 8) + Game->GetCurScreen();
    Overhead_Data[OVERHEAD_STATE] = OVERHEAD_STATE_SCROLLING;

    // If we've just started scrolling, figure out what direction it's in so
    // we can draw the deleted combos properly. Also reset the timer.
    if (LA_SCROLLING == Link->Action) {
      if (-16 == Link->X) {Overhead_Data[OVERHEAD_SCROLL_DIR] = DIR_RIGHT;}
      if (256 == Link->X) {Overhead_Data[OVERHEAD_SCROLL_DIR] = DIR_LEFT;}
      if (-16 == Link->Y) {Overhead_Data[OVERHEAD_SCROLL_DIR] = DIR_DOWN;}
      if (176 == Link->Y) {Overhead_Data[OVERHEAD_SCROLL_DIR] = DIR_UP;}
      Overhead_Data[OVERHEAD_TIMER] = 0;
    }
  }

  // If we've finished scrolling, copy over the layers and delete them.
  if (LA_SCROLLING != Link->Action && OVERHEAD_STATE_SCROLLING == Overhead_Data[OVERHEAD_STATE]) {
    for (layer = 3; layer <= 6; ++layer) {
      // Skip this layer if we're not configured to use it.
      if (3 == layer && !OVERHEAD_USE_L3) {continue;}
      if (4 == layer && !OVERHEAD_USE_L4) {continue;}
      if (5 == layer && !OVERHEAD_USE_L5) {continue;}
      if (6 == layer && !OVERHEAD_USE_L6) {continue;}

      // If this screen doesn't use this layer, mark as not in use and skip.
      map = Screen->LayerMap(layer);
      screen = Screen->LayerScreen(layer);
      if (-1 == map || -1 == screen) {
        Overhead_Data[OVERHEAD_SCREENS + layer - 3] = -1;
        continue;
      }

      // Save this layer's screen location.
      Overhead_Data[OVERHEAD_SCREENS + layer - 3] = (map << 8) + screen;

      // Grab every combo and cset, and delete the original.
      offset = (layer - 3) * 176;
      for (location = 0; location < 176; ++location) {
        // Grab the data.
        Overhead_Data[OVERHEAD_COMBOS + offset + location] = Game->GetComboData(map, screen, location);
        Overhead_Data[OVERHEAD_CSETS + offset + location] = Game->GetComboCSet(map, screen, location);
        // Delete the original.
        Game->SetComboData(map, screen, location, 0);
      }
    }

    // Update the state so we know we've copied the data.
    Overhead_Data[OVERHEAD_STATE] = OVERHEAD_STATE_WORKING;
  }

  //Modified for Majora's Mask
  under = true;

  // Offsets for scrolling.
  int x = 0;
  int y = 0;
  if (OVERHEAD_STATE_SCROLLING == Overhead_Data[OVERHEAD_STATE]) {
    if (DIR_LEFT == Overhead_Data[OVERHEAD_SCROLL_DIR]) {x = Overhead_Data[OVERHEAD_TIMER];}
    if (DIR_RIGHT == Overhead_Data[OVERHEAD_SCROLL_DIR]) {x = -Overhead_Data[OVERHEAD_TIMER];}
    if (DIR_UP == Overhead_Data[OVERHEAD_SCROLL_DIR]) {y = Overhead_Data[OVERHEAD_TIMER];}
    if (DIR_DOWN == Overhead_Data[OVERHEAD_SCROLL_DIR]) {y = -Overhead_Data[OVERHEAD_TIMER];}
    Overhead_Data[OVERHEAD_TIMER] += OVERHEAD_SCROLL_SPEED;
  }

  // Don't draw if we're under and have it set to be invisible then.
  if (under && OVERHEAD_INVISIBLE) {return;}

  // Draw the overhead layers.
  int opaque = Cond(under, OP_TRANS, OP_OPAQUE);
  for (layer = 3; layer <= 6; ++layer) {
    // Make sure the layer exists.
    if (-1 == Overhead_Data[OVERHEAD_SCREENS + layer - 3]) {continue;}

    // Draw the layer.
    offset = (layer - 3) * 176;
    for (location = 0; location < 176; ++location) {
      int combo = Overhead_Data[OVERHEAD_COMBOS + offset + location];
      if (combo) {
        Screen->FastCombo(layer, ComboX(location) + x, ComboY(location) + y,
                          combo, Overhead_Data[OVERHEAD_CSETS + offset + location],
                          opaque);
      }
    }
  }
}
//end LayerOverhead
//start bottleStateNames
void getBottleStateName(int state, int deststr){//start
	if(!state){
		int str[] = "Empty Bottle";
		strcpy(deststr,str);
	} else if(state==1){
		int str[] = "Red Potion";
		strcpy(deststr,str);
	} else if(state==2){
		int str[] = "Green Potion";
		strcpy(deststr,str);
	} else if(state==3){
		int str[] = "Blue Potion";
		strcpy(deststr,str);
	} else if(state==4){
		int str[] = "Water";
		strcpy(deststr,str);
	} else if(state==5){
		int str[] = "Fairy";
		strcpy(deststr,str);
	} else if(state==6){
		int str[] = "Milk (2/2)";
		strcpy(deststr,str);
	} else if(state==7){
		int str[] = "Milk (1/2)";
		strcpy(deststr,str);
	} else if(state==8){
		int str[] = "Bugs";
		strcpy(deststr,str);
	} else if(state==9){
		int str[] = "Chateau Romani";
		strcpy(deststr,str);
	} else if(state==10){
		int str[] = "Poe";
		strcpy(deststr,str);
	} else if(state==11){
		int str[] = "Big Poe";
		strcpy(deststr,str);
	} else if(state==12){
		int str[] = "Hot Spring Water";
		strcpy(deststr,str);
	} else if(state==13){
		int str[] = "Mushroom";
		strcpy(deststr,str);
	} else if(state==14){
		int str[] = "Gold Dust";
		strcpy(deststr,str);
	} else if(state==15){
		int str[] = "Fish";
		strcpy(deststr,str);
	} else if(state==16){
		int str[] = "Deku Princess";
		strcpy(deststr,str);
	} else if(state==17){
		int str[] = "Seahorse";
		strcpy(deststr,str);
	}
}//end

int getBottleState(int bottle){
	bottle = Clamp(bottle,1,6);
	return BottleState[bottle-1];
}


//end
//Not Mine, not modified:

//Stored in other files:
//my custom settings for tango.zh are located inside tango.zh
//Keyboard reader script in TypeAString.zh